# üîπConexi√≥n


Para conectar una aplicaci√≥n escrita en **Kotlin** con una base de datos **MongoDB**, existen dos opciones principales, seg√∫n el objetivo y el nivel de control que se necesite sobre las operaciones:

1Ô∏è‚É£ Conexi√≥n con el controlador oficial de MongoDB (**MongoDB Driver**)

Es la opci√≥n m√°s directa y de bajo nivel. Permite trabajar con las clases del paquete com.mongodb o org.bson para realizar operaciones CRUD (crear, leer, actualizar y eliminar) sobre las colecciones.
Se utiliza cuando se quiere tener control total sobre las consultas, la conexi√≥n y la conversi√≥n de documentos BSON a objetos Kotlin.

2Ô∏è‚É£ Conexi√≥n mediante una librer√≠a de mapeo (ORM/ODM), como **KMongo**

KMongo es una capa de abstracci√≥n sobre el driver oficial, dise√±ada espec√≠ficamente para Kotlin.
Permite trabajar con data classes y consultas tipadas, simplificando el c√≥digo y haci√©ndolo m√°s idiom√°tico.
Es la opci√≥n m√°s recomendada para proyectos educativos o empresariales donde se busca claridad, seguridad de tipos y menor c√≥digo repetitivo.

A continuaci√≥n veremos un ejemplo pr√°ctico de cada una de las dos formas de conectar Kotlin con MongoDB. Ambos ejemplos se ejecutar√°n sobre MongoDB Community Server en local y se crear√°n con Gradle desde IntelliJ.

## üîπKotlin + Gradle + Driver oficial

**1. Crea un nuevo proyecto**{.azul}

Al nuevo proyecto lo llamaremos, por ejemplo, BDNoSQL.

![alt text](../img/mongo1.png)

**2. A√±adir las dependencias en Gradle**{.azul}

En el archivo **build.gradle.kts**, dentro del bloque dependencies, a√±adimos:

        dependencies {
            implementation("org.mongodb:mongodb-driver-sync:5.2.0")
        }

**3. Ejemplo sobre la colecci√≥n Libros**{.azul}
    
Crea un archivo **Main.kt** en un paquete nuevo llamado **mongo** con el siguiente c√≥digo:


![alt text](../img/mongo2.png)


    import com.mongodb.client.MongoClients
    import com.mongodb.client.MongoCollection
    import com.mongodb.client.MongoDatabase
    import org.bson.Document

    fun main() {
        // 1Conexi√≥n al servidor local
        val uri = "mongodb://localhost:27017"
        val client = MongoClients.create(uri)

        // Seleccionar base de datos
        val database: MongoDatabase = client.getDatabase("biblioteca")

        // Seleccionar colecci√≥n
        val coleccion: MongoCollection<Document> = database.getCollection("libros")

        // Insertar un documento
        val doc = Document("titulo", "1984")
            .append("autor", "George Orwell")
            .append("a√±o", 1949)

        coleccion.insertOne(doc)
        println("Documento insertado correctamente.")

        // Leer documentos
        for (libro in coleccion.find()) {
            println(libro.toJson())
        }

        client.close()
    }


!!!Warning "Advertencia"
    Al ejecutar el programa os aparecer√° el siguiene mensaje:

    ![alt text](../img/mongo3_msg.png) 

    Esto no es un error, solo una advertencia. MongoDB intenta usar **SLF4J** (Simple Logging Facade for Java) para mostrar mensajes de registro (logs) sobre la conexi√≥n, operaciones, etc.  
    Como tu proyecto no incluye ninguna librer√≠a de logging, te avisa de que no podr√° mostrar esos logs internos, pero el programa sigue funcionando perfectamente.
   


## üîπKotlin + Gradle + KMongo

**1. A√±adir las dependencias en Gradle**{.azul}

En el **archivo build.gradle.kts**, dentro del bloque dependencies, a√±adimos:

        dependencies {
            implementation("org.litote.kmongo:kmongo:5.1.0")
        }

**2. Ejemplo sobre la colecci√≥n Libros**{.azul}

   
Crea un archivo **Main.kt** en un paquete nuevo llamado **Kmongo** con el siguiente c√≥digo:

![alt text](../img/mongo4.png)

        import org.litote.kmongo.*

        data class Libros(val titulo: String, val autor: String, val a√±o: Int)

        fun main() {
            // Crear conexi√≥n
            val client = KMongo.createClient() // Por defecto: mongodb://localhost:27017
            val database = client.getDatabase("biblioteca")
            val coleccion = database.getCollection<Libros>()

            // Insertar datos
            val libro = Libros("Fahrenheit 451", "Ray Bradbury", 1953)
            coleccion.insertOne(libro)
            println("Libro insertado correctamente")

            // Consultar datos
            val resultados = coleccion.find()
            resultados.forEach { println(it) }
        
            client.close()
        }


!!!Note "Nota"
    Aparecer√°n los dos libros insertados, tanto en el ejemplo anterior como en este, ya que la colecci√≥n Libros es la misma.

    ![alt text](../img/mongo4_msg.png)


## üîπControl de errores 

Cuando un programa se conecta a una base de datos como MongoDB, siempre existe la posibilidad de que ocurran errores: la base de datos puede no estar disponible, los datos pueden ser incorrectos o una operaci√≥n puede fallar por un conflicto o por formato inv√°lido.

Por eso, es importante incluir control de errores en el c√≥digo, especialmente en las operaciones de conexi√≥n y en las operaciones CRUD (insertar, leer, actualizar, eliminar).

El control de errores se hace con bloques **try-catch**. As√≠ puedes capturar las excepciones y evitar que el programa se detenga bruscamente.

**Buenas pr√°cticas:**

- Verificar que el servidor MongoDB est√° en ejecuci√≥n antes de conectar.
- Usar **try-catch** en las secciones cr√≠ticas del programa (especialmente conexi√≥n e inserci√≥n).
- Mostrar mensajes claros al usuario para facilitar el diagn√≥stico.
- Cerrar el cliente con client.close() en un bloque **finally** si se usa una conexi√≥n persistente.

        try {
            val client = KMongo.createClient() // Por defecto: mongodb://localhost:27017
            val database = client.getDatabase("biblioteca")
            val coleccion = database.getCollection<Libros>()

            // Insertar datos
            val libro = Libros("Fahrenheit 451", "Ray Bradbury", 1953)
            coleccion.insertOne(libro)
            println("Libro insertado correctamente")

            // Consultar datos
            val resultados = coleccion.find()
            resultados.forEach { println(it) }
        
            client.close()

        } catch (e: Exception) {
            println("‚ö†Ô∏è Error al acceder a MongoDB: ${e.message}")
        
        } finally { //si se usa una conexi√≥n persistente.
            // Cierre seguro del cliente
            client?.close()
            println("üîí Conexi√≥n cerrada.")
        }    
    


 <!--  

**Ejemplo de CRUD completo con KMongo**

        import org.litote.kmongo.*

        data class Alumno(val nombre: String, val nota: Double)

        fun main() {
            val client = KMongo.createClient()
            val db = client.getDatabase("instituto")
            val alumnos = db.getCollection<Alumno>()

            // Insertar
            alumnos.insertOne(Alumno("Ana", 8.5))
            alumnos.insertOne(Alumno("Luis", 6.7))

            // Listar
            println("üìã Todos los alumnos:")
            alumnos.find().forEach { println(it) }

            // Actualizar
            alumnos.updateOne(Alumno::nombre eq "Luis", setValue(Alumno::nota, 7.5))

            // Eliminar
            alumnos.deleteOne(Alumno::nombre eq "Ana")

            client.close()
        }
-->
<!--
## Conexi√≥n a MongoDB Atlas (nube)

Solo cambia la URI de conexi√≥n.

Copia la URL que te ofrece Atlas en la secci√≥n Connect ‚Üí Drivers.

    val uri = "mongodb+srv://usuario:password@cluster0.mongodb.net/?retryWrites=true&w=majority"
    val client = MongoClients.create(uri)
    val database = client.getDatabase("biblioteca")


‚ö†Ô∏è Aseg√∫rate de:

- A√±adir tu IP a la lista blanca de Atlas.
- Usar un usuario con permisos de lectura/escritura.
- Especificar correctamente el nombre de la base.

-->
