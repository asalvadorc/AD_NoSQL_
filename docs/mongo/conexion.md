# üîπConexi√≥n


Para conectar una aplicaci√≥n escrita en **Kotlin** con una base de datos **MongoDB**, existen dos opciones principales, seg√∫n el objetivo y el nivel de control que se necesite sobre las operaciones:

1Ô∏è‚É£ Conexi√≥n con el controlador oficial de MongoDB (**MongoDB Driver**)

Es la opci√≥n m√°s directa y de bajo nivel. Permite trabajar con las clases del paquete com.mongodb o org.bson para realizar operaciones CRUD (crear, leer, actualizar y eliminar) sobre las colecciones.
Se utiliza cuando se quiere tener control total sobre las consultas, la conexi√≥n y la conversi√≥n de documentos BSON a objetos Kotlin.

2Ô∏è‚É£ Conexi√≥n mediante una librer√≠a de mapeo (ORM/ODM), como **KMongo**

KMongo es una capa de abstracci√≥n sobre el driver oficial, dise√±ada espec√≠ficamente para Kotlin.
Permite trabajar con data classes y consultas tipadas, simplificando el c√≥digo y haci√©ndolo m√°s idiom√°tico.
Es la opci√≥n m√°s recomendada para proyectos educativos o empresariales donde se busca claridad, seguridad de tipos y menor c√≥digo repetitivo.

A continuaci√≥n veremos un ejemplo pr√°ctico de cada una de las dos formas de conectar Kotlin con MongoDB. Ambos ejemplos se ejecutar√°n sobre MongoDB Community Server en local y se crear√°n con Gradle desde IntelliJ.

## üîπKotlin + Gradle + Driver oficial

**1. Crea un nuevo proyecto**{.azul}

Al nuevo proyecto lo llamaremos, por ejemplo, BDNoSQL.

![alt text](../img/mongo1.png)

**2. A√±adir las dependencias en Gradle**{.azul}

En el archivo **build.gradle.kts**, dentro del bloque dependencies, a√±adimos:

        dependencies {
            implementation("org.mongodb:mongodb-driver-sync:5.2.0")
        }

**3. Ejemplo sobre la colecci√≥n Libros**{.azul}
    
Crea un archivo **Main.kt** en un paquete nuevo llamado **mongo** con el siguiente c√≥digo:


![alt text](../img/mongo2.png)


    import com.mongodb.client.MongoClients
    import com.mongodb.client.MongoCollection
    import com.mongodb.client.MongoDatabase
    import org.bson.Document

    fun main() {
        // 1Conexi√≥n al servidor local
        val uri = "mongodb://localhost:27017"
        val client = MongoClients.create(uri)

        // Seleccionar base de datos
        val database: MongoDatabase = client.getDatabase("biblioteca")

        // Seleccionar colecci√≥n
        val coleccion: MongoCollection<Document> = database.getCollection("libros")

        // Insertar un documento
        val doc = Document("titulo", "1984")
            .append("autor", "George Orwell")
            .append("a√±o", 1949)

        coleccion.insertOne(doc)
        println("Documento insertado correctamente.")

        // Leer documentos
        for (libro in coleccion.find()) {
            println(libro.toJson())
        }

        client.close()
    }


!!!Warning "Advertencia"
    Al ejecutar el programa os aparecer√° el siguiene mensaje:

    ![alt text](../img/mongo3_msg.png) 

    Esto no es un error, solo una advertencia. MongoDB intenta usar **SLF4J** (Simple Logging Facade for Java) para mostrar mensajes de registro (logs) sobre la conexi√≥n, operaciones, etc.  
    Como tu proyecto no incluye ninguna librer√≠a de logging, te avisa de que no podr√° mostrar esos logs internos, pero el programa sigue funcionando perfectamente.
   


## üîπKotlin + Gradle + KMongo

**1. A√±adir las dependencias en Gradle**{.azul}

En el **archivo build.gradle.kts**, dentro del bloque dependencies, a√±adimos:

        dependencies {
            implementation("org.litote.kmongo:kmongo:5.1.0")
        }

**2. Ejemplo sobre la colecci√≥n Libros**{.azul}

   
Crea un archivo **Main.kt** en un paquete nuevo llamado **Kmongo** con el siguiente c√≥digo:

![alt text](../img/mongo4.png)

        import org.litote.kmongo.*

        data class Libros(val titulo: String, val autor: String, val a√±o: Int)

        fun main() {
            // Crear conexi√≥n
            val client = KMongo.createClient() // Por defecto: mongodb://localhost:27017
            val database = client.getDatabase("biblioteca")
            val coleccion = database.getCollection<Libros>()

            // Insertar datos
            val libro = Libros("Fahrenheit 451", "Ray Bradbury", 1953)
            coleccion.insertOne(libro)
            println("Libro insertado correctamente")

            // Consultar datos
            val resultados = coleccion.find()
            resultados.forEach { println(it) }
        
            client.close()
        }


!!!Note "Nota"
    Aparecer√°n los dos libros insertados, tanto en el ejemplo anterior como en este, ya que la colecci√≥n Libros es la misma.

    ![alt text](../img/mongo4_msg.png)


## üîπControl de errores 

Cuando un programa se conecta a una base de datos como MongoDB, siempre existe la posibilidad de que ocurran errores: la base de datos puede no estar disponible, los datos pueden ser incorrectos o una operaci√≥n puede fallar por un conflicto o por formato inv√°lido.

Por eso, es importante incluir control de errores en el c√≥digo, especialmente en las operaciones de conexi√≥n y en las operaciones CRUD (insertar, leer, actualizar, eliminar).

El control de errores se hace con bloques **try-catch**. As√≠ puedes capturar las excepciones y evitar que el programa se detenga bruscamente.

**Buenas pr√°cticas:**

- Verificar que el servidor MongoDB est√° en ejecuci√≥n antes de conectar.
- Usar **try-catch** en las secciones cr√≠ticas del programa (especialmente conexi√≥n e inserci√≥n).
- Mostrar mensajes claros al usuario para facilitar el diagn√≥stico.
- Cerrar el cliente con client.close() en un bloque **finally** si se usa una conexi√≥n persistente.

        try {
            val client = KMongo.createClient() // Por defecto: mongodb://localhost:27017
            val database = client.getDatabase("biblioteca")
            val coleccion = database.getCollection<Libros>()

            // Insertar datos
            val libro = Libros("Fahrenheit 451", "Ray Bradbury", 1953)
            coleccion.insertOne(libro)
            println("Libro insertado correctamente")

            // Consultar datos
            val resultados = coleccion.find()
            resultados.forEach { println(it) }
        
            client.close()

        } catch (e: Exception) {
            println("‚ö†Ô∏è Error al acceder a MongoDB: ${e.message}")
        
        } finally { //si se usa una conexi√≥n persistente.
            // Cierre seguro del cliente
            client?.close()
            println("üîí Conexi√≥n cerrada.")
        }    
    


 <!--  

**Ejemplo de CRUD completo con KMongo**

        import org.litote.kmongo.*

        data class Alumno(val nombre: String, val nota: Double)

        fun main() {
            val client = KMongo.createClient()
            val db = client.getDatabase("instituto")
            val alumnos = db.getCollection<Alumno>()

            // Insertar
            alumnos.insertOne(Alumno("Ana", 8.5))
            alumnos.insertOne(Alumno("Luis", 6.7))

            // Listar
            println("üìã Todos los alumnos:")
            alumnos.find().forEach { println(it) }

            // Actualizar
            alumnos.updateOne(Alumno::nombre eq "Luis", setValue(Alumno::nota, 7.5))

            // Eliminar
            alumnos.deleteOne(Alumno::nombre eq "Ana")

            client.close()
        }
-->
<!--
## Conexi√≥n a MongoDB Atlas (nube)

Solo cambia la URI de conexi√≥n.

Copia la URL que te ofrece Atlas en la secci√≥n Connect ‚Üí Drivers.

    val uri = "mongodb+srv://usuario:password@cluster0.mongodb.net/?retryWrites=true&w=majority"
    val client = MongoClients.create(uri)
    val database = client.getDatabase("biblioteca")


‚ö†Ô∏è Aseg√∫rate de:

- A√±adir tu IP a la lista blanca de Atlas.
- Usar un usuario con permisos de lectura/escritura.
- Especificar correctamente el nombre de la base.

-->

## üîπConstruir una base de datos MongoDB


Existen principalmente dos maneras de crear y poblar una base de datos en MongoDB:

**1.  Inserci√≥n manual de documentos**{.azul}

Podemos crear los documentos directamente desde la consola de MongoDB o desde un programa,
utilizando instrucciones **insertOne()** o **insertMany()** con los datos escritos a mano.
Por ejemplo:

    db.peliculas.insertOne({
        "titol": "La noia terrible",
        "director": "Michael Verhoeven",
        "genere": "Drama",
        "any": 1990
    })

Este m√©todo es √∫til para hacer pruebas r√°pidas o a√±adir registros sueltos,
pero no resulta pr√°ctico cuando tenemos muchos datos.

**2.  Lectura desde un archivo JSON**{.azul}

Cuando ya disponemos de un conjunto de datos estructurados (por ejemplo, en un **archivo json**),
podemos leer el archivo desde un programa y **convertir cada elemento en un documento MongoDB**.
Esto permite crear colecciones completas de forma autom√°tica, sin escribir los documentos uno a uno.
A partir de este archivo, un programa en Kotlin puede leer los datos y a√±adirlos autom√°ticamente
a una colecci√≥n MongoDB mediante las funciones insertOne() o insertMany().

En este ejemplo veremos c√≥mo crear una base de datos MongoDB a partir de un archivo JSON llamado
[peliculas.json](peliculas.json), que ubicaremos en un paquete llamado pelicualas (**src/main/kotlin/peliculas/**).

El programa, desarrollado en Kotlin, realiza los siguientes pasos:

- Lee el archivo JSON usando la librer√≠a kotlinx.serialization/Jackson.
- Convierte cada elemento en un objeto de la clase Pelicula.
- Inserta los objetos directamente en MongoDB usando KMongo.
- Recupera y muestra los datos almacenados en la colecci√≥n.


**Archivo JSON**

    [
    {
        "titol": "La noia terrible",
        "titol_or": "Das schreckliche M√§dchen",
        "director": "Michael Verhoeven",
        "genere": "Drama",
        "durada": 93,
        "any": 1990,
        "actors": ["Lena Stolze", "Hans-Reinhard M√ºller", "Monika Baumgartner"],
        "sinopsi": "Una noia alemanya que viu a Passau inicia una investigaci√≥ sobre el passat..."
    },
    {
        "titol": "Hardcore",
        "titol_or": null,
        "director": "Paul Schrader",
        "genere": "Comedia",
        "durada": 109,
        "any": 1979,
        "actors": ["Peter Boyle", "George C. Scott", "Season Hubley"],
        "sinopsi": "Un home profundament religi√≥s contracta un detectiu per trobar la seua filla..."
    }
    ]


**Estructura del proyecto**

    PeliculasMongo/
    ‚îú‚îÄ build.gradle.kts
    ‚îú‚îÄ src/
    ‚îÇ   ‚îî‚îÄ main/
    ‚îÇ       ‚îî‚îÄ kotlin/
    ‚îÇ           ‚îî‚îÄ peliculas/
    ‚îÇ               ‚îú‚îÄ Pelicula.kt      ‚Üí clase de datos serializable
    ‚îÇ               ‚îî‚îÄ Main.kt          ‚Üí programa principal con KMongo
                    ‚îî‚îÄ Peliculas.json   ‚Üí archivo con las pel√≠culas


**MainSerialization.kt**

Lee el archivo JSON usando la librer√≠a kotlinx.serialization.

    package peliculas


    import kotlinx.serialization.Serializable
    import kotlinx.serialization.builtins.ListSerializer
    import kotlinx.serialization.json.Json
    import org.litote.kmongo.KMongo
    import org.litote.kmongo.getCollection
    import java.io.File


    @Serializable
    data class Pelicula(
        val titol: String = "",
        val titol_or: String? = null,
        val director: String = "",
        val genere: String = "",
        val durada: Int = 0,
        val any: Int = 0,
        val actors: List<String>? = null,
        val sinopsi: String = ""
    )


    fun main() {
        val ruta = "src/main/kotlin/peliculas/peliculas.json"
        val archivo = File(ruta)

        if (!archivo.exists()) {
            println("‚ùå No se ha encontrado el archivo $ruta")
            return
        }

        println("üìñ Leyendo archivo $ruta ...")

        try {
            // 1Ô∏è‚É£ Leer y deserializar las pel√≠culas con kotlinx.serialization
            val json = Json { ignoreUnknownKeys = true }
            val peliculas: List<Pelicula> = json.decodeFromString(
                ListSerializer(Pelicula.serializer()),
                archivo.readText(Charsets.UTF_8)
            )

            println("‚úÖ Se han le√≠do ${peliculas.size} pel√≠culas del archivo.")

            // Conexi√≥n a MongoDB con KMongo
            val cliente = KMongo.createClient("mongodb://localhost:27017")
            val bd = cliente.getDatabase("peliculas_db")
            val coleccion = bd.getCollection<Pelicula>()

            // Limpiar colecci√≥n
            coleccion.drop()

            // Insertar todas las pel√≠culas directamente (sin Document)
            coleccion.insertMany(peliculas)
            println("üíæ ${peliculas.size} pel√≠culas insertadas correctamente.\n")

            // Consultar y mostrar todas
            val lista = coleccion.find().toList()
            println("üìú Contenido de la colecci√≥n en MongoDB:\n")

            var i = 1
            for (p in lista) {
                println("üéûÔ∏è $i. ${p.titol} (${p.any})")
                println("   üé¨ Director: ${p.director}")
                println("   üß© G√©nero: ${p.genere}")
                println("   ‚è±Ô∏è Duraci√≥n: ${p.durada} min")
                if (p.actors != null) println("   üë• Actores: ${p.actors.joinToString(", ")}")
                println("   üìù Sinopsis: ${p.sinopsi.take(100)}...")
                println("---------------------------------------------------------")
                i++
            }
    
            cliente.close()
            println("\nüîö Proceso finalizado correctamente.")

        } catch (e: Exception) {
            println("‚ùå Error durante la ejecuci√≥n: ${e.message}")
            e.printStackTrace()
        }
    }

**MainJackson.kt**

Lee el archivo JSON usando la librer√≠a Jackson.

    package peliculas



    import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
    import com.fasterxml.jackson.module.kotlin.readValue
    import org.litote.kmongo.KMongo
    import org.litote.kmongo.eq
    import org.litote.kmongo.getCollection
    import java.io.File
    import org.litote.kmongo.Id
    import org.litote.kmongo.newId

    data class Pelicula2(   //Ponemos otro nombre para que no entre en conclicto con Pelicula Serializable.
        val _id: Id<Pelicula> = newId(),
        val titol: String = "",
        val titol_or: String? = null,
        val director: String = "",
        val genere: String = "",
        val durada: Int = 0,
        val any: Int = 0,
        val actors: List<String>? = null,
        val sinopsi: String = ""
    )

    fun main() {
        val ruta = "src/main/kotlin/peliculas/peliculas.json"
        val archivo = File(ruta)

        if (!archivo.exists()) {
            println("‚ùå No se ha encontrado el archivo $ruta")
            return
        }

        println("üìñ Leyendo archivo $ruta ...")

        try {
            // 1Ô∏è‚É£ Crear el mapper de Jackson
            val mapper = jacksonObjectMapper()

            // 2Ô∏è‚É£ Leer el archivo y convertirlo en lista de Pelicula
            val peliculas: List<Pelicula2> = mapper.readValue(archivo)

            println("‚úÖ Se han le√≠do ${peliculas.size} pel√≠culas del archivo.")

            // 3Ô∏è‚É£ Conectarse a MongoDB con KMongo
            val cliente = KMongo.createClient("mongodb://localhost:27017")
            val baseDatos = cliente.getDatabase("peliculas_db")
            val coleccion = baseDatos.getCollection<Pelicula2>()

            // 4Ô∏è‚É£ Limpiar colecci√≥n (opcional)
            coleccion.drop()

            // 5Ô∏è‚É£ Insertar todas las pel√≠culas de golpe
            coleccion.insertMany(peliculas)
            println("üíæ ${peliculas.size} pel√≠culas insertadas correctamente.\n")

            // 6Ô∏è‚É£ Mostrar todas las pel√≠culas
            val lista = coleccion.find().toList()
            println("üìú Contenido de la colecci√≥n en MongoDB:\n")
            var i = 1
            for (p in lista) {
                println("üéûÔ∏è $i. ${p.titol} (${p.any})")
                println("   üé¨ Director: ${p.director}")
                println("   üß© G√©nero: ${p.genere}")
                println("   ‚è±Ô∏è Duraci√≥n: ${p.durada} min")
                if (p.actors != null) println("   üë• Actores: ${p.actors.joinToString(", ")}")
                println("   üìù Sinopsis: ${p.sinopsi.take(100)}...")
                println("---------------------------------------------------------")
                i++
            }

            // 7Ô∏è‚É£ Consultar solo los dramas, ordenados por t√≠tulo
            println("\nüé≠ --- Pel√≠culas de g√©nero 'Drama' ---\n")
            val dramas = coleccion.find(Pelicula::genere eq "Drama").sortedBy { it.titol }
            for (p in dramas) {
                println("${p.titol} - ${p.director} (${p.any})")
            }

            cliente.close()
            println("\nüîö Proceso finalizado correctamente.")

        } catch (e: Exception) {
            println("‚ùå Error durante la ejecuci√≥n: ${e.message}")
            e.printStackTrace()
        }
    }
