<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://asalvadorc.github.io/AD_BD_NoSQL_/mongo/conexion/" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>üîπDesde Kotlin - AD - Acc√©s a Dades - BD NoSQL</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../../css/extra.css" rel="stylesheet" />
        <link href="../../img/favicon.ico" rel="stylesheet" />
        <link href="../../css/copy-button.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\ud83d\udd39Desde Kotlin";
        var mkdocs_page_input_path = "mongo/conexion.md";
        var mkdocs_page_url = "/AD_BD_NoSQL_/mongo/conexion/";
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../..">
          <img src="../../assets/logocaminas.png" class="logo" alt="Logo"/>
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">BD Documentales nativas</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../RA_CE/">üîπRA y CE</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../Introduccion/">üîπIntroducci√≥n</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">MONGO</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../Mongo/">üîπIntroducci√≥n</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../json/">üîπJSON</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../instalacion/">üîπInstalaci√≥n</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../comandos/">üîπComandos</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">üîπDesde Kotlin</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#kotlin-gradle-driver-oficial">üîπKotlin + Gradle + Driver oficial</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#kotlin-gradle-kmongo">üîπKotlin + Gradle + KMongo</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#control-de-errores">üîπControl de errores</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#construir-una-base-de-datos-mongodb">üîπConstruir una base de datos MongoDB</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Ejercicio/">üìùEjercicio obligatorio 1</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../colecciones/">üîπColecciones</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../Ejercicio2/">üìùEjercicio obligatorio 2</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">AD - Acc√©s a Dades - BD NoSQL</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">MONGO</li>
      <li class="breadcrumb-item active">üîπDesde Kotlin</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="conexion">üîπConexi√≥n</h1>
<p>Para conectar una aplicaci√≥n escrita en <strong>Kotlin</strong> con una base de datos <strong>MongoDB</strong>, existen dos opciones principales, seg√∫n el objetivo y el nivel de control que se necesite sobre las operaciones:</p>
<p>1Ô∏è‚É£ Conexi√≥n con el controlador oficial de MongoDB (<strong>MongoDB Driver</strong>)</p>
<p>Es la opci√≥n m√°s directa y de bajo nivel. Permite trabajar con las clases del paquete com.mongodb o org.bson para realizar operaciones CRUD (crear, leer, actualizar y eliminar) sobre las colecciones.
Se utiliza cuando se quiere tener control total sobre las consultas, la conexi√≥n y la conversi√≥n de documentos BSON a objetos Kotlin.</p>
<p>2Ô∏è‚É£ Conexi√≥n mediante una librer√≠a de mapeo (ORM/ODM), como <strong>KMongo</strong></p>
<p>KMongo es una capa de abstracci√≥n sobre el driver oficial, dise√±ada espec√≠ficamente para Kotlin.
Permite trabajar con data classes y consultas tipadas, simplificando el c√≥digo y haci√©ndolo m√°s idiom√°tico.
Es la opci√≥n m√°s recomendada para proyectos educativos o empresariales donde se busca claridad, seguridad de tipos y menor c√≥digo repetitivo.</p>
<p>A continuaci√≥n veremos un ejemplo pr√°ctico de cada una de las dos formas de conectar Kotlin con MongoDB. Ambos ejemplos se ejecutar√°n sobre <strong>MongoDB Community Server</strong> en local y se crear√°n con <strong>Gradle</strong> desde IntelliJ.</p>
<p>3Ô∏è‚É£ Creamos un nuevo proyecto llamado <strong>BDNoSQL</strong>.</p>
<p><img alt="alt text" src="../../img/mongo1.png" /></p>
<h2 id="kotlin-gradle-driver-oficial">üîπKotlin + Gradle + Driver oficial</h2>
<p><strong class="azul">1. A√±adir las dependencias en Gradle</strong></p>
<p>En el archivo <strong>build.gradle.kts</strong>, dentro del bloque dependencies, a√±adimos:</p>
<pre><code>    dependencies {
        implementation("org.mongodb:mongodb-driver-sync:5.2.0")
    }
</code></pre>
<p><strong class="azul">2. Ejemplo sobre la colecci√≥n Libros</strong></p>
<p>Crea un archivo <strong>main.kt</strong> en un paquete nuevo llamado <strong>mongo</strong> con el siguiente c√≥digo:</p>
<p><img alt="alt text" src="../../img/mongo2.png" /></p>
<pre><code>import com.mongodb.client.MongoClients
import com.mongodb.client.MongoCollection
import com.mongodb.client.MongoDatabase
import org.bson.Document

fun main() {
    // 1Conexi√≥n al servidor local
    val uri = "mongodb://localhost:27017"
    val client = MongoClients.create(uri)

    // Seleccionar base de datos
    val database: MongoDatabase = client.getDatabase("biblioteca")

    // Seleccionar colecci√≥n
    val coleccion: MongoCollection&lt;Document&gt; = database.getCollection("libros")

    // Insertar un documento
    val doc = Document("titulo", "1984")
        .append("autor", "George Orwell")
        .append("a√±o", 1949)

    coleccion.insertOne(doc)
    println("Documento insertado correctamente.")

    // Leer documentos
    for (libro in coleccion.find()) {
        println(libro.toJson())
    }

    client.close()
}
</code></pre>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Al ejecutar el programa os aparecer√° el siguiene mensaje:</p>
<p><img alt="alt text" src="../../img/mongo3_msg.png" /> </p>
<p>Esto no es un error, solo una advertencia. MongoDB intenta usar <strong>SLF4J</strong> (Simple Logging Facade for Java) para mostrar mensajes de registro (logs) sobre la conexi√≥n, operaciones, etc.<br />
Como tu proyecto no incluye ninguna librer√≠a de logging, te avisa de que no podr√° mostrar esos logs internos, pero el programa sigue funcionando perfectamente.</p>
</div>
<h2 id="kotlin-gradle-kmongo">üîπKotlin + Gradle + KMongo</h2>
<p><strong class="azul">1. A√±adir las dependencias en Gradle</strong></p>
<p>En el <strong>archivo build.gradle.kts</strong>, dentro del bloque dependencies, a√±adimos:</p>
<pre><code>    dependencies {
        implementation("org.litote.kmongo:kmongo:5.1.0")
    }
</code></pre>
<p><strong class="azul">2. Ejemplo sobre la colecci√≥n Libros</strong></p>
<p>Crea un archivo <strong>main.kt</strong> en un paquete nuevo llamado <strong>kmongo</strong> con el siguiente c√≥digo:</p>
<p><img alt="alt text" src="../../img/mongo4.png" /></p>
<pre><code>    import org.litote.kmongo.*

    data class Libros(val titulo: String, val autor: String, val a√±o: Int)

    fun main() {
        // Crear conexi√≥n
        val client = KMongo.createClient() // Por defecto: mongodb://localhost:27017
        val database = client.getDatabase("biblioteca")
        val coleccion = database.getCollection&lt;Libros&gt;()

        // Insertar datos
        val libro = Libros("Fahrenheit 451", "Ray Bradbury", 1953)
        coleccion.insertOne(libro)
        println("Libro insertado correctamente")

        // Consultar datos
        val resultados = coleccion.find()
        resultados.forEach { println(it) }

        client.close()
    }
</code></pre>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Aparecer√°n los dos libros insertados, tanto en el ejemplo anterior como en este, ya que la colecci√≥n Libros es la misma.</p>
<p><img alt="alt text" src="../../img/mongo4_msg.png" /></p>
</div>
<h2 id="control-de-errores">üîπControl de errores</h2>
<p>Cuando un programa se conecta a una base de datos como MongoDB, siempre existe la posibilidad de que ocurran errores: la base de datos puede no estar disponible, los datos pueden ser incorrectos o una operaci√≥n puede fallar por un conflicto o por formato inv√°lido.</p>
<p>Por eso, es importante incluir control de errores en el c√≥digo, especialmente en las operaciones de conexi√≥n y en las operaciones CRUD (insertar, leer, actualizar, eliminar).</p>
<p>El control de errores se hace con bloques <strong>try-catch</strong>. As√≠ puedes capturar las excepciones y evitar que el programa se detenga bruscamente.</p>
<p><strong>Buenas pr√°cticas:</strong></p>
<ul>
<li>Verificar que el servidor MongoDB est√° en ejecuci√≥n antes de conectar.</li>
<li>Usar <strong>try-catch</strong> en las secciones cr√≠ticas del programa (especialmente conexi√≥n e inserci√≥n).</li>
<li>Mostrar mensajes claros al usuario para facilitar el diagn√≥stico.</li>
<li>Cerrar el cliente con client.close() en un bloque <strong>finally</strong> si se usa una conexi√≥n persistente.<pre><code>try {
    val client = KMongo.createClient() // Por defecto: mongodb://localhost:27017
    val database = client.getDatabase("biblioteca")
    val coleccion = database.getCollection&lt;Libros&gt;()

    // Insertar datos
    val libro = Libros("Fahrenheit 451", "Ray Bradbury", 1953)
    coleccion.insertOne(libro)
    println("Libro insertado correctamente")

    // Consultar datos
    val resultados = coleccion.find()
    resultados.forEach { println(it) }

    client.close()

} catch (e: Exception) {
    println("‚ö†Ô∏è Error al acceder a MongoDB: ${e.message}")

} finally { //si se usa una conexi√≥n persistente.
    // Cierre seguro del cliente
    client?.close()
    println("üîí Conexi√≥n cerrada.")
}
</code></pre>
</li>
</ul>
<h2 id="construir-una-base-de-datos-mongodb">üîπConstruir una base de datos MongoDB</h2>
<p>Existen principalmente dos maneras de crear y poblar una base de datos en MongoDB:</p>
<p><strong class="azul">1.  Inserci√≥n manual de documentos</strong></p>
<p>Podemos crear los documentos directamente desde la consola de MongoDB o desde un programa,
utilizando instrucciones <strong>insertOne()</strong> o <strong>insertMany()</strong> con los datos escritos a mano.</p>
<p>Por ejemplo: Insertar un pel√≠cula en una colecci√≥n llamada peliculas.</p>
<pre><code>db.peliculas.insertOne({
    "titol": "La noia terrible",
    "director": "Michael Verhoeven",
    "genere": "Drama",
    "any": 1990
})
</code></pre>
<div class="admonition warning">
<p>Este m√©todo es √∫til para hacer pruebas r√°pidas o a√±adir registros sueltos, pero no resulta pr√°ctico cuando tenemos muchos datos.</p>
</div>
<p><strong class="azul">2.  Lectura desde un archivo JSON</strong></p>
<p>Cuando ya disponemos de un conjunto de datos estructurados (por ejemplo, en un <strong>archivo json</strong>),
podemos leer el archivo desde un programa y <strong>convertir cada elemento en un documento MongoDB</strong>.
Esto permite crear colecciones completas de forma autom√°tica, sin escribir los documentos uno a uno.
A partir de este archivo, un programa en Kotlin puede leer los datos y a√±adirlos autom√°ticamente
a una colecci√≥n MongoDB mediante las funciones insertOne() o insertMany().</p>
<p>En este ejemplo veremos c√≥mo crear una base de datos MongoDB, utilizando el controlador <strong>KMongo</strong>, a partir de un archivo JSON llamado
<strong><a href="../peliculas.json">peliculas.json</a></strong>, que ubicaremos en un paquete nuevo llamado <strong>peliculas</strong>, dentro del paquete <strong>kmongo</strong> (<strong>src/main/kotlin/kmongo/peliculas/</strong>).</p>
<p>Vamos a desarrollar dos programas equivalentes, pero utilizando dos librer√≠as diferentes para el tratamiento de los datos JSON:
<strong>kotlinx.serialization</strong> y <strong>Jackson</strong>.</p>
<p>Ambos programas trabajar√°n con el mismo archivo de datos <strong><a href="../peliculas.json">peliculas.json</a></strong>, y realizar√°n exactamente los mismos pasos:</p>
<ul>
<li>Lee el archivo JSON.</li>
<li>Convertir los datos le√≠dos en una lista de objetos de la clase Pelicula.</li>
<li>Insertar los objetos en una colecci√≥n de MongoDB llamada peliculas, utilizando la librer√≠a <strong>KMongo</strong>, que permite trabajar directamente con clases de datos Kotlin (data class).</li>
<li>Recupera y muestra los datos almacenados en la colecci√≥n.  </li>
</ul>
<p>--</p>
<p><strong>üîπEstructura del archivo JSON</strong></p>
<pre><code>    [
    {
        "titol": "La noia terrible",
        "titol_or": "Das schreckliche M√§dchen",
        "director": "Michael Verhoeven",
        "genere": "Drama",
        "durada": 93,
        "any": 1990,
        "actors": ["Lena Stolze", "Hans-Reinhard M√ºller", "Monika Baumgartner"],
        "sinopsi": "Una noia alemanya que viu a Passau inicia una investigaci√≥ sobre el passat..."
    },
    {
        "titol": "Hardcore",
        "titol_or": null,
        "director": "Paul Schrader",
        "genere": "Comedia",
        "durada": 109,
        "any": 1979,
        "actors": ["Peter Boyle", "George C. Scott", "Season Hubley"],
        "sinopsi": "Un home profundament religi√≥s contracta un detectiu per trobar la seua filla..."
    }
    ]
</code></pre>
<p><strong>üîπEstructura del proyecto</strong></p>
<pre><code>    BDNoSQL/
        ‚îú‚îÄ build.gradle.kts
        ‚îú‚îÄ src/
            ‚îî‚îÄ main/
                ‚îî‚îÄ kotlin/
                    ‚îî‚îÄ kmongo/
                        ‚îî‚îÄ peliculas/
                            ‚îú‚îÄ MainSerialization.kt      ‚Üí programa con kotlinx.serialization
                            ‚îî‚îÄ MainJackson.kt            ‚Üí programa con Jackson
                            ‚îî‚îÄ peliculas.json            ‚Üí archivo con las pel√≠culas
</code></pre>
<p><strong>üîπPrograma utilizando kotlinx.serialization</strong>: MainSerialization.kt</p>
<pre><code>    package kmongo.peliculas


    import kotlinx.serialization.Serializable
    import kotlinx.serialization.builtins.ListSerializer
    import kotlinx.serialization.json.Json
    import org.litote.kmongo.*
    import org.litote.kmongo.getCollection
    import java.io.File


    @Serializable
    data class PeliculaSerializada(
        val titol: String = "",
        val titol_or: String? = null,
        val director: String = "",
        val genere: String = "",
        val durada: Int = 0,
        val any: Int = 0,
        val actors: List&lt;String&gt;? = null,
        val sinopsi: String = ""
    )


    fun main() {
        val ruta = "src/main/kotlin/kmongo/peliculas/peliculas.json"
        val archivo = File(ruta)

        if (!archivo.exists()) {
            println("‚ùå No se ha encontrado el archivo $ruta")
            return
        }

        println("üìñ Leyendo archivo $ruta ...")

        try {
            // 1Ô∏è‚É£ Leer y deserializar las pel√≠culas con kotlinx.serialization
            val json = Json { ignoreUnknownKeys = true }
            val peliculas: List&lt;PeliculaSerializada&gt; = json.decodeFromString(
                ListSerializer(PeliculaSerializada.serializer()),
                archivo.readText(Charsets.UTF_8)
            )

            println("‚úÖ Se han le√≠do ${peliculas.size} pel√≠culas del archivo.")

            // Conexi√≥n a MongoDB con KMongo
            val cliente = KMongo.createClient("mongodb://localhost:27017")
            val bd = cliente.getDatabase("peliculas_db")
            val coleccion = bd.getCollection&lt;PeliculaSerializada&gt;()

            // Limpiar colecci√≥n
            coleccion.drop()

            // Insertar todas las pel√≠culas directamente (sin Document)
            coleccion.insertMany(peliculas)
            println("üíæ ${peliculas.size} pel√≠culas insertadas correctamente.\n")

            // Consultar y mostrar todas
            val lista = coleccion.find().toList()
            println("üìú Contenido de la colecci√≥n en MongoDB:\n")

            var i = 1
            for (p in lista) {
                println("üéûÔ∏è $i. ${p.titol} (${p.any})")
                println("   üé¨ Director: ${p.director}")
                println("   üß© G√©nero: ${p.genere}")
                println("   ‚è±Ô∏è Duraci√≥n: ${p.durada} min")
                if (p.actors != null) println("   üë• Actores: ${p.actors.joinToString(", ")}")
                println("   üìù Sinopsis: ${p.sinopsi.take(100)}...")
                println("---------------------------------------------------------")
                i++
            }

            // Ejemplo de consulta: solo dramas ordenados por t√≠tulo

            val dramas = coleccion.find(PeliculaSerializada::genere eq "Drama").sortedBy { it.titol }

            println("\nüé≠ --- Pel√≠culas de g√©nero 'Drama' ---\n")

            for (p in dramas) {
                println("${p.titol} - ${p.director} (${p.any})")
            }

            cliente.close()
            println("\nüîö Proceso finalizado correctamente.")

        } catch (e: Exception) {
            println("‚ùå Error durante la ejecuci√≥n: ${e.message}")
            e.printStackTrace()
        }
    }
</code></pre>
<p><strong>üîπPrograma utilizando Jackson</strong>: MainJackson.kt</p>
<pre><code>    package kmongo.peliculas



    import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
    import com.fasterxml.jackson.module.kotlin.readValue
    import org.litote.kmongo.KMongo
    import org.litote.kmongo.eq
    import org.litote.kmongo.getCollection
    import java.io.File
    import org.litote.kmongo.Id
    import org.litote.kmongo.newId

    data class Pelicula(
        val _id: Id&lt;Pelicula&gt; = newId(),
        val titol: String = "",
        val titol_or: String? = null,
        val director: String = "",
        val genere: String = "",
        val durada: Int = 0,
        val any: Int = 0,
        val actors: List&lt;String&gt;? = null,
        val sinopsi: String = ""
    )

    fun main() {
        val ruta = "src/main/kotlin/kmongo/peliculas/peliculas.json"
        val archivo = File(ruta)

        if (!archivo.exists()) {
            println("‚ùå No se ha encontrado el archivo $ruta")
            return
        }

        println("Leyendo archivo $ruta ...")

        try {
            // Crear el mapper de Jackson
            val mapper = jacksonObjectMapper()

            // Leer el archivo y convertirlo en lista de Pelicula
            val peliculas: List&lt;Pelicula&gt; = mapper.readValue(archivo)

            println("‚úÖ Se han le√≠do ${peliculas.size} pel√≠culas del archivo.")

            // Conectarse a MongoDB con KMongo
            val cliente = KMongo.createClient("mongodb://localhost:27017")
            val baseDatos = cliente.getDatabase("peliculas_db")
            val coleccion = baseDatos.getCollection&lt;Pelicula&gt;()

            // Limpiar colecci√≥n (opcional)
            coleccion.drop()

            // Insertar todas las pel√≠culas de golpe
            coleccion.insertMany(peliculas)
            println(" ${peliculas.size} pel√≠culas insertadas correctamente.\n")

            // Mostrar todas las pel√≠culas
            val lista = coleccion.find().toList()
            println("Contenido de la colecci√≥n en MongoDB:\n")
            var i = 1
            for (p in lista) {
                println("üéûÔ∏è $i. ${p.titol} (${p.any})")
                println("   üé¨ Director: ${p.director}")
                println("   üß© G√©nero: ${p.genere}")
                println("   ‚è±Ô∏è Duraci√≥n: ${p.durada} min")
                if (p.actors != null) println("   üë• Actores: ${p.actors.joinToString(", ")}")
                println("   üìù Sinopsis: ${p.sinopsi.take(100)}...")
                println("---------------------------------------------------------")
                i++
            }

            // Consultar solo los dramas, ordenados por t√≠tulo
            println("\n--- Pel√≠culas de g√©nero 'Drama' ---\n")
            val dramas = coleccion.find(Pelicula::genere eq "Drama").sortedBy { it.titol }
            for (p in dramas) {
                println("${p.titol} - ${p.director} (${p.any})")
            }

            cliente.close()
            println("\n Proceso finalizado correctamente.")

        } catch (e: Exception) {
            println("‚ùå Error durante la ejecuci√≥n: ${e.message}")
            e.printStackTrace()
        }
    }
</code></pre>
<p><strong>üîπSalida esperada:</strong></p>
<p><img alt="alt text" src="../../img/mongoejemplo.png" /></p>
<!--
### Ejemplos con Agregaci√≥n

El siguiente ejemplo realiza una agregaci√≥n con aggregate() para mostrar cu√°ntas pel√≠culas hay por g√©nero, usando una operaci√≥n tipo group + sum + sort.

Lo haremos en kmongo + kotlinx.serialization:


A√±ade esta clase al principio del archivo, fuera de main():

    import kotlinx.serialization.Serializable

    @Serializable
    data class GeneroConConteo(
        val _id: String,              // nombre del g√©nero
        val total: Int                // n√∫mero de pel√≠culas de ese g√©nero
    )

Agrega esta funci√≥n en tu c√≥digo:

        import org.bson.Document

        fun mostrarConteoPeliculasPorGenero() {
            val cliente = KMongo.createClient("mongodb://localhost:27017")
            val bd = cliente.getDatabase("peliculas_db")
            val coleccion = bd.getCollection<PeliculaSerializada>()

            val pipeline = listOf(
                Document("\$group", Document()
                    .append("_id", "\$genere")
                    .append("total", Document("\$sum", 1))),
                Document("\$sort", Document("total", -1))
            )

            val resultado = coleccion.aggregate(pipeline)
                .map { doc -> 
                    GeneroConConteo(
                        _id = doc.getString("_id"),
                        total = doc.getInteger("total")
                    )
                }
                .toList()

            println("\nüìä Pel√≠culas por g√©nero:")
            for (g in resultado) {
                println("üé¨ ${g._id}: ${g.total} pel√≠culas")
            }

            cliente.close()
        }


Llamar a la funci√≥n desde main()

    mostrarConteoPeliculasPorGenero()
-->
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../comandos/" class="btn btn-neutral float-left" title="üîπComandos"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../Ejercicio/" class="btn btn-neutral float-right" title="üìùEjercicio obligatorio 1">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../comandos/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../Ejercicio/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../js/copy-button.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
