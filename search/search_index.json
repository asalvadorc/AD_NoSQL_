{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bases de Datos Documentales Nativas","title":"Acceso a Datos - Bases de Datos Documentales Nativas"},{"location":"#bases-de-datos-documentales-nativas","text":"","title":"Bases de Datos Documentales Nativas"},{"location":"Introduccion/","text":"\ud83d\udd39Introducci\u00f3n Las bases de datos documentales nativas (como MongoDB, Redis o Firebase) almacenan informaci\u00f3n en forma de documentos, usualmente codificados en JSON, BSON o XML, en lugar de filas y columnas como en las bases de datos relacionales. Cada documento puede tener una estructura diferente, lo que permite mayor flexibilidad y agilidad en el desarrollo. Sin embargo, si el dominio de la aplicaci\u00f3n tiene muchas relaciones fuertes entre entidades y se necesita garantizar una integridad referencial estricta, una base de datos relacional puede ser m\u00e1s adecuada. Ventajas Ventaja Descripci\u00f3n Flexibilidad del esquema No es necesario definir un esquema fijo antes de insertar datos. Ideal para estructuras din\u00e1micas. Escalabilidad horizontal Se adaptan bien al escalado distribuyendo los datos en m\u00faltiples servidores (sharding). Rendimiento en lectura y escritura Muy eficiente en operaciones de lectura y escritura sobre documentos completos. Modelo cercano a objetos Almacenan los datos de manera similar a como se manejan en el c\u00f3digo (objetos serializados como JSON). Facilidad de integraci\u00f3n con APIs REST Los documentos JSON pueden ser enviados y recibidos f\u00e1cilmente a trav\u00e9s de APIs. Ideal para datos semiestructurados \u00datiles para trabajar con datos que no se ajustan a una estructura tabular, como respuestas de formularios, logs, etc. Inconvenientes Inconveniente Descripci\u00f3n Falta de integridad referencial No hay claves for\u00e1neas como en las bases de datos relacionales, lo que puede causar inconsistencias si no se gestiona adecuadamente desde la aplicaci\u00f3n. Redundancia de datos Se repite informaci\u00f3n entre documentos al no haber normalizaci\u00f3n; esto puede generar m\u00e1s uso de espacio. Curva de aprendizaje Requiere aprender nuevos conceptos como agregaciones, operadores espec\u00edficos y estructuras de documentos. Menor soporte para transacciones complejas Aunque existen transacciones en algunas bases (como MongoDB), su uso es m\u00e1s limitado que en sistemas relacionales. Consultas menos optimizadas en relaciones complejas No es la mejor opci\u00f3n cuando los datos necesitan muchas relaciones y joins complejos.","title":"\ud83d\udd39Introducci\u00f3n"},{"location":"Introduccion/#introduccion","text":"Las bases de datos documentales nativas (como MongoDB, Redis o Firebase) almacenan informaci\u00f3n en forma de documentos, usualmente codificados en JSON, BSON o XML, en lugar de filas y columnas como en las bases de datos relacionales. Cada documento puede tener una estructura diferente, lo que permite mayor flexibilidad y agilidad en el desarrollo. Sin embargo, si el dominio de la aplicaci\u00f3n tiene muchas relaciones fuertes entre entidades y se necesita garantizar una integridad referencial estricta, una base de datos relacional puede ser m\u00e1s adecuada. Ventajas Ventaja Descripci\u00f3n Flexibilidad del esquema No es necesario definir un esquema fijo antes de insertar datos. Ideal para estructuras din\u00e1micas. Escalabilidad horizontal Se adaptan bien al escalado distribuyendo los datos en m\u00faltiples servidores (sharding). Rendimiento en lectura y escritura Muy eficiente en operaciones de lectura y escritura sobre documentos completos. Modelo cercano a objetos Almacenan los datos de manera similar a como se manejan en el c\u00f3digo (objetos serializados como JSON). Facilidad de integraci\u00f3n con APIs REST Los documentos JSON pueden ser enviados y recibidos f\u00e1cilmente a trav\u00e9s de APIs. Ideal para datos semiestructurados \u00datiles para trabajar con datos que no se ajustan a una estructura tabular, como respuestas de formularios, logs, etc. Inconvenientes Inconveniente Descripci\u00f3n Falta de integridad referencial No hay claves for\u00e1neas como en las bases de datos relacionales, lo que puede causar inconsistencias si no se gestiona adecuadamente desde la aplicaci\u00f3n. Redundancia de datos Se repite informaci\u00f3n entre documentos al no haber normalizaci\u00f3n; esto puede generar m\u00e1s uso de espacio. Curva de aprendizaje Requiere aprender nuevos conceptos como agregaciones, operadores espec\u00edficos y estructuras de documentos. Menor soporte para transacciones complejas Aunque existen transacciones en algunas bases (como MongoDB), su uso es m\u00e1s limitado que en sistemas relacionales. Consultas menos optimizadas en relaciones complejas No es la mejor opci\u00f3n cuando los datos necesitan muchas relaciones y joins complejos.","title":"\ud83d\udd39Introducci\u00f3n"},{"location":"RA_CE/","text":"\ud83d\udd39 RA5. Desarrolla aplicaciones que gestionan la informaci\u00f3n almacenada en bases de datos documentales nativas evaluando y utilizando clases espec\u00edficas Criterio de Evaluaci\u00f3n Contenidos Asociados a) Se han valorado las ventajas e inconvenientes de utilizar bases de datos documentales nativas. - Definici\u00f3n de base de datos documental (orientada a documentos). - Comparativa frente a bases de datos relacionales: rendimiento, escalabilidad, flexibilidad del esquema. - Ventajas: almacenamiento de datos semiestructurados (JSON, BSON), escalabilidad horizontal, alta disponibilidad. - Inconvenientes: falta de integridad referencial, consistencia eventual, menor madurez en algunos entornos. b) Se ha establecido la conexi\u00f3n con la base de datos. - Conectores y drivers para bases de datos como MongoDB (MongoDB Java Driver, KMongo). - Configuraci\u00f3n de la URI de conexi\u00f3n. - Gesti\u00f3n de clientes y sesiones. - Buenas pr\u00e1cticas de conexi\u00f3n y cierre de recursos. c) Se han desarrollado aplicaciones que efect\u00faan consultas sobre el contenido de la base de datos. - Uso de consultas simples y complejas en MongoDB (filtros, proyecciones, operadores l\u00f3gicos, agregaciones). - Librer\u00edas de acceso desde Kotlin (KMongo, MongoDB Java Driver). - Ejecuci\u00f3n de b\u00fasquedas por campo, rango y patr\u00f3n. d) Se han a\u00f1adido y eliminado colecciones de la base de datos. - Creaci\u00f3n din\u00e1mica de colecciones. - Eliminaci\u00f3n de colecciones y sus implicaciones. - Comprobaci\u00f3n de existencia previa. - Operaciones de administraci\u00f3n desde el c\u00f3digo. e) Se han desarrollado aplicaciones para a\u00f1adir, modificar y eliminar documentos de la base de datos. - Inserci\u00f3n de documentos JSON/BSON. - Actualizaci\u00f3n completa y parcial (updateOne, updateMany). - Eliminaci\u00f3n de documentos (deleteOne, deleteMany). - Uso de data classes de Kotlin para representar documentos. - Serializaci\u00f3n y deserializaci\u00f3n de objetos.","title":"\ud83d\udd39RA y CE"},{"location":"RA_CE/#ra5-desarrolla-aplicaciones-que-gestionan-la-informacion-almacenada-en-bases-de-datos-documentales-nativas-evaluando-y-utilizando-clases-especificas","text":"Criterio de Evaluaci\u00f3n Contenidos Asociados a) Se han valorado las ventajas e inconvenientes de utilizar bases de datos documentales nativas. - Definici\u00f3n de base de datos documental (orientada a documentos). - Comparativa frente a bases de datos relacionales: rendimiento, escalabilidad, flexibilidad del esquema. - Ventajas: almacenamiento de datos semiestructurados (JSON, BSON), escalabilidad horizontal, alta disponibilidad. - Inconvenientes: falta de integridad referencial, consistencia eventual, menor madurez en algunos entornos. b) Se ha establecido la conexi\u00f3n con la base de datos. - Conectores y drivers para bases de datos como MongoDB (MongoDB Java Driver, KMongo). - Configuraci\u00f3n de la URI de conexi\u00f3n. - Gesti\u00f3n de clientes y sesiones. - Buenas pr\u00e1cticas de conexi\u00f3n y cierre de recursos. c) Se han desarrollado aplicaciones que efect\u00faan consultas sobre el contenido de la base de datos. - Uso de consultas simples y complejas en MongoDB (filtros, proyecciones, operadores l\u00f3gicos, agregaciones). - Librer\u00edas de acceso desde Kotlin (KMongo, MongoDB Java Driver). - Ejecuci\u00f3n de b\u00fasquedas por campo, rango y patr\u00f3n. d) Se han a\u00f1adido y eliminado colecciones de la base de datos. - Creaci\u00f3n din\u00e1mica de colecciones. - Eliminaci\u00f3n de colecciones y sus implicaciones. - Comprobaci\u00f3n de existencia previa. - Operaciones de administraci\u00f3n desde el c\u00f3digo. e) Se han desarrollado aplicaciones para a\u00f1adir, modificar y eliminar documentos de la base de datos. - Inserci\u00f3n de documentos JSON/BSON. - Actualizaci\u00f3n completa y parcial (updateOne, updateMany). - Eliminaci\u00f3n de documentos (deleteOne, deleteMany). - Uso de data classes de Kotlin para representar documentos. - Serializaci\u00f3n y deserializaci\u00f3n de objetos.","title":"\ud83d\udd39 RA5. Desarrolla aplicaciones que gestionan la informaci\u00f3n almacenada en bases de datos documentales nativas evaluando y utilizando clases espec\u00edficas"},{"location":"firebase/Firebase/","text":"","title":"\ud83d\udd39Conexi\u00f3n"},{"location":"mongo/Ejercicio/","text":"\ud83d\udcdd Ejercicio: Mi base de datos MongoDB en Kotlin \ud83d\udee0\ufe0f Requisitos 1. Base de Datos En este ejercicio vas a crear tu propia base de datos MongoDB, cuyo nombre debe seguir el formato: bd_tunombreprimerapellido . Por ejemplo, si te llamas Maria P\u00e9rez, tu base de datos se llamar\u00e1 bd_mariaperez . 2. Opeaciones en Kotlin Trabajar\u00e1s con Kotlin y KMongo para realizar operaciones CRUD (crear, leer, actualizar y eliminar) y una consulta avanzada utilizando el m\u00e9todo aggregate() . Crea tambi\u00e9n una colecci\u00f3n principal. Puedes elegir el tema que m\u00e1s te guste, por ejemplo: productos, libros, peliculas, alumnos, clientes... Implementa en tu programa las siguientes operaciones: Insertar varios documentos en la colecci\u00f3n. Mostrar todos los documentos almacenados. Actualizar alg\u00fan campo de un documento (por ejemplo, el precio o el stock). Encontrar documentos seg\u00fan criterios de b\u00fasqueda. Eliminar uno o varios documentos seg\u00fan un criterio. 3. B\u00fasqueda avanzada con aggregate() Crea una consulta con agregaci\u00f3n que muestre informaci\u00f3n resumida de tus datos. Algunas ideas: Agrupar productos por categor\u00eda y calcular el precio medio. Contar cu\u00e1ntos productos hay por tipo. Mostrar los productos con precio superior a la media. \ud83d\udce9 Entrega Sube un archivo .zip con: El proyecto completo. Un archivo README.md donde expliques: El nombre de tu base de datos. Qu\u00e9 colecci\u00f3n has elegido. Qu\u00e9 operaciones CRUD has implementado. Qu\u00e9 hace tu consulta con aggregate() y qu\u00e9 resultado devuelve. \u2705 R\u00fabrica de evaluaci\u00f3n Criterio Puntuaci\u00f3n Base de datos 2 Operaciones CRUD 3 Agregaci\u00f3n 2 C\u00f3digo y documentaci\u00f3n 2 Control de errores 1 Puntuaci\u00f3n total 10","title":"\ud83d\udcddEjercicio obligatorio"},{"location":"mongo/Ejercicio/#ejercicio-mi-base-de-datos-mongodb-en-kotlin","text":"","title":"\ud83d\udcdd Ejercicio: Mi base de datos MongoDB en Kotlin"},{"location":"mongo/Ejercicio/#requisitos","text":"","title":"\ud83d\udee0\ufe0f Requisitos"},{"location":"mongo/Ejercicio/#1-base-de-datos","text":"En este ejercicio vas a crear tu propia base de datos MongoDB, cuyo nombre debe seguir el formato: bd_tunombreprimerapellido . Por ejemplo, si te llamas Maria P\u00e9rez, tu base de datos se llamar\u00e1 bd_mariaperez .","title":"1. Base de Datos"},{"location":"mongo/Ejercicio/#2-opeaciones-en-kotlin","text":"Trabajar\u00e1s con Kotlin y KMongo para realizar operaciones CRUD (crear, leer, actualizar y eliminar) y una consulta avanzada utilizando el m\u00e9todo aggregate() . Crea tambi\u00e9n una colecci\u00f3n principal. Puedes elegir el tema que m\u00e1s te guste, por ejemplo: productos, libros, peliculas, alumnos, clientes... Implementa en tu programa las siguientes operaciones: Insertar varios documentos en la colecci\u00f3n. Mostrar todos los documentos almacenados. Actualizar alg\u00fan campo de un documento (por ejemplo, el precio o el stock). Encontrar documentos seg\u00fan criterios de b\u00fasqueda. Eliminar uno o varios documentos seg\u00fan un criterio.","title":"2. Opeaciones en Kotlin"},{"location":"mongo/Ejercicio/#3-busqueda-avanzada-con-aggregate","text":"Crea una consulta con agregaci\u00f3n que muestre informaci\u00f3n resumida de tus datos. Algunas ideas: Agrupar productos por categor\u00eda y calcular el precio medio. Contar cu\u00e1ntos productos hay por tipo. Mostrar los productos con precio superior a la media.","title":"3. B\u00fasqueda avanzada con aggregate()"},{"location":"mongo/Ejercicio/#entrega","text":"Sube un archivo .zip con: El proyecto completo. Un archivo README.md donde expliques: El nombre de tu base de datos. Qu\u00e9 colecci\u00f3n has elegido. Qu\u00e9 operaciones CRUD has implementado. Qu\u00e9 hace tu consulta con aggregate() y qu\u00e9 resultado devuelve.","title":"\ud83d\udce9 Entrega"},{"location":"mongo/Ejercicio/#rubrica-de-evaluacion","text":"Criterio Puntuaci\u00f3n Base de datos 2 Operaciones CRUD 3 Agregaci\u00f3n 2 C\u00f3digo y documentaci\u00f3n 2 Control de errores 1 Puntuaci\u00f3n total 10","title":"\u2705 R\u00fabrica de evaluaci\u00f3n"},{"location":"mongo/Mongo/","text":"MongoDB \ud83d\udcda MongoDB es un sistema de gesti\u00f3n de bases de datos NoSQL orientado a documentos . A diferencia de las bases de datos relacionales, que almacenan la informaci\u00f3n en tablas con filas y columnas, MongoDB guarda los datos en colecciones formadas por documentos en formato BSON (una representaci\u00f3n binaria de JSON). Cada documento es una estructura flexible , parecida a un objeto de programaci\u00f3n, donde los datos se organizan en pares clave\u2013valor . Esta flexibilidad permite que cada documento tenga una estructura diferente, lo que hace que MongoDB se adapte f\u00e1cilmente a los cambios en los datos sin necesidad de modificar esquemas. \ud83d\udcc2 Estructura b\u00e1sica Concepto Equivalente en BD relacional Descripci\u00f3n Base de datos Base de datos Conjunto de colecciones. Colecci\u00f3n Tabla Agrupaci\u00f3n de documentos relacionados. Documento Fila (registro) Unidad b\u00e1sica de almacenamiento. Es un objeto JSON. Campo Columna Atributo dentro del documento. Ejemplo de estructura flexible Veamos algunos ejemplos de documentos JSON para guardar la informaci\u00f3n de libros y autores . Dependiendo de c\u00f3mo se deba acceder a la informaci\u00f3n, podemos plantearnos guardar los libros con sus autores, o guardar los autores con sus libros. Incluso podr\u00edamos guardar ambas versiones, para poder acceder a los datos de todas las formas posibles, aunque eso implique duplicar la informaci\u00f3n. De la primera manera, guardando los libros junto con su autor, podr\u00edamos tener documentos con esta estructura, que se podr\u00edan guardar en una colecci\u00f3n llamada Libros : { _id:101, titol:\"El secret de Khadrell\", autor: { nom:\"Pep\", cognoms:\"Castellano Puchol\", any_naixement:1960 }, isbn:\"84-95620-72-3\" }, { _id:102, titol:\"L'Ombra del Vent\", autor: { nom:\"Carlos\", cognoms:\"Ruiz Zafon\", pais:\"Espanya\" }, pagines:490, editorial:\"Planeta\" } Observa c\u00f3mo los objetos no tienen por qu\u00e9 tener la misma estructura. La forma de acceder al nombre de un autor ser\u00eda la siguiente: objeto.autor.nombre Una manera alternativa de guardar la informaci\u00f3n, como hab\u00edamos comentado antes, ser\u00eda organizarla por autores, junto con sus libros. De este modo, podr\u00edamos ir completando la colecci\u00f3n Autores con uno o m\u00e1s documentos de este estilo: { _id: 201, nom:\"Pep\", cognoms:\"Castellano Puchol\", any_naixement:1960, llibres: [ { titol:\"El secret de Khadrell\", isbn:\"84-95620-72-3\" }, { titol:\"Habitaci\u00f3 502\", editorial:\"Tabarca\" } ] }, { _id:202, nom:\"Carlos\", cognoms:\"Ruiz Zafon\", pais:\"Espanya\", llibres: [ { titol:\"L'Ombra del Vent\", pagines:490, editorial:\"Planeta\" } ] } Observa c\u00f3mo, para un autor, ahora tenemos un array (los corchetes: [ ]) con sus libros. \u00bfCu\u00e1l de las dos formas es mejor para guardar la informaci\u00f3n? Pues depende del tipo de acceso que se vaya a realizar a los datos. La mejor opci\u00f3n ser\u00e1 probablemente aquella que, seg\u00fan las consultas que se necesiten hacer, devuelva la informaci\u00f3n de forma m\u00e1s r\u00e1pida.","title":"\ud83d\udd39Introducci\u00f3n"},{"location":"mongo/Mongo/#mongodb","text":"\ud83d\udcda MongoDB es un sistema de gesti\u00f3n de bases de datos NoSQL orientado a documentos . A diferencia de las bases de datos relacionales, que almacenan la informaci\u00f3n en tablas con filas y columnas, MongoDB guarda los datos en colecciones formadas por documentos en formato BSON (una representaci\u00f3n binaria de JSON). Cada documento es una estructura flexible , parecida a un objeto de programaci\u00f3n, donde los datos se organizan en pares clave\u2013valor . Esta flexibilidad permite que cada documento tenga una estructura diferente, lo que hace que MongoDB se adapte f\u00e1cilmente a los cambios en los datos sin necesidad de modificar esquemas. \ud83d\udcc2 Estructura b\u00e1sica Concepto Equivalente en BD relacional Descripci\u00f3n Base de datos Base de datos Conjunto de colecciones. Colecci\u00f3n Tabla Agrupaci\u00f3n de documentos relacionados. Documento Fila (registro) Unidad b\u00e1sica de almacenamiento. Es un objeto JSON. Campo Columna Atributo dentro del documento. Ejemplo de estructura flexible Veamos algunos ejemplos de documentos JSON para guardar la informaci\u00f3n de libros y autores . Dependiendo de c\u00f3mo se deba acceder a la informaci\u00f3n, podemos plantearnos guardar los libros con sus autores, o guardar los autores con sus libros. Incluso podr\u00edamos guardar ambas versiones, para poder acceder a los datos de todas las formas posibles, aunque eso implique duplicar la informaci\u00f3n. De la primera manera, guardando los libros junto con su autor, podr\u00edamos tener documentos con esta estructura, que se podr\u00edan guardar en una colecci\u00f3n llamada Libros : { _id:101, titol:\"El secret de Khadrell\", autor: { nom:\"Pep\", cognoms:\"Castellano Puchol\", any_naixement:1960 }, isbn:\"84-95620-72-3\" }, { _id:102, titol:\"L'Ombra del Vent\", autor: { nom:\"Carlos\", cognoms:\"Ruiz Zafon\", pais:\"Espanya\" }, pagines:490, editorial:\"Planeta\" } Observa c\u00f3mo los objetos no tienen por qu\u00e9 tener la misma estructura. La forma de acceder al nombre de un autor ser\u00eda la siguiente: objeto.autor.nombre Una manera alternativa de guardar la informaci\u00f3n, como hab\u00edamos comentado antes, ser\u00eda organizarla por autores, junto con sus libros. De este modo, podr\u00edamos ir completando la colecci\u00f3n Autores con uno o m\u00e1s documentos de este estilo: { _id: 201, nom:\"Pep\", cognoms:\"Castellano Puchol\", any_naixement:1960, llibres: [ { titol:\"El secret de Khadrell\", isbn:\"84-95620-72-3\" }, { titol:\"Habitaci\u00f3 502\", editorial:\"Tabarca\" } ] }, { _id:202, nom:\"Carlos\", cognoms:\"Ruiz Zafon\", pais:\"Espanya\", llibres: [ { titol:\"L'Ombra del Vent\", pagines:490, editorial:\"Planeta\" } ] } Observa c\u00f3mo, para un autor, ahora tenemos un array (los corchetes: [ ]) con sus libros. \u00bfCu\u00e1l de las dos formas es mejor para guardar la informaci\u00f3n? Pues depende del tipo de acceso que se vaya a realizar a los datos. La mejor opci\u00f3n ser\u00e1 probablemente aquella que, seg\u00fan las consultas que se necesiten hacer, devuelva la informaci\u00f3n de forma m\u00e1s r\u00e1pida.","title":"MongoDB"},{"location":"mongo/comandos/","text":"\ud83d\udd39 Comandos de MongoDB y su utilizaci\u00f3n Los comandos b\u00e1sicos de MongoDB ya se trabajaron en 1.\u00ba de DAM, cuando se introdujo el modelo NoSQL y las operaciones fundamentales sobre colecciones y documentos. En este tema no se pretende volver a explicarlos desde cero, sino ofrecer un resumen pr\u00e1ctico y actualizado con los comandos m\u00e1s \u00fatiles para consultar, ordenar, filtrar y gestionar datos en MongoDB, que te servir\u00e1 como recordatorio y punto de partida para los ejercicios de este m\u00f3dulo. MongoDB utiliza su propia shell interactiva , llamada mongosh , que permite ejecutar comandos para administrar bases de datos, colecciones y documentos. Su sintaxis es muy similar a JavaScript , ya que cada comando se ejecuta sobre un objeto base : db.coleccion.operacion() db \u2192 representa la base de datos actual. coleccion \u2192 el nombre de la colecci\u00f3n sobre la que actuamos. operacion() \u2192 el comando que deseamos ejecutar. \ud83d\udd39 Sobre bases de datos Comando Descripci\u00f3n Ejemplo show dbs Muestra todas las bases de datos existentes. show dbs use <nombre> Cambia a una base de datos (la crea si no existe). use biblioteca db.getName() Muestra el nombre de la base de datos actual. db.getName() db.dropDatabase() Elimina la base de datos actual. db.dropDatabase() \ud83d\udd39 Sobre colecciones Comando Descripci\u00f3n show collections Lista todas las colecciones de la base de datos. Ejemplo: show collections db.createCollection(\"nombre\") Crea una colecci\u00f3n vac\u00eda. Ejemplo: db.createCollection(\"alumnos\") db.coleccion.drop() Elimina una colecci\u00f3n completa. Ejemplo: db.alumnos.drop() db.coleccion.renameCollection(\"nuevoNombre\") Cambia el nombre de una colecci\u00f3n. Ejemplo: db.alumnos.renameCollection(\"estudiantes\") \ud83d\udd39 Operaciones b\u00e1sicas \ud83d\udd39Inserci\u00f3n Comando Descripci\u00f3n insertOne() Inserta un solo documento. Ejemplo: db.alumnos.insertOne({nombre:\"Ana\", nota:8}) insertMany() Inserta varios documentos a la vez. Ejemplo: db.alumnos.insertMany([{nombre:\"Luis\", nota:7}, {nombre:\"Marta\", nota:9}]) \ud83d\udccc Si la colecci\u00f3n no existe, MongoDB la crear\u00e1 autom\u00e1ticamente en el momento de la inserci\u00f3n. \ud83d\udd39B\u00fasqueda Comando Descripci\u00f3n find() Devuelve todos los documentos de la colecci\u00f3n. Ejemplo: db.alumnos.find() findOne() Devuelve el primer documento que cumple una condici\u00f3n. Ejemplo: db.alumnos.findOne({nombre:\"Ana\"}) find(criterio, proyecci\u00f3n) Permite filtrar y mostrar solo algunos campos. Ejemplo: db.alumnos.find({nota:{$gte:8}}, {nombre:1, _id:0}) \ud83d\udcd8 Operadores comunes : $eq (igual), $ne (distinto), $gt (mayor que), $lt (menor que), $gte (mayor o igual), $lte (menor o igual), $in , $and , $or . \ud83d\udd39 Actualizaci\u00f3n Comando Descripci\u00f3n updateOne(filtro, cambios) Actualiza el primer documento que cumpla la condici\u00f3n. Ejemplo: db.alumnos.updateOne({nombre:\"Ana\"}, {$set:{nota:9}}) updateMany(filtro, cambios) Actualiza todos los documentos que cumplan la condici\u00f3n. Ejemplo: db.alumnos.updateMany({nota:{$lt:5}}, {$set:{aprobado:false}}) replaceOne(filtro, nuevoDoc) Sustituye el documento completo. Ejemplo: db.alumnos.replaceOne({nombre:\"Ana\"}, {nombre:\"Ana\", nota:10}) \u26a0\ufe0f Usa $set para modificar solo algunos campos y no perder el resto . \ud83d\udd39 Eliminaci\u00f3n Comando Descripci\u00f3n deleteOne() Elimina el primer documento que cumpla la condici\u00f3n. Ejemplo: db.alumnos.deleteOne({nombre:\"Luis\"}) deleteMany() Elimina todos los documentos que cumplan la condici\u00f3n. Ejemplo: db.alumnos.deleteMany({nota:{$lt:5}}) \ud83d\udd39 Consultas avanzadas y ordenaci\u00f3n Comando Descripci\u00f3n sort() Ordena los resultados. 1 ascendente, -1 descendente. Ejemplo: db.alumnos.find().sort({nota:-1}) limit() Limita el n\u00famero de resultados. Ejemplo: db.alumnos.find().limit(3) countDocuments() Devuelve el n\u00famero de documentos que cumplen un filtro. Ejemplo: db.alumnos.countDocuments({nota:{$gte:5}}) \ud83d\udd39 \u00cdndices Comando Descripci\u00f3n createIndex({campo:1}) Crea un \u00edndice ascendente. Ejemplo: db.alumnos.createIndex({nombre:1}) getIndexes() Muestra los \u00edndices existentes. Ejemplo: db.alumnos.getIndexes() dropIndex(\"nombre_1\") Elimina un \u00edndice. Ejemplo: db.alumnos.dropIndex(\"nombre_1\") \ud83d\udd39 Informaci\u00f3n \u00fatil del entorno Comando Descripci\u00f3n db.stats() Muestra estad\u00edsticas sobre la base de datos. Ejemplo: db.stats() db.coleccion.stats() Muestra estad\u00edsticas sobre una colecci\u00f3n. Ejemplo: db.alumnos.stats() db.version() Devuelve la versi\u00f3n de MongoDB. Ejemplo: db.version() \ud83d\udd39 Ejemplo completo use biblioteca db.libros.insertMany([ {titulo:\"1984\", autor:\"Orwell\", a\u00f1o:1949}, {titulo:\"Fahrenheit 451\", autor:\"Bradbury\", a\u00f1o:1953} ]) db.libros.find() db.libros.updateOne({titulo:\"1984\"}, {$set:{a\u00f1o:1950}}) db.libros.find({a\u00f1o:{$gte:1950}}) db.libros.deleteOne({titulo:\"Fahrenheit 451\"}) \ud83d\udd39 Consultas avanzadas con aggregate() El m\u00e9todo aggregate() permite realizar consultas complejas y procesamientos de datos en varias etapas, similares a las funciones de GROUP BY, JOIN o HAVING en SQL. Cada etapa del pipeline (tuber\u00eda) transforma los datos paso a paso. Estructura b\u00e1sica db.coleccion.aggregate([ { <etapa1> }, { <etapa2> }, ... ]) Cada etapa (stage) se representa mediante un objeto precedido por $, que indica la operaci\u00f3n a realizar. Etapa Descripci\u00f3n $match Filtra documentos (equivalente a WHERE ). Ejemplo: { $match: { ciudad: \"Valencia\" } } $project Selecciona campos espec\u00edficos o crea nuevos. Ejemplo: { $project: { _id:0, nombre:1, nota:1 } } $sort Ordena los resultados. Ejemplo: { $sort: { nota: -1 } } $limit Limita el n\u00famero de resultados. Ejemplo: { $limit: 5 } $skip Omite un n\u00famero de documentos. Ejemplo: { $skip: 10 } $group Agrupa los documentos por un campo y calcula valores agregados (como COUNT , SUM , AVG ). Ejemplo: { $group: { _id: \"$curso\", media: { $avg: \"$nota\" } } } $count Devuelve el n\u00famero total de documentos resultantes. Ejemplo: { $count: \"total\" } $lookup Realiza una uni\u00f3n entre colecciones (similar a JOIN ). Ejemplo: { $lookup: { from: \"profesores\", localField: \"idProfesor\", foreignField: \"_id\", as: \"infoProfesor\" } } $unwind Descompone arrays en m\u00faltiples documentos. Ejemplo: { $unwind: \"$aficiones\" } \u2705 Resumen Categor\u00eda Comandos clave \ud83d\udcda Base de datos show dbs , use , db.getName() , db.dropDatabase() \ud83d\udcc2 Colecciones show collections , db.createCollection() , db.coleccion.drop() \u2795 Inserci\u00f3n db.coleccion.insertOne() , db.coleccion.insertMany() \ud83d\udd0d Consulta db.coleccion.find() , db.coleccion.findOne() , .sort() , .limit() \u270f\ufe0f Actualizaci\u00f3n db.coleccion.updateOne() , db.coleccion.updateMany() , $set \u274c Eliminaci\u00f3n db.coleccion.deleteOne() , db.coleccion.deleteMany() \ud83e\udde9 \u00cdndices db.coleccion.createIndex() , db.coleccion.getIndexes() , db.coleccion.dropIndex() \ud83d\udcc8 Estad\u00edsticas db.stats() , db.coleccion.stats() , db.version()","title":"\ud83d\udd39Comandos"},{"location":"mongo/comandos/#comandos-de-mongodb-y-su-utilizacion","text":"Los comandos b\u00e1sicos de MongoDB ya se trabajaron en 1.\u00ba de DAM, cuando se introdujo el modelo NoSQL y las operaciones fundamentales sobre colecciones y documentos. En este tema no se pretende volver a explicarlos desde cero, sino ofrecer un resumen pr\u00e1ctico y actualizado con los comandos m\u00e1s \u00fatiles para consultar, ordenar, filtrar y gestionar datos en MongoDB, que te servir\u00e1 como recordatorio y punto de partida para los ejercicios de este m\u00f3dulo. MongoDB utiliza su propia shell interactiva , llamada mongosh , que permite ejecutar comandos para administrar bases de datos, colecciones y documentos. Su sintaxis es muy similar a JavaScript , ya que cada comando se ejecuta sobre un objeto base : db.coleccion.operacion() db \u2192 representa la base de datos actual. coleccion \u2192 el nombre de la colecci\u00f3n sobre la que actuamos. operacion() \u2192 el comando que deseamos ejecutar.","title":"\ud83d\udd39 Comandos de MongoDB y su utilizaci\u00f3n"},{"location":"mongo/comandos/#sobre-bases-de-datos","text":"Comando Descripci\u00f3n Ejemplo show dbs Muestra todas las bases de datos existentes. show dbs use <nombre> Cambia a una base de datos (la crea si no existe). use biblioteca db.getName() Muestra el nombre de la base de datos actual. db.getName() db.dropDatabase() Elimina la base de datos actual. db.dropDatabase()","title":"\ud83d\udd39 Sobre bases de datos"},{"location":"mongo/comandos/#sobre-colecciones","text":"Comando Descripci\u00f3n show collections Lista todas las colecciones de la base de datos. Ejemplo: show collections db.createCollection(\"nombre\") Crea una colecci\u00f3n vac\u00eda. Ejemplo: db.createCollection(\"alumnos\") db.coleccion.drop() Elimina una colecci\u00f3n completa. Ejemplo: db.alumnos.drop() db.coleccion.renameCollection(\"nuevoNombre\") Cambia el nombre de una colecci\u00f3n. Ejemplo: db.alumnos.renameCollection(\"estudiantes\")","title":"\ud83d\udd39 Sobre colecciones"},{"location":"mongo/comandos/#operaciones-basicas","text":"","title":"\ud83d\udd39 Operaciones b\u00e1sicas"},{"location":"mongo/comandos/#insercion","text":"Comando Descripci\u00f3n insertOne() Inserta un solo documento. Ejemplo: db.alumnos.insertOne({nombre:\"Ana\", nota:8}) insertMany() Inserta varios documentos a la vez. Ejemplo: db.alumnos.insertMany([{nombre:\"Luis\", nota:7}, {nombre:\"Marta\", nota:9}]) \ud83d\udccc Si la colecci\u00f3n no existe, MongoDB la crear\u00e1 autom\u00e1ticamente en el momento de la inserci\u00f3n.","title":"\ud83d\udd39Inserci\u00f3n"},{"location":"mongo/comandos/#busqueda","text":"Comando Descripci\u00f3n find() Devuelve todos los documentos de la colecci\u00f3n. Ejemplo: db.alumnos.find() findOne() Devuelve el primer documento que cumple una condici\u00f3n. Ejemplo: db.alumnos.findOne({nombre:\"Ana\"}) find(criterio, proyecci\u00f3n) Permite filtrar y mostrar solo algunos campos. Ejemplo: db.alumnos.find({nota:{$gte:8}}, {nombre:1, _id:0}) \ud83d\udcd8 Operadores comunes : $eq (igual), $ne (distinto), $gt (mayor que), $lt (menor que), $gte (mayor o igual), $lte (menor o igual), $in , $and , $or .","title":"\ud83d\udd39B\u00fasqueda"},{"location":"mongo/comandos/#actualizacion","text":"Comando Descripci\u00f3n updateOne(filtro, cambios) Actualiza el primer documento que cumpla la condici\u00f3n. Ejemplo: db.alumnos.updateOne({nombre:\"Ana\"}, {$set:{nota:9}}) updateMany(filtro, cambios) Actualiza todos los documentos que cumplan la condici\u00f3n. Ejemplo: db.alumnos.updateMany({nota:{$lt:5}}, {$set:{aprobado:false}}) replaceOne(filtro, nuevoDoc) Sustituye el documento completo. Ejemplo: db.alumnos.replaceOne({nombre:\"Ana\"}, {nombre:\"Ana\", nota:10}) \u26a0\ufe0f Usa $set para modificar solo algunos campos y no perder el resto .","title":"\ud83d\udd39 Actualizaci\u00f3n"},{"location":"mongo/comandos/#eliminacion","text":"Comando Descripci\u00f3n deleteOne() Elimina el primer documento que cumpla la condici\u00f3n. Ejemplo: db.alumnos.deleteOne({nombre:\"Luis\"}) deleteMany() Elimina todos los documentos que cumplan la condici\u00f3n. Ejemplo: db.alumnos.deleteMany({nota:{$lt:5}})","title":"\ud83d\udd39 Eliminaci\u00f3n"},{"location":"mongo/comandos/#consultas-avanzadas-y-ordenacion","text":"Comando Descripci\u00f3n sort() Ordena los resultados. 1 ascendente, -1 descendente. Ejemplo: db.alumnos.find().sort({nota:-1}) limit() Limita el n\u00famero de resultados. Ejemplo: db.alumnos.find().limit(3) countDocuments() Devuelve el n\u00famero de documentos que cumplen un filtro. Ejemplo: db.alumnos.countDocuments({nota:{$gte:5}})","title":"\ud83d\udd39 Consultas avanzadas y ordenaci\u00f3n"},{"location":"mongo/comandos/#indices","text":"Comando Descripci\u00f3n createIndex({campo:1}) Crea un \u00edndice ascendente. Ejemplo: db.alumnos.createIndex({nombre:1}) getIndexes() Muestra los \u00edndices existentes. Ejemplo: db.alumnos.getIndexes() dropIndex(\"nombre_1\") Elimina un \u00edndice. Ejemplo: db.alumnos.dropIndex(\"nombre_1\")","title":"\ud83d\udd39 \u00cdndices"},{"location":"mongo/comandos/#informacion-util-del-entorno","text":"Comando Descripci\u00f3n db.stats() Muestra estad\u00edsticas sobre la base de datos. Ejemplo: db.stats() db.coleccion.stats() Muestra estad\u00edsticas sobre una colecci\u00f3n. Ejemplo: db.alumnos.stats() db.version() Devuelve la versi\u00f3n de MongoDB. Ejemplo: db.version()","title":"\ud83d\udd39 Informaci\u00f3n \u00fatil del entorno"},{"location":"mongo/comandos/#ejemplo-completo","text":"use biblioteca db.libros.insertMany([ {titulo:\"1984\", autor:\"Orwell\", a\u00f1o:1949}, {titulo:\"Fahrenheit 451\", autor:\"Bradbury\", a\u00f1o:1953} ]) db.libros.find() db.libros.updateOne({titulo:\"1984\"}, {$set:{a\u00f1o:1950}}) db.libros.find({a\u00f1o:{$gte:1950}}) db.libros.deleteOne({titulo:\"Fahrenheit 451\"})","title":"\ud83d\udd39 Ejemplo completo"},{"location":"mongo/comandos/#consultas-avanzadas-con-aggregate","text":"El m\u00e9todo aggregate() permite realizar consultas complejas y procesamientos de datos en varias etapas, similares a las funciones de GROUP BY, JOIN o HAVING en SQL. Cada etapa del pipeline (tuber\u00eda) transforma los datos paso a paso. Estructura b\u00e1sica db.coleccion.aggregate([ { <etapa1> }, { <etapa2> }, ... ]) Cada etapa (stage) se representa mediante un objeto precedido por $, que indica la operaci\u00f3n a realizar. Etapa Descripci\u00f3n $match Filtra documentos (equivalente a WHERE ). Ejemplo: { $match: { ciudad: \"Valencia\" } } $project Selecciona campos espec\u00edficos o crea nuevos. Ejemplo: { $project: { _id:0, nombre:1, nota:1 } } $sort Ordena los resultados. Ejemplo: { $sort: { nota: -1 } } $limit Limita el n\u00famero de resultados. Ejemplo: { $limit: 5 } $skip Omite un n\u00famero de documentos. Ejemplo: { $skip: 10 } $group Agrupa los documentos por un campo y calcula valores agregados (como COUNT , SUM , AVG ). Ejemplo: { $group: { _id: \"$curso\", media: { $avg: \"$nota\" } } } $count Devuelve el n\u00famero total de documentos resultantes. Ejemplo: { $count: \"total\" } $lookup Realiza una uni\u00f3n entre colecciones (similar a JOIN ). Ejemplo: { $lookup: { from: \"profesores\", localField: \"idProfesor\", foreignField: \"_id\", as: \"infoProfesor\" } } $unwind Descompone arrays en m\u00faltiples documentos. Ejemplo: { $unwind: \"$aficiones\" }","title":"\ud83d\udd39 Consultas avanzadas con aggregate()"},{"location":"mongo/comandos/#resumen","text":"Categor\u00eda Comandos clave \ud83d\udcda Base de datos show dbs , use , db.getName() , db.dropDatabase() \ud83d\udcc2 Colecciones show collections , db.createCollection() , db.coleccion.drop() \u2795 Inserci\u00f3n db.coleccion.insertOne() , db.coleccion.insertMany() \ud83d\udd0d Consulta db.coleccion.find() , db.coleccion.findOne() , .sort() , .limit() \u270f\ufe0f Actualizaci\u00f3n db.coleccion.updateOne() , db.coleccion.updateMany() , $set \u274c Eliminaci\u00f3n db.coleccion.deleteOne() , db.coleccion.deleteMany() \ud83e\udde9 \u00cdndices db.coleccion.createIndex() , db.coleccion.getIndexes() , db.coleccion.dropIndex() \ud83d\udcc8 Estad\u00edsticas db.stats() , db.coleccion.stats() , db.version()","title":"\u2705 Resumen"},{"location":"mongo/conexion/","text":"\ud83d\udd39Conexi\u00f3n Para conectar una aplicaci\u00f3n escrita en Kotlin con una base de datos MongoDB , existen dos opciones principales, seg\u00fan el objetivo y el nivel de control que se necesite sobre las operaciones: 1\ufe0f\u20e3 Conexi\u00f3n con el controlador oficial de MongoDB ( MongoDB Driver ) Es la opci\u00f3n m\u00e1s directa y de bajo nivel. Permite trabajar con las clases del paquete com.mongodb o org.bson para realizar operaciones CRUD (crear, leer, actualizar y eliminar) sobre las colecciones. Se utiliza cuando se quiere tener control total sobre las consultas, la conexi\u00f3n y la conversi\u00f3n de documentos BSON a objetos Kotlin. 2\ufe0f\u20e3 Conexi\u00f3n mediante una librer\u00eda de mapeo (ORM/ODM), como KMongo KMongo es una capa de abstracci\u00f3n sobre el driver oficial, dise\u00f1ada espec\u00edficamente para Kotlin. Permite trabajar con data classes y consultas tipadas, simplificando el c\u00f3digo y haci\u00e9ndolo m\u00e1s idiom\u00e1tico. Es la opci\u00f3n m\u00e1s recomendada para proyectos educativos o empresariales donde se busca claridad, seguridad de tipos y menor c\u00f3digo repetitivo. A continuaci\u00f3n veremos un ejemplo pr\u00e1ctico de cada una de las dos formas de conectar Kotlin con MongoDB. Ambos ejemplos se ejecutar\u00e1n sobre MongoDB Community Server en local y se crear\u00e1n con Gradle desde IntelliJ. \ud83d\udd39Kotlin + Gradle + Driver oficial 1. Crea un nuevo proyecto Al nuevo proyecto lo llamaremos, por ejemplo, BDNoSQL. 2. A\u00f1adir las dependencias en Gradle En el archivo build.gradle.kts , dentro del bloque dependencies, a\u00f1adimos: dependencies { implementation(\"org.mongodb:mongodb-driver-sync:5.2.0\") } 3. Ejemplo sobre la colecci\u00f3n Libros Crea un archivo Main.kt en un paquete nuevo llamado mongo con el siguiente c\u00f3digo: import com.mongodb.client.MongoClients import com.mongodb.client.MongoCollection import com.mongodb.client.MongoDatabase import org.bson.Document fun main() { // 1Conexi\u00f3n al servidor local val uri = \"mongodb://localhost:27017\" val client = MongoClients.create(uri) // Seleccionar base de datos val database: MongoDatabase = client.getDatabase(\"biblioteca\") // Seleccionar colecci\u00f3n val coleccion: MongoCollection<Document> = database.getCollection(\"libros\") // Insertar un documento val doc = Document(\"titulo\", \"1984\") .append(\"autor\", \"George Orwell\") .append(\"a\u00f1o\", 1949) coleccion.insertOne(doc) println(\"Documento insertado correctamente.\") // Leer documentos for (libro in coleccion.find()) { println(libro.toJson()) } client.close() } Advertencia Al ejecutar el programa os aparecer\u00e1 el siguiene mensaje: Esto no es un error, solo una advertencia. MongoDB intenta usar SLF4J (Simple Logging Facade for Java) para mostrar mensajes de registro (logs) sobre la conexi\u00f3n, operaciones, etc. Como tu proyecto no incluye ninguna librer\u00eda de logging, te avisa de que no podr\u00e1 mostrar esos logs internos, pero el programa sigue funcionando perfectamente. \ud83d\udd39Kotlin + Gradle + KMongo 1. A\u00f1adir las dependencias en Gradle En el archivo build.gradle.kts , dentro del bloque dependencies, a\u00f1adimos: dependencies { implementation(\"org.litote.kmongo:kmongo:5.1.0\") } 2. Ejemplo sobre la colecci\u00f3n Libros Crea un archivo Main.kt en un paquete nuevo llamado Kmongo con el siguiente c\u00f3digo: import org.litote.kmongo.* data class Libros(val titulo: String, val autor: String, val a\u00f1o: Int) fun main() { // Crear conexi\u00f3n val client = KMongo.createClient() // Por defecto: mongodb://localhost:27017 val database = client.getDatabase(\"biblioteca\") val coleccion = database.getCollection<Libros>() // Insertar datos val libro = Libros(\"Fahrenheit 451\", \"Ray Bradbury\", 1953) coleccion.insertOne(libro) println(\"Libro insertado correctamente\") // Consultar datos val resultados = coleccion.find() resultados.forEach { println(it) } client.close() } Nota Aparecer\u00e1n los dos libros insertados, tanto en el ejemplo anterior como en este, ya que la colecci\u00f3n Libros es la misma. \ud83d\udd39Control de errores Cuando un programa se conecta a una base de datos como MongoDB, siempre existe la posibilidad de que ocurran errores: la base de datos puede no estar disponible, los datos pueden ser incorrectos o una operaci\u00f3n puede fallar por un conflicto o por formato inv\u00e1lido. Por eso, es importante incluir control de errores en el c\u00f3digo, especialmente en las operaciones de conexi\u00f3n y en las operaciones CRUD (insertar, leer, actualizar, eliminar). El control de errores se hace con bloques try-catch . As\u00ed puedes capturar las excepciones y evitar que el programa se detenga bruscamente. Buenas pr\u00e1cticas: Verificar que el servidor MongoDB est\u00e1 en ejecuci\u00f3n antes de conectar. Usar try-catch en las secciones cr\u00edticas del programa (especialmente conexi\u00f3n e inserci\u00f3n). Mostrar mensajes claros al usuario para facilitar el diagn\u00f3stico. Cerrar el cliente con client.close() en un bloque finally si se usa una conexi\u00f3n persistente. try { val client = KMongo.createClient() // Por defecto: mongodb://localhost:27017 val database = client.getDatabase(\"biblioteca\") val coleccion = database.getCollection<Libros>() // Insertar datos val libro = Libros(\"Fahrenheit 451\", \"Ray Bradbury\", 1953) coleccion.insertOne(libro) println(\"Libro insertado correctamente\") // Consultar datos val resultados = coleccion.find() resultados.forEach { println(it) } client.close() } catch (e: Exception) { println(\"\u26a0\ufe0f Error al acceder a MongoDB: ${e.message}\") } finally { //si se usa una conexi\u00f3n persistente. // Cierre seguro del cliente client?.close() println(\"\ud83d\udd12 Conexi\u00f3n cerrada.\") } \ud83d\udd39Construir una base de datos MongoDB Existen principalmente dos maneras de crear y poblar una base de datos en MongoDB: 1. Inserci\u00f3n manual de documentos Podemos crear los documentos directamente desde la consola de MongoDB o desde un programa, utilizando instrucciones insertOne() o insertMany() con los datos escritos a mano. Por ejemplo: db.peliculas.insertOne({ \"titol\": \"La noia terrible\", \"director\": \"Michael Verhoeven\", \"genere\": \"Drama\", \"any\": 1990 }) Este m\u00e9todo es \u00fatil para hacer pruebas r\u00e1pidas o a\u00f1adir registros sueltos, pero no resulta pr\u00e1ctico cuando tenemos muchos datos. 2. Lectura desde un archivo JSON Cuando ya disponemos de un conjunto de datos estructurados (por ejemplo, en un archivo json ), podemos leer el archivo desde un programa y convertir cada elemento en un documento MongoDB . Esto permite crear colecciones completas de forma autom\u00e1tica, sin escribir los documentos uno a uno. A partir de este archivo, un programa en Kotlin puede leer los datos y a\u00f1adirlos autom\u00e1ticamente a una colecci\u00f3n MongoDB mediante las funciones insertOne() o insertMany(). En este ejemplo veremos c\u00f3mo crear una base de datos MongoDB a partir de un archivo JSON llamado peliculas.json , que ubicaremos en un paquete llamado pelicualas ( src/main/kotlin/peliculas/ ). El programa, desarrollado en Kotlin, realiza los siguientes pasos: Lee el archivo JSON usando la librer\u00eda kotlinx.serialization/Jackson. Convierte cada elemento en un objeto de la clase Pelicula. Inserta los objetos directamente en MongoDB usando KMongo. Recupera y muestra los datos almacenados en la colecci\u00f3n. Archivo JSON [ { \"titol\": \"La noia terrible\", \"titol_or\": \"Das schreckliche M\u00e4dchen\", \"director\": \"Michael Verhoeven\", \"genere\": \"Drama\", \"durada\": 93, \"any\": 1990, \"actors\": [\"Lena Stolze\", \"Hans-Reinhard M\u00fcller\", \"Monika Baumgartner\"], \"sinopsi\": \"Una noia alemanya que viu a Passau inicia una investigaci\u00f3 sobre el passat...\" }, { \"titol\": \"Hardcore\", \"titol_or\": null, \"director\": \"Paul Schrader\", \"genere\": \"Comedia\", \"durada\": 109, \"any\": 1979, \"actors\": [\"Peter Boyle\", \"George C. Scott\", \"Season Hubley\"], \"sinopsi\": \"Un home profundament religi\u00f3s contracta un detectiu per trobar la seua filla...\" } ] Estructura del proyecto PeliculasMongo/ \u251c\u2500 build.gradle.kts \u251c\u2500 src/ \u2502 \u2514\u2500 main/ \u2502 \u2514\u2500 kotlin/ \u2502 \u2514\u2500 peliculas/ \u2502 \u251c\u2500 Pelicula.kt \u2192 clase de datos serializable \u2502 \u2514\u2500 Main.kt \u2192 programa principal con KMongo \u2514\u2500 Peliculas.json \u2192 archivo con las pel\u00edculas MainSerialization.kt Lee el archivo JSON usando la librer\u00eda kotlinx.serialization. package peliculas import kotlinx.serialization.Serializable import kotlinx.serialization.builtins.ListSerializer import kotlinx.serialization.json.Json import org.litote.kmongo.KMongo import org.litote.kmongo.getCollection import java.io.File @Serializable data class Pelicula( val titol: String = \"\", val titol_or: String? = null, val director: String = \"\", val genere: String = \"\", val durada: Int = 0, val any: Int = 0, val actors: List<String>? = null, val sinopsi: String = \"\" ) fun main() { val ruta = \"src/main/kotlin/peliculas/peliculas.json\" val archivo = File(ruta) if (!archivo.exists()) { println(\"\u274c No se ha encontrado el archivo $ruta\") return } println(\"\ud83d\udcd6 Leyendo archivo $ruta ...\") try { // 1\ufe0f\u20e3 Leer y deserializar las pel\u00edculas con kotlinx.serialization val json = Json { ignoreUnknownKeys = true } val peliculas: List<Pelicula> = json.decodeFromString( ListSerializer(Pelicula.serializer()), archivo.readText(Charsets.UTF_8) ) println(\"\u2705 Se han le\u00eddo ${peliculas.size} pel\u00edculas del archivo.\") // Conexi\u00f3n a MongoDB con KMongo val cliente = KMongo.createClient(\"mongodb://localhost:27017\") val bd = cliente.getDatabase(\"peliculas_db\") val coleccion = bd.getCollection<Pelicula>() // Limpiar colecci\u00f3n coleccion.drop() // Insertar todas las pel\u00edculas directamente (sin Document) coleccion.insertMany(peliculas) println(\"\ud83d\udcbe ${peliculas.size} pel\u00edculas insertadas correctamente.\\n\") // Consultar y mostrar todas val lista = coleccion.find().toList() println(\"\ud83d\udcdc Contenido de la colecci\u00f3n en MongoDB:\\n\") var i = 1 for (p in lista) { println(\"\ud83c\udf9e\ufe0f $i. ${p.titol} (${p.any})\") println(\" \ud83c\udfac Director: ${p.director}\") println(\" \ud83e\udde9 G\u00e9nero: ${p.genere}\") println(\" \u23f1\ufe0f Duraci\u00f3n: ${p.durada} min\") if (p.actors != null) println(\" \ud83d\udc65 Actores: ${p.actors.joinToString(\", \")}\") println(\" \ud83d\udcdd Sinopsis: ${p.sinopsi.take(100)}...\") println(\"---------------------------------------------------------\") i++ } cliente.close() println(\"\\n\ud83d\udd1a Proceso finalizado correctamente.\") } catch (e: Exception) { println(\"\u274c Error durante la ejecuci\u00f3n: ${e.message}\") e.printStackTrace() } } MainJackson.kt Lee el archivo JSON usando la librer\u00eda Jackson. package peliculas import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.readValue import org.litote.kmongo.KMongo import org.litote.kmongo.eq import org.litote.kmongo.getCollection import java.io.File import org.litote.kmongo.Id import org.litote.kmongo.newId data class Pelicula2( //Ponemos otro nombre para que no entre en conclicto con Pelicula Serializable. val _id: Id<Pelicula> = newId(), val titol: String = \"\", val titol_or: String? = null, val director: String = \"\", val genere: String = \"\", val durada: Int = 0, val any: Int = 0, val actors: List<String>? = null, val sinopsi: String = \"\" ) fun main() { val ruta = \"src/main/kotlin/peliculas/peliculas.json\" val archivo = File(ruta) if (!archivo.exists()) { println(\"\u274c No se ha encontrado el archivo $ruta\") return } println(\"\ud83d\udcd6 Leyendo archivo $ruta ...\") try { // 1\ufe0f\u20e3 Crear el mapper de Jackson val mapper = jacksonObjectMapper() // 2\ufe0f\u20e3 Leer el archivo y convertirlo en lista de Pelicula val peliculas: List<Pelicula2> = mapper.readValue(archivo) println(\"\u2705 Se han le\u00eddo ${peliculas.size} pel\u00edculas del archivo.\") // 3\ufe0f\u20e3 Conectarse a MongoDB con KMongo val cliente = KMongo.createClient(\"mongodb://localhost:27017\") val baseDatos = cliente.getDatabase(\"peliculas_db\") val coleccion = baseDatos.getCollection<Pelicula2>() // 4\ufe0f\u20e3 Limpiar colecci\u00f3n (opcional) coleccion.drop() // 5\ufe0f\u20e3 Insertar todas las pel\u00edculas de golpe coleccion.insertMany(peliculas) println(\"\ud83d\udcbe ${peliculas.size} pel\u00edculas insertadas correctamente.\\n\") // 6\ufe0f\u20e3 Mostrar todas las pel\u00edculas val lista = coleccion.find().toList() println(\"\ud83d\udcdc Contenido de la colecci\u00f3n en MongoDB:\\n\") var i = 1 for (p in lista) { println(\"\ud83c\udf9e\ufe0f $i. ${p.titol} (${p.any})\") println(\" \ud83c\udfac Director: ${p.director}\") println(\" \ud83e\udde9 G\u00e9nero: ${p.genere}\") println(\" \u23f1\ufe0f Duraci\u00f3n: ${p.durada} min\") if (p.actors != null) println(\" \ud83d\udc65 Actores: ${p.actors.joinToString(\", \")}\") println(\" \ud83d\udcdd Sinopsis: ${p.sinopsi.take(100)}...\") println(\"---------------------------------------------------------\") i++ } // 7\ufe0f\u20e3 Consultar solo los dramas, ordenados por t\u00edtulo println(\"\\n\ud83c\udfad --- Pel\u00edculas de g\u00e9nero 'Drama' ---\\n\") val dramas = coleccion.find(Pelicula::genere eq \"Drama\").sortedBy { it.titol } for (p in dramas) { println(\"${p.titol} - ${p.director} (${p.any})\") } cliente.close() println(\"\\n\ud83d\udd1a Proceso finalizado correctamente.\") } catch (e: Exception) { println(\"\u274c Error durante la ejecuci\u00f3n: ${e.message}\") e.printStackTrace() } }","title":"\ud83d\udd39Conexi\u00f3n"},{"location":"mongo/conexion/#conexion","text":"Para conectar una aplicaci\u00f3n escrita en Kotlin con una base de datos MongoDB , existen dos opciones principales, seg\u00fan el objetivo y el nivel de control que se necesite sobre las operaciones: 1\ufe0f\u20e3 Conexi\u00f3n con el controlador oficial de MongoDB ( MongoDB Driver ) Es la opci\u00f3n m\u00e1s directa y de bajo nivel. Permite trabajar con las clases del paquete com.mongodb o org.bson para realizar operaciones CRUD (crear, leer, actualizar y eliminar) sobre las colecciones. Se utiliza cuando se quiere tener control total sobre las consultas, la conexi\u00f3n y la conversi\u00f3n de documentos BSON a objetos Kotlin. 2\ufe0f\u20e3 Conexi\u00f3n mediante una librer\u00eda de mapeo (ORM/ODM), como KMongo KMongo es una capa de abstracci\u00f3n sobre el driver oficial, dise\u00f1ada espec\u00edficamente para Kotlin. Permite trabajar con data classes y consultas tipadas, simplificando el c\u00f3digo y haci\u00e9ndolo m\u00e1s idiom\u00e1tico. Es la opci\u00f3n m\u00e1s recomendada para proyectos educativos o empresariales donde se busca claridad, seguridad de tipos y menor c\u00f3digo repetitivo. A continuaci\u00f3n veremos un ejemplo pr\u00e1ctico de cada una de las dos formas de conectar Kotlin con MongoDB. Ambos ejemplos se ejecutar\u00e1n sobre MongoDB Community Server en local y se crear\u00e1n con Gradle desde IntelliJ.","title":"\ud83d\udd39Conexi\u00f3n"},{"location":"mongo/conexion/#kotlin-gradle-driver-oficial","text":"1. Crea un nuevo proyecto Al nuevo proyecto lo llamaremos, por ejemplo, BDNoSQL. 2. A\u00f1adir las dependencias en Gradle En el archivo build.gradle.kts , dentro del bloque dependencies, a\u00f1adimos: dependencies { implementation(\"org.mongodb:mongodb-driver-sync:5.2.0\") } 3. Ejemplo sobre la colecci\u00f3n Libros Crea un archivo Main.kt en un paquete nuevo llamado mongo con el siguiente c\u00f3digo: import com.mongodb.client.MongoClients import com.mongodb.client.MongoCollection import com.mongodb.client.MongoDatabase import org.bson.Document fun main() { // 1Conexi\u00f3n al servidor local val uri = \"mongodb://localhost:27017\" val client = MongoClients.create(uri) // Seleccionar base de datos val database: MongoDatabase = client.getDatabase(\"biblioteca\") // Seleccionar colecci\u00f3n val coleccion: MongoCollection<Document> = database.getCollection(\"libros\") // Insertar un documento val doc = Document(\"titulo\", \"1984\") .append(\"autor\", \"George Orwell\") .append(\"a\u00f1o\", 1949) coleccion.insertOne(doc) println(\"Documento insertado correctamente.\") // Leer documentos for (libro in coleccion.find()) { println(libro.toJson()) } client.close() } Advertencia Al ejecutar el programa os aparecer\u00e1 el siguiene mensaje: Esto no es un error, solo una advertencia. MongoDB intenta usar SLF4J (Simple Logging Facade for Java) para mostrar mensajes de registro (logs) sobre la conexi\u00f3n, operaciones, etc. Como tu proyecto no incluye ninguna librer\u00eda de logging, te avisa de que no podr\u00e1 mostrar esos logs internos, pero el programa sigue funcionando perfectamente.","title":"\ud83d\udd39Kotlin + Gradle + Driver oficial"},{"location":"mongo/conexion/#kotlin-gradle-kmongo","text":"1. A\u00f1adir las dependencias en Gradle En el archivo build.gradle.kts , dentro del bloque dependencies, a\u00f1adimos: dependencies { implementation(\"org.litote.kmongo:kmongo:5.1.0\") } 2. Ejemplo sobre la colecci\u00f3n Libros Crea un archivo Main.kt en un paquete nuevo llamado Kmongo con el siguiente c\u00f3digo: import org.litote.kmongo.* data class Libros(val titulo: String, val autor: String, val a\u00f1o: Int) fun main() { // Crear conexi\u00f3n val client = KMongo.createClient() // Por defecto: mongodb://localhost:27017 val database = client.getDatabase(\"biblioteca\") val coleccion = database.getCollection<Libros>() // Insertar datos val libro = Libros(\"Fahrenheit 451\", \"Ray Bradbury\", 1953) coleccion.insertOne(libro) println(\"Libro insertado correctamente\") // Consultar datos val resultados = coleccion.find() resultados.forEach { println(it) } client.close() } Nota Aparecer\u00e1n los dos libros insertados, tanto en el ejemplo anterior como en este, ya que la colecci\u00f3n Libros es la misma.","title":"\ud83d\udd39Kotlin + Gradle + KMongo"},{"location":"mongo/conexion/#control-de-errores","text":"Cuando un programa se conecta a una base de datos como MongoDB, siempre existe la posibilidad de que ocurran errores: la base de datos puede no estar disponible, los datos pueden ser incorrectos o una operaci\u00f3n puede fallar por un conflicto o por formato inv\u00e1lido. Por eso, es importante incluir control de errores en el c\u00f3digo, especialmente en las operaciones de conexi\u00f3n y en las operaciones CRUD (insertar, leer, actualizar, eliminar). El control de errores se hace con bloques try-catch . As\u00ed puedes capturar las excepciones y evitar que el programa se detenga bruscamente. Buenas pr\u00e1cticas: Verificar que el servidor MongoDB est\u00e1 en ejecuci\u00f3n antes de conectar. Usar try-catch en las secciones cr\u00edticas del programa (especialmente conexi\u00f3n e inserci\u00f3n). Mostrar mensajes claros al usuario para facilitar el diagn\u00f3stico. Cerrar el cliente con client.close() en un bloque finally si se usa una conexi\u00f3n persistente. try { val client = KMongo.createClient() // Por defecto: mongodb://localhost:27017 val database = client.getDatabase(\"biblioteca\") val coleccion = database.getCollection<Libros>() // Insertar datos val libro = Libros(\"Fahrenheit 451\", \"Ray Bradbury\", 1953) coleccion.insertOne(libro) println(\"Libro insertado correctamente\") // Consultar datos val resultados = coleccion.find() resultados.forEach { println(it) } client.close() } catch (e: Exception) { println(\"\u26a0\ufe0f Error al acceder a MongoDB: ${e.message}\") } finally { //si se usa una conexi\u00f3n persistente. // Cierre seguro del cliente client?.close() println(\"\ud83d\udd12 Conexi\u00f3n cerrada.\") }","title":"\ud83d\udd39Control de errores"},{"location":"mongo/conexion/#construir-una-base-de-datos-mongodb","text":"Existen principalmente dos maneras de crear y poblar una base de datos en MongoDB: 1. Inserci\u00f3n manual de documentos Podemos crear los documentos directamente desde la consola de MongoDB o desde un programa, utilizando instrucciones insertOne() o insertMany() con los datos escritos a mano. Por ejemplo: db.peliculas.insertOne({ \"titol\": \"La noia terrible\", \"director\": \"Michael Verhoeven\", \"genere\": \"Drama\", \"any\": 1990 }) Este m\u00e9todo es \u00fatil para hacer pruebas r\u00e1pidas o a\u00f1adir registros sueltos, pero no resulta pr\u00e1ctico cuando tenemos muchos datos. 2. Lectura desde un archivo JSON Cuando ya disponemos de un conjunto de datos estructurados (por ejemplo, en un archivo json ), podemos leer el archivo desde un programa y convertir cada elemento en un documento MongoDB . Esto permite crear colecciones completas de forma autom\u00e1tica, sin escribir los documentos uno a uno. A partir de este archivo, un programa en Kotlin puede leer los datos y a\u00f1adirlos autom\u00e1ticamente a una colecci\u00f3n MongoDB mediante las funciones insertOne() o insertMany(). En este ejemplo veremos c\u00f3mo crear una base de datos MongoDB a partir de un archivo JSON llamado peliculas.json , que ubicaremos en un paquete llamado pelicualas ( src/main/kotlin/peliculas/ ). El programa, desarrollado en Kotlin, realiza los siguientes pasos: Lee el archivo JSON usando la librer\u00eda kotlinx.serialization/Jackson. Convierte cada elemento en un objeto de la clase Pelicula. Inserta los objetos directamente en MongoDB usando KMongo. Recupera y muestra los datos almacenados en la colecci\u00f3n. Archivo JSON [ { \"titol\": \"La noia terrible\", \"titol_or\": \"Das schreckliche M\u00e4dchen\", \"director\": \"Michael Verhoeven\", \"genere\": \"Drama\", \"durada\": 93, \"any\": 1990, \"actors\": [\"Lena Stolze\", \"Hans-Reinhard M\u00fcller\", \"Monika Baumgartner\"], \"sinopsi\": \"Una noia alemanya que viu a Passau inicia una investigaci\u00f3 sobre el passat...\" }, { \"titol\": \"Hardcore\", \"titol_or\": null, \"director\": \"Paul Schrader\", \"genere\": \"Comedia\", \"durada\": 109, \"any\": 1979, \"actors\": [\"Peter Boyle\", \"George C. Scott\", \"Season Hubley\"], \"sinopsi\": \"Un home profundament religi\u00f3s contracta un detectiu per trobar la seua filla...\" } ] Estructura del proyecto PeliculasMongo/ \u251c\u2500 build.gradle.kts \u251c\u2500 src/ \u2502 \u2514\u2500 main/ \u2502 \u2514\u2500 kotlin/ \u2502 \u2514\u2500 peliculas/ \u2502 \u251c\u2500 Pelicula.kt \u2192 clase de datos serializable \u2502 \u2514\u2500 Main.kt \u2192 programa principal con KMongo \u2514\u2500 Peliculas.json \u2192 archivo con las pel\u00edculas MainSerialization.kt Lee el archivo JSON usando la librer\u00eda kotlinx.serialization. package peliculas import kotlinx.serialization.Serializable import kotlinx.serialization.builtins.ListSerializer import kotlinx.serialization.json.Json import org.litote.kmongo.KMongo import org.litote.kmongo.getCollection import java.io.File @Serializable data class Pelicula( val titol: String = \"\", val titol_or: String? = null, val director: String = \"\", val genere: String = \"\", val durada: Int = 0, val any: Int = 0, val actors: List<String>? = null, val sinopsi: String = \"\" ) fun main() { val ruta = \"src/main/kotlin/peliculas/peliculas.json\" val archivo = File(ruta) if (!archivo.exists()) { println(\"\u274c No se ha encontrado el archivo $ruta\") return } println(\"\ud83d\udcd6 Leyendo archivo $ruta ...\") try { // 1\ufe0f\u20e3 Leer y deserializar las pel\u00edculas con kotlinx.serialization val json = Json { ignoreUnknownKeys = true } val peliculas: List<Pelicula> = json.decodeFromString( ListSerializer(Pelicula.serializer()), archivo.readText(Charsets.UTF_8) ) println(\"\u2705 Se han le\u00eddo ${peliculas.size} pel\u00edculas del archivo.\") // Conexi\u00f3n a MongoDB con KMongo val cliente = KMongo.createClient(\"mongodb://localhost:27017\") val bd = cliente.getDatabase(\"peliculas_db\") val coleccion = bd.getCollection<Pelicula>() // Limpiar colecci\u00f3n coleccion.drop() // Insertar todas las pel\u00edculas directamente (sin Document) coleccion.insertMany(peliculas) println(\"\ud83d\udcbe ${peliculas.size} pel\u00edculas insertadas correctamente.\\n\") // Consultar y mostrar todas val lista = coleccion.find().toList() println(\"\ud83d\udcdc Contenido de la colecci\u00f3n en MongoDB:\\n\") var i = 1 for (p in lista) { println(\"\ud83c\udf9e\ufe0f $i. ${p.titol} (${p.any})\") println(\" \ud83c\udfac Director: ${p.director}\") println(\" \ud83e\udde9 G\u00e9nero: ${p.genere}\") println(\" \u23f1\ufe0f Duraci\u00f3n: ${p.durada} min\") if (p.actors != null) println(\" \ud83d\udc65 Actores: ${p.actors.joinToString(\", \")}\") println(\" \ud83d\udcdd Sinopsis: ${p.sinopsi.take(100)}...\") println(\"---------------------------------------------------------\") i++ } cliente.close() println(\"\\n\ud83d\udd1a Proceso finalizado correctamente.\") } catch (e: Exception) { println(\"\u274c Error durante la ejecuci\u00f3n: ${e.message}\") e.printStackTrace() } } MainJackson.kt Lee el archivo JSON usando la librer\u00eda Jackson. package peliculas import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.readValue import org.litote.kmongo.KMongo import org.litote.kmongo.eq import org.litote.kmongo.getCollection import java.io.File import org.litote.kmongo.Id import org.litote.kmongo.newId data class Pelicula2( //Ponemos otro nombre para que no entre en conclicto con Pelicula Serializable. val _id: Id<Pelicula> = newId(), val titol: String = \"\", val titol_or: String? = null, val director: String = \"\", val genere: String = \"\", val durada: Int = 0, val any: Int = 0, val actors: List<String>? = null, val sinopsi: String = \"\" ) fun main() { val ruta = \"src/main/kotlin/peliculas/peliculas.json\" val archivo = File(ruta) if (!archivo.exists()) { println(\"\u274c No se ha encontrado el archivo $ruta\") return } println(\"\ud83d\udcd6 Leyendo archivo $ruta ...\") try { // 1\ufe0f\u20e3 Crear el mapper de Jackson val mapper = jacksonObjectMapper() // 2\ufe0f\u20e3 Leer el archivo y convertirlo en lista de Pelicula val peliculas: List<Pelicula2> = mapper.readValue(archivo) println(\"\u2705 Se han le\u00eddo ${peliculas.size} pel\u00edculas del archivo.\") // 3\ufe0f\u20e3 Conectarse a MongoDB con KMongo val cliente = KMongo.createClient(\"mongodb://localhost:27017\") val baseDatos = cliente.getDatabase(\"peliculas_db\") val coleccion = baseDatos.getCollection<Pelicula2>() // 4\ufe0f\u20e3 Limpiar colecci\u00f3n (opcional) coleccion.drop() // 5\ufe0f\u20e3 Insertar todas las pel\u00edculas de golpe coleccion.insertMany(peliculas) println(\"\ud83d\udcbe ${peliculas.size} pel\u00edculas insertadas correctamente.\\n\") // 6\ufe0f\u20e3 Mostrar todas las pel\u00edculas val lista = coleccion.find().toList() println(\"\ud83d\udcdc Contenido de la colecci\u00f3n en MongoDB:\\n\") var i = 1 for (p in lista) { println(\"\ud83c\udf9e\ufe0f $i. ${p.titol} (${p.any})\") println(\" \ud83c\udfac Director: ${p.director}\") println(\" \ud83e\udde9 G\u00e9nero: ${p.genere}\") println(\" \u23f1\ufe0f Duraci\u00f3n: ${p.durada} min\") if (p.actors != null) println(\" \ud83d\udc65 Actores: ${p.actors.joinToString(\", \")}\") println(\" \ud83d\udcdd Sinopsis: ${p.sinopsi.take(100)}...\") println(\"---------------------------------------------------------\") i++ } // 7\ufe0f\u20e3 Consultar solo los dramas, ordenados por t\u00edtulo println(\"\\n\ud83c\udfad --- Pel\u00edculas de g\u00e9nero 'Drama' ---\\n\") val dramas = coleccion.find(Pelicula::genere eq \"Drama\").sortedBy { it.titol } for (p in dramas) { println(\"${p.titol} - ${p.director} (${p.any})\") } cliente.close() println(\"\\n\ud83d\udd1a Proceso finalizado correctamente.\") } catch (e: Exception) { println(\"\u274c Error durante la ejecuci\u00f3n: ${e.message}\") e.printStackTrace() } }","title":"\ud83d\udd39Construir una base de datos MongoDB"},{"location":"mongo/instalacion/","text":"Instalaci\u00f3n Hoy en d\u00eda existen m\u00faltiples opciones para trabajar con MongoDB, tanto a nivel de instalaci\u00f3n como de desarrollo y administraci\u00f3n. Aqu\u00ed tienes un resumen actualizado, organizado por categor\u00edas \ud83d\udc47 \u2699\ufe0f 1. Opciones de instalaci\u00f3n y despliegue Opci\u00f3n Descripci\u00f3n Ideal para \ud83d\udda5\ufe0f MongoDB Community Server Versi\u00f3n gratuita que se instala localmente en Windows, Linux o macOS. Pr\u00e1cticas locales, entornos educativos. \ud83d\udc33 MongoDB en Docker Se ejecuta como contenedor con docker-compose o comandos docker run . Entornos de desarrollo r\u00e1pidos y reproducibles. \u2601\ufe0f MongoDB Atlas Servicio en la nube oficial de MongoDB. Permite crear cl\u00fasteres gratuitos o de pago, gestionados por Mongo. Proyectos web, microservicios, despliegues reales. \ud83e\udde9 MongoDB Local + Atlas Sync Permite sincronizar datos locales con una base remota en Atlas. Aplicaciones con modo offline/online. \ud83d\udcbb 2. Herramientas de administraci\u00f3n y visualizaci\u00f3n Herramienta Tipo Descripci\u00f3n \ud83e\udded MongoDB Compass GUI oficial Interfaz gr\u00e1fica para consultar, insertar y analizar datos. \ud83d\udc18 DBeaver GUI universal Permite conectarse a Mongo y a otras bases de datos (SQL y NoSQL). \ud83e\uddd1\u200d\ud83d\udcbb Robo 3T (antiguo Robomongo) GUI ligera Muy utilizada para tareas b\u00e1sicas de exploraci\u00f3n. \ud83d\udcdc mongosh Consola oficial Shell de comandos moderno (sustituye a mongo ). \ud83c\udfaf De entre todas las opciones posibles para instalar y administrar MongoDB, hemos elegido utilizar la versi\u00f3n Community junto con Mongo Shell (mongosh) por su simplicidad, ligereza y adecuaci\u00f3n a los objetivos de esta unidad. \ud83d\udc27 Instalaci\u00f3n en Linux Para realizar la instalaci\u00f3n m\u00e1s b\u00e1sica, podemos hacerlo sin permisos de administrador. Si los tenemos, todo ser\u00e1 m\u00e1s c\u00f3modo, pero si no, tambi\u00e9n es posible, como veremos y destacaremos a continuaci\u00f3n. \u2699\ufe0f Instalaci\u00f3n del servidor (Linux) Desde la p\u00e1gina oficial de MongoDB: https://www.mongodb.com/try/download/community vamos al men\u00fa Products \u2192 Community Edition \u2192 Community Server y descargamos la versi\u00f3n apropiada para nuestro sistema operativo. Observa que, en el caso de Linux, hay muchas versiones para distintas distribuciones. Es recomendable elegir el paquete .tgz , ya que simplemente descomprimiendo el archivo se completa la instalaci\u00f3n b\u00e1sica. Por ejemplo, para Ubuntu 22.04 de 64 bits, en el momento de redactar estos apuntes, el archivo ser\u00eda: https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu2204-8.2.1.tgz Recuerda comprobar siempre que la versi\u00f3n coincide con la de tu sistema operativo. Sencillamente, descomprimiremos este archivo en el lugar que queramos, y con eso ya tendremos la instalaci\u00f3n b\u00e1sica lista. \ud83d\udcc1 Una vez instalado, crearemos el directorio de datos, que por defecto ha de estar ubicado en la raiz de la instalaci\u00f3n: mkdir /data mkdir /data/db El \u00fanico problema que podr\u00edamos tener, si no somos administradores, es no tener permiso para crear ese directorio. En ese caso, crearemos otro directorio alternativo y, en el momento de arrancar el servidor, le indicaremos esa ubicaci\u00f3n. \u25b6\ufe0f La forma de arrancar el servidor ser\u00e1: <directoro ra\u00edz de MongoDB>./bin/mongod Opcionalmente, podemos indicarle a MongoDB d\u00f3nde se encuentra la base de datos (si no lo especificamos, asumir\u00e1 por defecto que est\u00e1 en /data/db): <directorio ra\u00edz de MongoDB>./bin/mongod --dbpath <directorio_de_la_BD> Una vez arrancamos el servidor, y si todo es correcto, aparecer\u00e1n una serie de mensajes informativos y el servidor quedar\u00e1 en espera de recibir peticiones del cliente: Nota Una vez que el servidor est\u00e1 en marcha, no debemos cerrar esa terminal, ya que al hacerlo detendr\u00edamos el servidor. \u2699\ufe0f Instalaci\u00f3n del cliente MongoShell (Linux) Desde la p\u00e1gina de MongoDB https://www.mongodb.com/try/download/shell vamos al men\u00fa Products \u2192 Tools \u2192 MongoDB Shell , y descargamos la versi\u00f3n apropiada para nuestro sistema operativo. Observa que, en el caso de Linux, existen muchas versiones para diferentes distribuciones. Es recomendable elegir el paquete .tgz , ya que simplemente descomprimiendo el archivo se completa la instalaci\u00f3n. En el caso de Ubuntu 22.04 de 64 bits, seleccionaremos la opci\u00f3n gen\u00e9rica \u201cLinux 64\u201d, ya que es la que ofrece el paquete .tgz. El archivo correspondiente es: https://downloads.mongodb.com/compass/mongosh-2.4.0-linux-x64.tgz Recuerda asegurarte siempre de que la versi\u00f3n sea la correcta para tu sistema. Sencillamente descomprimiremos este archivo en el lugar que queramos, y con eso ya tendremos hecha la instalaci\u00f3n b\u00e1sica. \u25b6\ufe0f La forma de arrancar el cliente ser\u00e1: <directori ra\u00edz de Mongosh>./bin/mongosh \ud83e\ude9f Instalaci\u00f3n en Windows \u2699\ufe0f Instalaci\u00f3n del servidor (Windows) Desde la p\u00e1gina oficial de MongoDB: https://www.mongodb.com/try/download/community vamos al men\u00fa Products \u2192 Community Edition \u2192 Community Server y descargamos la versi\u00f3n apropiada para nuestro sistema operativo, que se distribuye como un archivo .msi ejecutable. \ud83d\udd3dEn el momento de redactar estos apuntes, la versi\u00f3n de 64 bits m\u00e1s reciente: https://fastdl.mongodb.org/windows/mongodb-windows-x86_64-8.2.1-signed.msi Durante la instalaci\u00f3n, se te preguntar\u00e1 si deseas instalarlo como un servicio. Si eliges esta opci\u00f3n, el programa se iniciar\u00e1 autom\u00e1ticamente con el sistema y no tendr\u00e1s que ejecutarlo manualmente cada vez. \ud83c\udfafSi instalaste MongoDB como servicio, se inicia autom\u00e1ticamente al arrancar Windows, puedes comprobarlo con: net start | find \"MongoDB\" Nota Si eliges no instalar MongoDB como servicio, deber\u00e1s iniciarlo manualmente cada vez que quieras usarlo. En este caso, es necesario crear la carpeta donde se almacenar\u00e1n los datos de la base de datos. \ud83d\udcbb Instalaci\u00f3n del cliente Mongo Shell (Windows) Para conectarnos como clientes, debemos hacerlo desde un terminal, utilizando mongosh.exe, que es la interfaz de l\u00ednea de comandos (CLI) oficial de MongoDB. Esta herramienta permite interactuar con la base de datos mediante comandos en JavaScript. \ud83d\udd3dDescargamos la versi\u00f3n correspondiente de MongoDB Shell para Windows desde la p\u00e1gina oficial: https://www.mongodb.com/try/download/shell \ud83d\udd3dEn el momento de redactar estos apuntes, la versi\u00f3n de 64 bits m\u00e1s reciente: https://downloads.mongodb.com/compass/mongosh-2.5.8-x64.msi Una vez el servidor est\u00e9 activo, simplemente escribe: mongosh Dentro del shell, prueba con: show dbs Si ves las bases de datos (admin, config, local), todo est\u00e1 funcionando correctamente: Mongo Compass Tambi\u00e9n pod\u00e9is descargar la versi\u00f3n MongoDB Compass , que es la herramienta gr\u00e1fica oficial de MongoDB, la cual permite visualizar, explorar y administrar bases de datos MongoDB sin necesidad de utilizar la l\u00ednea de comandos. https://downloads.mongodb.com/compass/mongodb-compass-1.45.3-win32-x64.exe Probar el funcionament Para probar su funcionamiento, vamos a ejecutar un par de comandos: uno para guardar un documento y otro para recuperarlo. En cualquier operaci\u00f3n, debemos escribir db seguido del nombre de la colecci\u00f3n, y despu\u00e9s la operaci\u00f3n que queremos realizar. Con el siguiente comando: db.ejemplo.insertOne({ msg: \"Hola, \u00bfqu\u00e9 tal?\" }) Nos responder\u00e1 con: { acknowledged: true, insertedId: ObjectId('68ff6004ab24a06f35cebea4') } Indicando que se ha insertado un documento en la colecci\u00f3n ejemplo (si no exist\u00eda, la crear\u00e1 autom\u00e1ticamente). Y con el siguiente comando recuperamos la informaci\u00f3n: db.ejemplo.find() Lo que nos devolver\u00e1 algo como: { \"_id\" : ObjectId(\"56cc1acd73b559230de8f71b\"), \"msg\" : \"Hola, \u00bfqu\u00e9 tal?\" } Todo esto se realiza en la misma terminal, y cada uno de nosotros obtendr\u00e1 un n\u00famero diferente en el campo ObjectId . En la siguiente imagen pueden verse las dos operaciones. En realidad, estamos conectados a una base de datos llamada test. Podemos crear y utilizar m\u00e1s de una base de datos, pero en este curso ser\u00e1 m\u00e1s que suficiente trabajar con esta. Para comprobarlo, podemos ejecutar la siguiente instrucci\u00f3n, que nos devuelve el nombre de la base de datos actual : db.getName()","title":"\ud83d\udd39Instalaci\u00f3n"},{"location":"mongo/instalacion/#instalacion","text":"Hoy en d\u00eda existen m\u00faltiples opciones para trabajar con MongoDB, tanto a nivel de instalaci\u00f3n como de desarrollo y administraci\u00f3n. Aqu\u00ed tienes un resumen actualizado, organizado por categor\u00edas \ud83d\udc47 \u2699\ufe0f 1. Opciones de instalaci\u00f3n y despliegue Opci\u00f3n Descripci\u00f3n Ideal para \ud83d\udda5\ufe0f MongoDB Community Server Versi\u00f3n gratuita que se instala localmente en Windows, Linux o macOS. Pr\u00e1cticas locales, entornos educativos. \ud83d\udc33 MongoDB en Docker Se ejecuta como contenedor con docker-compose o comandos docker run . Entornos de desarrollo r\u00e1pidos y reproducibles. \u2601\ufe0f MongoDB Atlas Servicio en la nube oficial de MongoDB. Permite crear cl\u00fasteres gratuitos o de pago, gestionados por Mongo. Proyectos web, microservicios, despliegues reales. \ud83e\udde9 MongoDB Local + Atlas Sync Permite sincronizar datos locales con una base remota en Atlas. Aplicaciones con modo offline/online. \ud83d\udcbb 2. Herramientas de administraci\u00f3n y visualizaci\u00f3n Herramienta Tipo Descripci\u00f3n \ud83e\udded MongoDB Compass GUI oficial Interfaz gr\u00e1fica para consultar, insertar y analizar datos. \ud83d\udc18 DBeaver GUI universal Permite conectarse a Mongo y a otras bases de datos (SQL y NoSQL). \ud83e\uddd1\u200d\ud83d\udcbb Robo 3T (antiguo Robomongo) GUI ligera Muy utilizada para tareas b\u00e1sicas de exploraci\u00f3n. \ud83d\udcdc mongosh Consola oficial Shell de comandos moderno (sustituye a mongo ). \ud83c\udfaf De entre todas las opciones posibles para instalar y administrar MongoDB, hemos elegido utilizar la versi\u00f3n Community junto con Mongo Shell (mongosh) por su simplicidad, ligereza y adecuaci\u00f3n a los objetivos de esta unidad.","title":"Instalaci\u00f3n"},{"location":"mongo/instalacion/#instalacion-en-linux","text":"Para realizar la instalaci\u00f3n m\u00e1s b\u00e1sica, podemos hacerlo sin permisos de administrador. Si los tenemos, todo ser\u00e1 m\u00e1s c\u00f3modo, pero si no, tambi\u00e9n es posible, como veremos y destacaremos a continuaci\u00f3n. \u2699\ufe0f Instalaci\u00f3n del servidor (Linux) Desde la p\u00e1gina oficial de MongoDB: https://www.mongodb.com/try/download/community vamos al men\u00fa Products \u2192 Community Edition \u2192 Community Server y descargamos la versi\u00f3n apropiada para nuestro sistema operativo. Observa que, en el caso de Linux, hay muchas versiones para distintas distribuciones. Es recomendable elegir el paquete .tgz , ya que simplemente descomprimiendo el archivo se completa la instalaci\u00f3n b\u00e1sica. Por ejemplo, para Ubuntu 22.04 de 64 bits, en el momento de redactar estos apuntes, el archivo ser\u00eda: https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu2204-8.2.1.tgz Recuerda comprobar siempre que la versi\u00f3n coincide con la de tu sistema operativo. Sencillamente, descomprimiremos este archivo en el lugar que queramos, y con eso ya tendremos la instalaci\u00f3n b\u00e1sica lista. \ud83d\udcc1 Una vez instalado, crearemos el directorio de datos, que por defecto ha de estar ubicado en la raiz de la instalaci\u00f3n: mkdir /data mkdir /data/db El \u00fanico problema que podr\u00edamos tener, si no somos administradores, es no tener permiso para crear ese directorio. En ese caso, crearemos otro directorio alternativo y, en el momento de arrancar el servidor, le indicaremos esa ubicaci\u00f3n. \u25b6\ufe0f La forma de arrancar el servidor ser\u00e1: <directoro ra\u00edz de MongoDB>./bin/mongod Opcionalmente, podemos indicarle a MongoDB d\u00f3nde se encuentra la base de datos (si no lo especificamos, asumir\u00e1 por defecto que est\u00e1 en /data/db): <directorio ra\u00edz de MongoDB>./bin/mongod --dbpath <directorio_de_la_BD> Una vez arrancamos el servidor, y si todo es correcto, aparecer\u00e1n una serie de mensajes informativos y el servidor quedar\u00e1 en espera de recibir peticiones del cliente: Nota Una vez que el servidor est\u00e1 en marcha, no debemos cerrar esa terminal, ya que al hacerlo detendr\u00edamos el servidor. \u2699\ufe0f Instalaci\u00f3n del cliente MongoShell (Linux) Desde la p\u00e1gina de MongoDB https://www.mongodb.com/try/download/shell vamos al men\u00fa Products \u2192 Tools \u2192 MongoDB Shell , y descargamos la versi\u00f3n apropiada para nuestro sistema operativo. Observa que, en el caso de Linux, existen muchas versiones para diferentes distribuciones. Es recomendable elegir el paquete .tgz , ya que simplemente descomprimiendo el archivo se completa la instalaci\u00f3n. En el caso de Ubuntu 22.04 de 64 bits, seleccionaremos la opci\u00f3n gen\u00e9rica \u201cLinux 64\u201d, ya que es la que ofrece el paquete .tgz. El archivo correspondiente es: https://downloads.mongodb.com/compass/mongosh-2.4.0-linux-x64.tgz Recuerda asegurarte siempre de que la versi\u00f3n sea la correcta para tu sistema. Sencillamente descomprimiremos este archivo en el lugar que queramos, y con eso ya tendremos hecha la instalaci\u00f3n b\u00e1sica. \u25b6\ufe0f La forma de arrancar el cliente ser\u00e1: <directori ra\u00edz de Mongosh>./bin/mongosh","title":"\ud83d\udc27 Instalaci\u00f3n en Linux"},{"location":"mongo/instalacion/#instalacion-en-windows","text":"\u2699\ufe0f Instalaci\u00f3n del servidor (Windows) Desde la p\u00e1gina oficial de MongoDB: https://www.mongodb.com/try/download/community vamos al men\u00fa Products \u2192 Community Edition \u2192 Community Server y descargamos la versi\u00f3n apropiada para nuestro sistema operativo, que se distribuye como un archivo .msi ejecutable. \ud83d\udd3dEn el momento de redactar estos apuntes, la versi\u00f3n de 64 bits m\u00e1s reciente: https://fastdl.mongodb.org/windows/mongodb-windows-x86_64-8.2.1-signed.msi Durante la instalaci\u00f3n, se te preguntar\u00e1 si deseas instalarlo como un servicio. Si eliges esta opci\u00f3n, el programa se iniciar\u00e1 autom\u00e1ticamente con el sistema y no tendr\u00e1s que ejecutarlo manualmente cada vez. \ud83c\udfafSi instalaste MongoDB como servicio, se inicia autom\u00e1ticamente al arrancar Windows, puedes comprobarlo con: net start | find \"MongoDB\" Nota Si eliges no instalar MongoDB como servicio, deber\u00e1s iniciarlo manualmente cada vez que quieras usarlo. En este caso, es necesario crear la carpeta donde se almacenar\u00e1n los datos de la base de datos. \ud83d\udcbb Instalaci\u00f3n del cliente Mongo Shell (Windows) Para conectarnos como clientes, debemos hacerlo desde un terminal, utilizando mongosh.exe, que es la interfaz de l\u00ednea de comandos (CLI) oficial de MongoDB. Esta herramienta permite interactuar con la base de datos mediante comandos en JavaScript. \ud83d\udd3dDescargamos la versi\u00f3n correspondiente de MongoDB Shell para Windows desde la p\u00e1gina oficial: https://www.mongodb.com/try/download/shell \ud83d\udd3dEn el momento de redactar estos apuntes, la versi\u00f3n de 64 bits m\u00e1s reciente: https://downloads.mongodb.com/compass/mongosh-2.5.8-x64.msi Una vez el servidor est\u00e9 activo, simplemente escribe: mongosh Dentro del shell, prueba con: show dbs Si ves las bases de datos (admin, config, local), todo est\u00e1 funcionando correctamente: Mongo Compass Tambi\u00e9n pod\u00e9is descargar la versi\u00f3n MongoDB Compass , que es la herramienta gr\u00e1fica oficial de MongoDB, la cual permite visualizar, explorar y administrar bases de datos MongoDB sin necesidad de utilizar la l\u00ednea de comandos. https://downloads.mongodb.com/compass/mongodb-compass-1.45.3-win32-x64.exe Probar el funcionament Para probar su funcionamiento, vamos a ejecutar un par de comandos: uno para guardar un documento y otro para recuperarlo. En cualquier operaci\u00f3n, debemos escribir db seguido del nombre de la colecci\u00f3n, y despu\u00e9s la operaci\u00f3n que queremos realizar. Con el siguiente comando: db.ejemplo.insertOne({ msg: \"Hola, \u00bfqu\u00e9 tal?\" }) Nos responder\u00e1 con: { acknowledged: true, insertedId: ObjectId('68ff6004ab24a06f35cebea4') } Indicando que se ha insertado un documento en la colecci\u00f3n ejemplo (si no exist\u00eda, la crear\u00e1 autom\u00e1ticamente). Y con el siguiente comando recuperamos la informaci\u00f3n: db.ejemplo.find() Lo que nos devolver\u00e1 algo como: { \"_id\" : ObjectId(\"56cc1acd73b559230de8f71b\"), \"msg\" : \"Hola, \u00bfqu\u00e9 tal?\" } Todo esto se realiza en la misma terminal, y cada uno de nosotros obtendr\u00e1 un n\u00famero diferente en el campo ObjectId . En la siguiente imagen pueden verse las dos operaciones. En realidad, estamos conectados a una base de datos llamada test. Podemos crear y utilizar m\u00e1s de una base de datos, pero en este curso ser\u00e1 m\u00e1s que suficiente trabajar con esta. Para comprobarlo, podemos ejecutar la siguiente instrucci\u00f3n, que nos devuelve el nombre de la base de datos actual : db.getName()","title":"\ud83e\ude9f Instalaci\u00f3n en Windows"},{"location":"mongo/json/","text":"JSON JSON (JavaScript Object Notation) es un formato de texto ligero utilizado para almacenar e intercambiar informaci\u00f3n estructurada entre aplicaciones. Aunque su sintaxis proviene de JavaScript, hoy en d\u00eda es independiente del lenguaje y se usa ampliamente en entornos como Kotlin, Java, Python, Node.js, bases de datos NoSQL, APIs REST, etc. Un fichero JSON est\u00e1 compuesto por pares clave\u2013valor , donde: Las claves siempre van entre comillas dobles \" \". Los valores pueden ser: Cadenas de texto (\"texto\") N\u00fameros (42) Booleanos (true o false) Objetos (otro conjunto de pares clave-valor { ... }) Arrays o listas ([ ... ]) Valor nulo (null) Ejemplos de estructuras JSON \ud83d\udd39 Objeto simple : Representa un \u00fanico elemento con propiedades b\u00e1sicas. { \"nombre\": \"Ana\", \"edad\": 25, \"ciudad\": \"Valencia\" } \ud83d\udd39 Objeto con array (lista de valores): Incluye un campo que contiene una lista. { \"nombre\": \"Pedro\", \"aficiones\": [\"cine\", \"f\u00fatbol\", \"viajar\"] } \ud83d\udd39 Objeto con otro objeto anidado : Un campo puede contener a su vez otro objeto JSON. { \"nombre\": \"Luc\u00eda\", \"edad\": 30, \"direccion\": { \"calle\": \"Gran V\u00eda\", \"ciudad\": \"Madrid\", \"codigo_postal\": 28013 } } \ud83d\udd39 Array de objetos : Cuando necesitamos almacenar varios elementos similares (por ejemplo, una lista de productos o alumnos). { \"alumnos\": [ { \"nombre\": \"Carlos\", \"nota\": 8.5 }, { \"nombre\": \"Mar\u00eda\", \"nota\": 9.2 }, { \"nombre\": \"Laura\", \"nota\": 7.8 } ] } \ud83d\udd39 Combinaci\u00f3n compleja (objetos + arrays + anidamientos) : Para representar datos estructurados, como los de una tienda online. { \"pedido\": { \"id\": 101, \"fecha\": \"2025-10-11\", \"cliente\": { \"nombre\": \"Javier L\u00f3pez\", \"email\": \"jlopez@example.com\" }, \"productos\": [ { \"nombre\": \"Rat\u00f3n inal\u00e1mbrico\", \"precio\": 19.99, \"cantidad\": 1 }, { \"nombre\": \"Teclado mec\u00e1nico\", \"precio\": 49.95, \"cantidad\": 1 } ], \"total\": 69.94 } } \ud83d\udd39 Array de objetos principales : Tambi\u00e9n se puede usar un array como estructura ra\u00edz, por ejemplo, para representar varios registros en un mismo fichero: [ { \"nombre\": \"Ana\", \"edad\": 25 }, { \"nombre\": \"Pedro\", \"edad\": 31 }, { \"nombre\": \"Luc\u00eda\", \"edad\": 28 } ]","title":"\ud83d\udd39JSON"},{"location":"mongo/json/#json","text":"JSON (JavaScript Object Notation) es un formato de texto ligero utilizado para almacenar e intercambiar informaci\u00f3n estructurada entre aplicaciones. Aunque su sintaxis proviene de JavaScript, hoy en d\u00eda es independiente del lenguaje y se usa ampliamente en entornos como Kotlin, Java, Python, Node.js, bases de datos NoSQL, APIs REST, etc. Un fichero JSON est\u00e1 compuesto por pares clave\u2013valor , donde: Las claves siempre van entre comillas dobles \" \". Los valores pueden ser: Cadenas de texto (\"texto\") N\u00fameros (42) Booleanos (true o false) Objetos (otro conjunto de pares clave-valor { ... }) Arrays o listas ([ ... ]) Valor nulo (null) Ejemplos de estructuras JSON \ud83d\udd39 Objeto simple : Representa un \u00fanico elemento con propiedades b\u00e1sicas. { \"nombre\": \"Ana\", \"edad\": 25, \"ciudad\": \"Valencia\" } \ud83d\udd39 Objeto con array (lista de valores): Incluye un campo que contiene una lista. { \"nombre\": \"Pedro\", \"aficiones\": [\"cine\", \"f\u00fatbol\", \"viajar\"] } \ud83d\udd39 Objeto con otro objeto anidado : Un campo puede contener a su vez otro objeto JSON. { \"nombre\": \"Luc\u00eda\", \"edad\": 30, \"direccion\": { \"calle\": \"Gran V\u00eda\", \"ciudad\": \"Madrid\", \"codigo_postal\": 28013 } } \ud83d\udd39 Array de objetos : Cuando necesitamos almacenar varios elementos similares (por ejemplo, una lista de productos o alumnos). { \"alumnos\": [ { \"nombre\": \"Carlos\", \"nota\": 8.5 }, { \"nombre\": \"Mar\u00eda\", \"nota\": 9.2 }, { \"nombre\": \"Laura\", \"nota\": 7.8 } ] } \ud83d\udd39 Combinaci\u00f3n compleja (objetos + arrays + anidamientos) : Para representar datos estructurados, como los de una tienda online. { \"pedido\": { \"id\": 101, \"fecha\": \"2025-10-11\", \"cliente\": { \"nombre\": \"Javier L\u00f3pez\", \"email\": \"jlopez@example.com\" }, \"productos\": [ { \"nombre\": \"Rat\u00f3n inal\u00e1mbrico\", \"precio\": 19.99, \"cantidad\": 1 }, { \"nombre\": \"Teclado mec\u00e1nico\", \"precio\": 49.95, \"cantidad\": 1 } ], \"total\": 69.94 } } \ud83d\udd39 Array de objetos principales : Tambi\u00e9n se puede usar un array como estructura ra\u00edz, por ejemplo, para representar varios registros en un mismo fichero: [ { \"nombre\": \"Ana\", \"edad\": 25 }, { \"nombre\": \"Pedro\", \"edad\": 31 }, { \"nombre\": \"Luc\u00eda\", \"edad\": 28 } ]","title":"JSON"}]}