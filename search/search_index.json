{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bases de Datos Documentales Nativas","title":"Acceso a Datos - Bases de Datos Documentales Nativas"},{"location":"#bases-de-datos-documentales-nativas","text":"","title":"Bases de Datos Documentales Nativas"},{"location":"Introduccion/","text":"\ud83d\udd39Introducci\u00f3n Las bases de datos documentales nativas (como MongoDB, Redis o Firebase) almacenan informaci\u00f3n en forma de documentos, usualmente codificados en JSON, BSON o XML, en lugar de filas y columnas como en las bases de datos relacionales. Cada documento puede tener una estructura diferente, lo que permite mayor flexibilidad y agilidad en el desarrollo. Sin embargo, si el dominio de la aplicaci\u00f3n tiene muchas relaciones fuertes entre entidades y se necesita garantizar una integridad referencial estricta, una base de datos relacional puede ser m\u00e1s adecuada. Ventajas Ventaja Descripci\u00f3n Flexibilidad del esquema No es necesario definir un esquema fijo antes de insertar datos. Ideal para estructuras din\u00e1micas. Escalabilidad horizontal Se adaptan bien al escalado distribuyendo los datos en m\u00faltiples servidores (sharding). Rendimiento en lectura y escritura Muy eficiente en operaciones de lectura y escritura sobre documentos completos. Modelo cercano a objetos Almacenan los datos de manera similar a como se manejan en el c\u00f3digo (objetos serializados como JSON). Facilidad de integraci\u00f3n con APIs REST Los documentos JSON pueden ser enviados y recibidos f\u00e1cilmente a trav\u00e9s de APIs. Ideal para datos semiestructurados \u00datiles para trabajar con datos que no se ajustan a una estructura tabular, como respuestas de formularios, logs, etc. Inconvenientes Inconveniente Descripci\u00f3n Falta de integridad referencial No hay claves for\u00e1neas como en las bases de datos relacionales, lo que puede causar inconsistencias si no se gestiona adecuadamente desde la aplicaci\u00f3n. Redundancia de datos Se repite informaci\u00f3n entre documentos al no haber normalizaci\u00f3n; esto puede generar m\u00e1s uso de espacio. Curva de aprendizaje Requiere aprender nuevos conceptos como agregaciones, operadores espec\u00edficos y estructuras de documentos. Menor soporte para transacciones complejas Aunque existen transacciones en algunas bases (como MongoDB), su uso es m\u00e1s limitado que en sistemas relacionales. Consultas menos optimizadas en relaciones complejas No es la mejor opci\u00f3n cuando los datos necesitan muchas relaciones y joins complejos.","title":"\ud83d\udd39Introducci\u00f3n"},{"location":"Introduccion/#introduccion","text":"Las bases de datos documentales nativas (como MongoDB, Redis o Firebase) almacenan informaci\u00f3n en forma de documentos, usualmente codificados en JSON, BSON o XML, en lugar de filas y columnas como en las bases de datos relacionales. Cada documento puede tener una estructura diferente, lo que permite mayor flexibilidad y agilidad en el desarrollo. Sin embargo, si el dominio de la aplicaci\u00f3n tiene muchas relaciones fuertes entre entidades y se necesita garantizar una integridad referencial estricta, una base de datos relacional puede ser m\u00e1s adecuada. Ventajas Ventaja Descripci\u00f3n Flexibilidad del esquema No es necesario definir un esquema fijo antes de insertar datos. Ideal para estructuras din\u00e1micas. Escalabilidad horizontal Se adaptan bien al escalado distribuyendo los datos en m\u00faltiples servidores (sharding). Rendimiento en lectura y escritura Muy eficiente en operaciones de lectura y escritura sobre documentos completos. Modelo cercano a objetos Almacenan los datos de manera similar a como se manejan en el c\u00f3digo (objetos serializados como JSON). Facilidad de integraci\u00f3n con APIs REST Los documentos JSON pueden ser enviados y recibidos f\u00e1cilmente a trav\u00e9s de APIs. Ideal para datos semiestructurados \u00datiles para trabajar con datos que no se ajustan a una estructura tabular, como respuestas de formularios, logs, etc. Inconvenientes Inconveniente Descripci\u00f3n Falta de integridad referencial No hay claves for\u00e1neas como en las bases de datos relacionales, lo que puede causar inconsistencias si no se gestiona adecuadamente desde la aplicaci\u00f3n. Redundancia de datos Se repite informaci\u00f3n entre documentos al no haber normalizaci\u00f3n; esto puede generar m\u00e1s uso de espacio. Curva de aprendizaje Requiere aprender nuevos conceptos como agregaciones, operadores espec\u00edficos y estructuras de documentos. Menor soporte para transacciones complejas Aunque existen transacciones en algunas bases (como MongoDB), su uso es m\u00e1s limitado que en sistemas relacionales. Consultas menos optimizadas en relaciones complejas No es la mejor opci\u00f3n cuando los datos necesitan muchas relaciones y joins complejos.","title":"\ud83d\udd39Introducci\u00f3n"},{"location":"RA_CE/","text":"\ud83d\udd39 RA5. Desarrolla aplicaciones que gestionan la informaci\u00f3n almacenada en bases de datos documentales nativas evaluando y utilizando clases espec\u00edficas Criterio de Evaluaci\u00f3n Contenidos Asociados a) Se han valorado las ventajas e inconvenientes de utilizar bases de datos documentales nativas. - Definici\u00f3n de base de datos documental (orientada a documentos). - Comparativa frente a bases de datos relacionales: rendimiento, escalabilidad, flexibilidad del esquema. - Ventajas: almacenamiento de datos semiestructurados (JSON, BSON), escalabilidad horizontal, alta disponibilidad. - Inconvenientes: falta de integridad referencial, consistencia eventual, menor madurez en algunos entornos. b) Se ha establecido la conexi\u00f3n con la base de datos. - Conectores y drivers para bases de datos como MongoDB (MongoDB Java Driver, KMongo). - Configuraci\u00f3n de la URI de conexi\u00f3n. - Gesti\u00f3n de clientes y sesiones. - Buenas pr\u00e1cticas de conexi\u00f3n y cierre de recursos. c) Se han desarrollado aplicaciones que efect\u00faan consultas sobre el contenido de la base de datos. - Uso de consultas simples y complejas en MongoDB (filtros, proyecciones, operadores l\u00f3gicos, agregaciones). - Librer\u00edas de acceso desde Kotlin (KMongo, MongoDB Java Driver). - Ejecuci\u00f3n de b\u00fasquedas por campo, rango y patr\u00f3n. d) Se han a\u00f1adido y eliminado colecciones de la base de datos. - Creaci\u00f3n din\u00e1mica de colecciones. - Eliminaci\u00f3n de colecciones y sus implicaciones. - Comprobaci\u00f3n de existencia previa. - Operaciones de administraci\u00f3n desde el c\u00f3digo. e) Se han desarrollado aplicaciones para a\u00f1adir, modificar y eliminar documentos de la base de datos. - Inserci\u00f3n de documentos JSON/BSON. - Actualizaci\u00f3n completa y parcial (updateOne, updateMany). - Eliminaci\u00f3n de documentos (deleteOne, deleteMany). - Uso de data classes de Kotlin para representar documentos. - Serializaci\u00f3n y deserializaci\u00f3n de objetos.","title":"\ud83d\udd39RA y CE"},{"location":"RA_CE/#ra5-desarrolla-aplicaciones-que-gestionan-la-informacion-almacenada-en-bases-de-datos-documentales-nativas-evaluando-y-utilizando-clases-especificas","text":"Criterio de Evaluaci\u00f3n Contenidos Asociados a) Se han valorado las ventajas e inconvenientes de utilizar bases de datos documentales nativas. - Definici\u00f3n de base de datos documental (orientada a documentos). - Comparativa frente a bases de datos relacionales: rendimiento, escalabilidad, flexibilidad del esquema. - Ventajas: almacenamiento de datos semiestructurados (JSON, BSON), escalabilidad horizontal, alta disponibilidad. - Inconvenientes: falta de integridad referencial, consistencia eventual, menor madurez en algunos entornos. b) Se ha establecido la conexi\u00f3n con la base de datos. - Conectores y drivers para bases de datos como MongoDB (MongoDB Java Driver, KMongo). - Configuraci\u00f3n de la URI de conexi\u00f3n. - Gesti\u00f3n de clientes y sesiones. - Buenas pr\u00e1cticas de conexi\u00f3n y cierre de recursos. c) Se han desarrollado aplicaciones que efect\u00faan consultas sobre el contenido de la base de datos. - Uso de consultas simples y complejas en MongoDB (filtros, proyecciones, operadores l\u00f3gicos, agregaciones). - Librer\u00edas de acceso desde Kotlin (KMongo, MongoDB Java Driver). - Ejecuci\u00f3n de b\u00fasquedas por campo, rango y patr\u00f3n. d) Se han a\u00f1adido y eliminado colecciones de la base de datos. - Creaci\u00f3n din\u00e1mica de colecciones. - Eliminaci\u00f3n de colecciones y sus implicaciones. - Comprobaci\u00f3n de existencia previa. - Operaciones de administraci\u00f3n desde el c\u00f3digo. e) Se han desarrollado aplicaciones para a\u00f1adir, modificar y eliminar documentos de la base de datos. - Inserci\u00f3n de documentos JSON/BSON. - Actualizaci\u00f3n completa y parcial (updateOne, updateMany). - Eliminaci\u00f3n de documentos (deleteOne, deleteMany). - Uso de data classes de Kotlin para representar documentos. - Serializaci\u00f3n y deserializaci\u00f3n de objetos.","title":"\ud83d\udd39 RA5. Desarrolla aplicaciones que gestionan la informaci\u00f3n almacenada en bases de datos documentales nativas evaluando y utilizando clases espec\u00edficas"},{"location":"firebase/Firebase/","text":"Introducci\u00f3n Firebase es un servicio de backend, es decir, del lado del servidor, que ofrece la posibilidad de guardar los datos de aplicaciones web y de dispositivos m\u00f3viles, con la particularidad de que los datos modificados por uno de los clientes conectados se pueden actualizar en tiempo real en todos los dem\u00e1s que est\u00e9n conectados. Ofrece una serie de servicios, entre los cuales podemos destacar: Firebase Auth \u2013 Autenticaci\u00f3n de usuarios: permite gestionar la validaci\u00f3n de usuarios de forma c\u00f3moda. Incluye autenticaci\u00f3n mediante Facebook, GitHub, Twitter y Google, as\u00ed como validaci\u00f3n utilizando una cuenta de correo, guardando la contrase\u00f1a en Firebase, lo que nos libera de tener que almacenarlas en nuestro propio dispositivo. Realtime Database \u2013 Base de Datos en Tiempo Real: permite guardar datos en la nube que estar\u00e1n sincronizados entre todas las aplicaciones (clientes) conectadas. En realidad, no es una base de datos propiamente dicha, sino un documento JSON. Cloud Firestore : es una evoluci\u00f3n de la anterior que s\u00ed permite guardar colecciones de documentos JSON, por lo que ya puede considerarse una base de datos completa. Firebase Storage : permite almacenar archivos para nuestras aplicaciones, como pueden ser audios, v\u00eddeos, im\u00e1genes, etc. En este tema nos centraremos sobre todo en el segundo y el tercer servicio, los de bases de datos. Debemos recordar que Realtime Database no es una base de datos completa: \u00fanicamente podemos guardar un documento JSON, aunque puede ser tan extenso como queramos. Se trata, por tanto, de una base de datos NoSQL, o m\u00e1s bien una mini base de datos NoSQL. Eso s\u00ed, permite sincronizar los datos en tiempo real en todos los dispositivos conectados. En cambio, Cloud Firestore s\u00ed es una base de datos completa.","title":"Introducci\u00f3n"},{"location":"firebase/Firebase/#introduccion","text":"Firebase es un servicio de backend, es decir, del lado del servidor, que ofrece la posibilidad de guardar los datos de aplicaciones web y de dispositivos m\u00f3viles, con la particularidad de que los datos modificados por uno de los clientes conectados se pueden actualizar en tiempo real en todos los dem\u00e1s que est\u00e9n conectados. Ofrece una serie de servicios, entre los cuales podemos destacar: Firebase Auth \u2013 Autenticaci\u00f3n de usuarios: permite gestionar la validaci\u00f3n de usuarios de forma c\u00f3moda. Incluye autenticaci\u00f3n mediante Facebook, GitHub, Twitter y Google, as\u00ed como validaci\u00f3n utilizando una cuenta de correo, guardando la contrase\u00f1a en Firebase, lo que nos libera de tener que almacenarlas en nuestro propio dispositivo. Realtime Database \u2013 Base de Datos en Tiempo Real: permite guardar datos en la nube que estar\u00e1n sincronizados entre todas las aplicaciones (clientes) conectadas. En realidad, no es una base de datos propiamente dicha, sino un documento JSON. Cloud Firestore : es una evoluci\u00f3n de la anterior que s\u00ed permite guardar colecciones de documentos JSON, por lo que ya puede considerarse una base de datos completa. Firebase Storage : permite almacenar archivos para nuestras aplicaciones, como pueden ser audios, v\u00eddeos, im\u00e1genes, etc. En este tema nos centraremos sobre todo en el segundo y el tercer servicio, los de bases de datos. Debemos recordar que Realtime Database no es una base de datos completa: \u00fanicamente podemos guardar un documento JSON, aunque puede ser tan extenso como queramos. Se trata, por tanto, de una base de datos NoSQL, o m\u00e1s bien una mini base de datos NoSQL. Eso s\u00ed, permite sincronizar los datos en tiempo real en todos los dispositivos conectados. En cambio, Cloud Firestore s\u00ed es una base de datos completa.","title":"Introducci\u00f3n"},{"location":"firebase/Firestore/","text":"","title":"Firestore"},{"location":"firebase/Realtime/","text":"Realtime Database (RD) Aunque el objetivo es utilizarlo desde nuestro entorno de programaci\u00f3n, siempre resulta \u00fatil manipular los datos directamente desde el propio entorno de Firebase. El siguiente v\u00eddeo corresponde a una versi\u00f3n anterior de Firebase, pero sigue siendo igualmente v\u00e1lido. El entorno que nos ofrece Firebase ser\u00e1 suficiente. Podremos visualizar los datos que hayamos introducido en todas nuestras aplicaciones, as\u00ed como editarlos, es decir: a\u00f1adir, modificar y eliminar. Recordemos que podemos utilizar dos versiones: Realtime Database Cloud Firestore \ud83d\udd39RD: Utilizaci\u00f3n desde el entorno de Firebase Haremos especial menci\u00f3n al hecho de que lo que guardamos es un documento JSON. Incluso podremos descargarlo (exportarlo) o subirlo (importarlo) como un documento. Eso s\u00ed, la operaci\u00f3n de importaci\u00f3n elimina los datos anteriores, lo que demuestra que solo podemos almacenar un \u00fanico documento JSON. Este es el contenido del archivo Empleats.json que se muestra en el v\u00eddeo. Est\u00e1 formateado para facilitar su lectura, aunque en realidad no importar\u00eda que todo estuviera en una sola l\u00ednea. Lo ten\u00e9is disponible en el aula virtual para que pod\u00e1is importarlo. { \"empresa\": { \"empleat\": [ { \"num\": 1, \"nom\": \"Andreu\", \"departament\": 10, \"edat\": 32, \"sou\": 1000 }, { \"num\": 2, \"nom\": \"Bernat\", \"departament\": 20, \"edat\": 28, \"sou\": 1200 }, { \"num\": 3, \"nom\": \"Cl\u00e0udia\", \"departament\": 10, \"edat\": 26, \"sou\": 1100 }, { \"num\": 4, \"nom\": \"Dami\u00e0\", \"departament\": 10, \"edat\": 40, \"sou\": 1500 } ] } } Ya hab\u00e9is visto que al importar Empleats.json se han perdido los dem\u00e1s datos. Volved a a\u00f1adir el par clave-valor a1 (por ejemplo, con el valor Hola), ya que, al ser una estructura muy sencilla, la utilizaremos en algunos ejemplos. De este modo, nos quedar\u00e1 la siguiente estructura para los ejemplos posteriores: \ud83d\udd39RD: Utilizaci\u00f3n desde IntelliJ Para los ejemplos y ejercicios de esta parte, crearemos un proyecto llamado Tema8, con los siguientes paquetes: exemples_realtimedatabase, exemples_cloudfirestore, exemples_cloudstorage y exercicis. \ud83d\udd39 RD-IntelliJ: Connexi\u00f3n des de Kotlin Configuraci\u00f3n Lo primero que debemos hacer es preparar nuestro proyecto para que pueda acceder a la aplicaci\u00f3n que hemos creado en Firebase. Desde el entorno de IntelliJ, descargaremos un archivo JSON que contiene la clave de acceso a nuestra aplicaci\u00f3n. Para obtenerlo, debemos ir a la configuraci\u00f3n del proyecto y, dentro de ella, acceder a la pesta\u00f1a Cuentas de servicio ( Service Accounts ). All\u00ed veremos varios ejemplos de uso (en nuestro caso nos interesa el de Java ) y, al final de la p\u00e1gina, encontraremos un bot\u00f3n para Generar una nueva clave privada . Se descargar\u00e1 un archivo JSON que deberemos guardar en la ra\u00edz del proyecto. Despu\u00e9s, tal como indica el ejemplo, a\u00f1adiremos el siguiente c\u00f3digo para garantizar un acceso correcto: val serviceAccount = FileInputStream(\"access-a-dades-d119e-firebase-adminsdk-ehn3k-14a46f56f4.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .setDatabaseUrl(\"https://access-a-dades-d119e-default-rtdb.firebaseio.com/\").build() FirebaseApp.initializeApp(options) Av\u00eds No os olvid\u00e9is de sustituir el nombre del archivo JSON . Tambi\u00e9n deb\u00e9is tener en cuenta que la URL de la base de datos ser\u00e1 diferente para cada uno de vosotros. El ejemplo est\u00e1 escrito en Java , por lo que tendremos que convertirlo a Kotlin . Quedar\u00e1 de la siguiente forma (yo lo he adaptado a mi proyecto, pero recordad cambiar el nombre del archivo JSON y la URL por los vuestros): val serviceAccount = FileInputStream(\"access-a-dades-d119e-firebase-adminsdk-ehn3k-14a46f56f4.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .setDatabaseUrl(\"https://access-a-dades-d119e-default-rtdb.firebaseio.com/\").build() FirebaseApp.initializeApp(options) Referencia a la Base de Datos y a los datos concretos a los que queremos acceder Debemos crear un objeto FirebaseDatabase , que ser\u00e1 una referencia a toda la Base de Datos : val database = FirebaseDatabase.getInstance() A partir de este objeto, podr\u00edamos hacer referencia a un par clave-valor que se encuentre en la ra\u00edz , como cuando hab\u00edamos creado a1 (aunque recordad que ahora ya no existe): val refA1 = database.getReference(\"a1\") Tambi\u00e9n podr\u00edamos hacer referencia a un par clave-valor que no se encuentre en la ra\u00edz de la base de datos. Simplemente indicar\u00edamos la ruta completa desde la ra\u00edz. Por ejemplo, para acceder al nombre del primer empleado de la empresa que tenemos guardado, lo har\u00edamos as\u00ed: val empleat1 = database.getReference(\"empresa/empleat/0/nom\") En els casos anteriors hem optat per agafar parelles clau-valor, b\u00e9 a l'arrel o m\u00e9s cap a dins de l'estructura JSON. Per\u00f2 en definitiva \u00e9s una parella clau- valor. Tamb\u00e9 podem optar per agafar l'estructura JSON i treballar amb ella, com vam fer en el Tema 3, quan vam treballar amb l'estructura JSON. val empresa = database.getReference(\"empresa\") De esta manera, al obtener toda la estructura, tendremos dos formas de trabajar posteriormente para acceder a niveles m\u00e1s profundos dentro de la base de datos: Convertirla en objetos y arrays JSON , y trabajar como hicimos en el Tema 3 . Es un m\u00e9todo muy c\u00f3modo, especialmente cuando se trata de operaciones de lectura . Trabajar directamente con los m\u00e9todos de Firebase , que nos permiten acceder tanto a todos los nodos hijos de una estructura como a un nodo hijo concreto . Mostraremos ambos enfoques en los ejemplos posteriores. \ud83d\udd39RD-IntelliJ: Acceso a los datos","title":"Realtime Database (RD)"},{"location":"firebase/Realtime/#realtime-database-rd","text":"Aunque el objetivo es utilizarlo desde nuestro entorno de programaci\u00f3n, siempre resulta \u00fatil manipular los datos directamente desde el propio entorno de Firebase. El siguiente v\u00eddeo corresponde a una versi\u00f3n anterior de Firebase, pero sigue siendo igualmente v\u00e1lido. El entorno que nos ofrece Firebase ser\u00e1 suficiente. Podremos visualizar los datos que hayamos introducido en todas nuestras aplicaciones, as\u00ed como editarlos, es decir: a\u00f1adir, modificar y eliminar. Recordemos que podemos utilizar dos versiones: Realtime Database Cloud Firestore","title":"Realtime Database (RD)"},{"location":"firebase/Realtime/#rd-utilizacion-desde-el-entorno-de-firebase","text":"Haremos especial menci\u00f3n al hecho de que lo que guardamos es un documento JSON. Incluso podremos descargarlo (exportarlo) o subirlo (importarlo) como un documento. Eso s\u00ed, la operaci\u00f3n de importaci\u00f3n elimina los datos anteriores, lo que demuestra que solo podemos almacenar un \u00fanico documento JSON. Este es el contenido del archivo Empleats.json que se muestra en el v\u00eddeo. Est\u00e1 formateado para facilitar su lectura, aunque en realidad no importar\u00eda que todo estuviera en una sola l\u00ednea. Lo ten\u00e9is disponible en el aula virtual para que pod\u00e1is importarlo. { \"empresa\": { \"empleat\": [ { \"num\": 1, \"nom\": \"Andreu\", \"departament\": 10, \"edat\": 32, \"sou\": 1000 }, { \"num\": 2, \"nom\": \"Bernat\", \"departament\": 20, \"edat\": 28, \"sou\": 1200 }, { \"num\": 3, \"nom\": \"Cl\u00e0udia\", \"departament\": 10, \"edat\": 26, \"sou\": 1100 }, { \"num\": 4, \"nom\": \"Dami\u00e0\", \"departament\": 10, \"edat\": 40, \"sou\": 1500 } ] } } Ya hab\u00e9is visto que al importar Empleats.json se han perdido los dem\u00e1s datos. Volved a a\u00f1adir el par clave-valor a1 (por ejemplo, con el valor Hola), ya que, al ser una estructura muy sencilla, la utilizaremos en algunos ejemplos. De este modo, nos quedar\u00e1 la siguiente estructura para los ejemplos posteriores:","title":"\ud83d\udd39RD: Utilizaci\u00f3n desde el entorno de Firebase"},{"location":"firebase/Realtime/#rd-utilizacion-desde-intellij","text":"Para los ejemplos y ejercicios de esta parte, crearemos un proyecto llamado Tema8, con los siguientes paquetes: exemples_realtimedatabase, exemples_cloudfirestore, exemples_cloudstorage y exercicis.","title":"\ud83d\udd39RD: Utilizaci\u00f3n desde IntelliJ"},{"location":"firebase/Realtime/#rd-intellij-connexion-des-de-kotlin","text":"Configuraci\u00f3n Lo primero que debemos hacer es preparar nuestro proyecto para que pueda acceder a la aplicaci\u00f3n que hemos creado en Firebase. Desde el entorno de IntelliJ, descargaremos un archivo JSON que contiene la clave de acceso a nuestra aplicaci\u00f3n. Para obtenerlo, debemos ir a la configuraci\u00f3n del proyecto y, dentro de ella, acceder a la pesta\u00f1a Cuentas de servicio ( Service Accounts ). All\u00ed veremos varios ejemplos de uso (en nuestro caso nos interesa el de Java ) y, al final de la p\u00e1gina, encontraremos un bot\u00f3n para Generar una nueva clave privada . Se descargar\u00e1 un archivo JSON que deberemos guardar en la ra\u00edz del proyecto. Despu\u00e9s, tal como indica el ejemplo, a\u00f1adiremos el siguiente c\u00f3digo para garantizar un acceso correcto: val serviceAccount = FileInputStream(\"access-a-dades-d119e-firebase-adminsdk-ehn3k-14a46f56f4.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .setDatabaseUrl(\"https://access-a-dades-d119e-default-rtdb.firebaseio.com/\").build() FirebaseApp.initializeApp(options) Av\u00eds No os olvid\u00e9is de sustituir el nombre del archivo JSON . Tambi\u00e9n deb\u00e9is tener en cuenta que la URL de la base de datos ser\u00e1 diferente para cada uno de vosotros. El ejemplo est\u00e1 escrito en Java , por lo que tendremos que convertirlo a Kotlin . Quedar\u00e1 de la siguiente forma (yo lo he adaptado a mi proyecto, pero recordad cambiar el nombre del archivo JSON y la URL por los vuestros): val serviceAccount = FileInputStream(\"access-a-dades-d119e-firebase-adminsdk-ehn3k-14a46f56f4.json\") val options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(serviceAccount)) .setDatabaseUrl(\"https://access-a-dades-d119e-default-rtdb.firebaseio.com/\").build() FirebaseApp.initializeApp(options) Referencia a la Base de Datos y a los datos concretos a los que queremos acceder Debemos crear un objeto FirebaseDatabase , que ser\u00e1 una referencia a toda la Base de Datos : val database = FirebaseDatabase.getInstance() A partir de este objeto, podr\u00edamos hacer referencia a un par clave-valor que se encuentre en la ra\u00edz , como cuando hab\u00edamos creado a1 (aunque recordad que ahora ya no existe): val refA1 = database.getReference(\"a1\") Tambi\u00e9n podr\u00edamos hacer referencia a un par clave-valor que no se encuentre en la ra\u00edz de la base de datos. Simplemente indicar\u00edamos la ruta completa desde la ra\u00edz. Por ejemplo, para acceder al nombre del primer empleado de la empresa que tenemos guardado, lo har\u00edamos as\u00ed: val empleat1 = database.getReference(\"empresa/empleat/0/nom\") En els casos anteriors hem optat per agafar parelles clau-valor, b\u00e9 a l'arrel o m\u00e9s cap a dins de l'estructura JSON. Per\u00f2 en definitiva \u00e9s una parella clau- valor. Tamb\u00e9 podem optar per agafar l'estructura JSON i treballar amb ella, com vam fer en el Tema 3, quan vam treballar amb l'estructura JSON. val empresa = database.getReference(\"empresa\") De esta manera, al obtener toda la estructura, tendremos dos formas de trabajar posteriormente para acceder a niveles m\u00e1s profundos dentro de la base de datos: Convertirla en objetos y arrays JSON , y trabajar como hicimos en el Tema 3 . Es un m\u00e9todo muy c\u00f3modo, especialmente cuando se trata de operaciones de lectura . Trabajar directamente con los m\u00e9todos de Firebase , que nos permiten acceder tanto a todos los nodos hijos de una estructura como a un nodo hijo concreto . Mostraremos ambos enfoques en los ejemplos posteriores.","title":"\ud83d\udd39 RD-IntelliJ: Connexi\u00f3n des de Kotlin"},{"location":"firebase/Realtime/#rd-intellij-acceso-a-los-datos","text":"","title":"\ud83d\udd39RD-IntelliJ: Acceso a los datos"},{"location":"firebase/aplicacion/","text":"Crear una aplicaci\u00f3n La base de datos \u2014que, como hemos visto, puede ser un \u00fanico documento JSON en el caso de Realtime Database, o un conjunto completo en el caso de Cloud Firestore\u2014 est\u00e1 asociada a una aplicaci\u00f3n. Crearemos una nueva aplicaci\u00f3n desde el entorno de Firebase, y ser\u00e1 la referencia de esa aplicaci\u00f3n la que utilizaremos en nuestra aplicaci\u00f3n web o aplicaci\u00f3n m\u00f3vil. De este modo, podemos crear varias aplicaciones de Firebase, y en cada una de ellas almacenar una base de datos diferente. Para ello, ser\u00e1 necesario autenticarnos con una cuenta de Google. El proceso de creaci\u00f3n se realiza desde el entorno de Firebase: www.firebase.com . El siguiente v\u00eddeo muestra el proceso de creaci\u00f3n de una aplicaci\u00f3n: Reglas de seguridad Inicialmente elegiremos la opci\u00f3n modo de prueba, en la cual todo el mundo puede acceder a los datos. Evidentemente, no se deben dejar estas reglas de forma definitiva, pero para empezar a realizar pruebas est\u00e1 bien. De hecho, en la \u00faltima versi\u00f3n se mantiene el modo de prueba durante un mes. En cualquier caso, si quisi\u00e9ramos ampliarlo, podr\u00edamos hacerlo desde la configuraci\u00f3n de las rules (reglas). \ud83d\udd39Acceso desde IntelliJ Veremos el acceso desde IntelliJ, que es el entorno que utilizamos en el presente m\u00f3dulo. Para desarrollar una aplicaci\u00f3n en IntelliJ con Kotlin que acceda a Firebase, una forma bastante sencilla es utilizar Maven para gestionar las dependencias necesarias. A continuaci\u00f3n, se indican los pasos y las dependencias que deben a\u00f1adirse al archivo pom.xml : a) Repositori Maven de Google : Algunas dependencias de Firebase pueden no estar disponibles en el repositorio Maven Central. Aseguraos de a\u00f1adir tambi\u00e9n el repositorio de Google para que puedan resolverse correctamente. <repositories> <repository> <id>google</id> <url>https://maven.google.com/</url> </repository> </repositories> b) A\u00f1ade Firebase Admin SDK .El Admin SDK es la biblioteca principal que permite interactuar con los servicios de Firebase, como Realtime Database, Cloud Firestore, Authentication, entre otros. <dependency> <groupId>com.google.firebase</groupId> <artifactId>firebase-admin</artifactId> <version>9.1.1</version> </dependency> c) Servicios Adicionales Si necesitas interactuar con servicios espec\u00edficos, como Firestore o Realtime Database, aqu\u00ed tienes las dependencias correspondientes: Cloud Firestore <dependency> <groupId>com.google.cloud</groupId> <artifactId>google-cloud-firestore</artifactId> <version>3.15.0</version> </dependency> <dependency> <groupId>com.google.auth</groupId> <artifactId>google-auth-library-oauth2-http</artifactId> <version>1.27.0</version> </dependency> Realtime Database La funcionalidad de Realtime Database est\u00e1 incluida en el Admin SDK, por lo que no es necesario a\u00f1adir dependencias adicionales. Simplemente utiliza las clases que proporciona firebase-admin . Nota Haz clic en Reload Maven Project para asegurarte de que todas las dependencias se descargan correctamente.","title":"Crear una aplicaci\u00f3n"},{"location":"firebase/aplicacion/#crear-una-aplicacion","text":"La base de datos \u2014que, como hemos visto, puede ser un \u00fanico documento JSON en el caso de Realtime Database, o un conjunto completo en el caso de Cloud Firestore\u2014 est\u00e1 asociada a una aplicaci\u00f3n. Crearemos una nueva aplicaci\u00f3n desde el entorno de Firebase, y ser\u00e1 la referencia de esa aplicaci\u00f3n la que utilizaremos en nuestra aplicaci\u00f3n web o aplicaci\u00f3n m\u00f3vil. De este modo, podemos crear varias aplicaciones de Firebase, y en cada una de ellas almacenar una base de datos diferente. Para ello, ser\u00e1 necesario autenticarnos con una cuenta de Google. El proceso de creaci\u00f3n se realiza desde el entorno de Firebase: www.firebase.com . El siguiente v\u00eddeo muestra el proceso de creaci\u00f3n de una aplicaci\u00f3n: Reglas de seguridad Inicialmente elegiremos la opci\u00f3n modo de prueba, en la cual todo el mundo puede acceder a los datos. Evidentemente, no se deben dejar estas reglas de forma definitiva, pero para empezar a realizar pruebas est\u00e1 bien. De hecho, en la \u00faltima versi\u00f3n se mantiene el modo de prueba durante un mes. En cualquier caso, si quisi\u00e9ramos ampliarlo, podr\u00edamos hacerlo desde la configuraci\u00f3n de las rules (reglas).","title":"Crear una aplicaci\u00f3n"},{"location":"firebase/aplicacion/#acceso-desde-intellij","text":"Veremos el acceso desde IntelliJ, que es el entorno que utilizamos en el presente m\u00f3dulo. Para desarrollar una aplicaci\u00f3n en IntelliJ con Kotlin que acceda a Firebase, una forma bastante sencilla es utilizar Maven para gestionar las dependencias necesarias. A continuaci\u00f3n, se indican los pasos y las dependencias que deben a\u00f1adirse al archivo pom.xml : a) Repositori Maven de Google : Algunas dependencias de Firebase pueden no estar disponibles en el repositorio Maven Central. Aseguraos de a\u00f1adir tambi\u00e9n el repositorio de Google para que puedan resolverse correctamente. <repositories> <repository> <id>google</id> <url>https://maven.google.com/</url> </repository> </repositories> b) A\u00f1ade Firebase Admin SDK .El Admin SDK es la biblioteca principal que permite interactuar con los servicios de Firebase, como Realtime Database, Cloud Firestore, Authentication, entre otros. <dependency> <groupId>com.google.firebase</groupId> <artifactId>firebase-admin</artifactId> <version>9.1.1</version> </dependency> c) Servicios Adicionales Si necesitas interactuar con servicios espec\u00edficos, como Firestore o Realtime Database, aqu\u00ed tienes las dependencias correspondientes: Cloud Firestore <dependency> <groupId>com.google.cloud</groupId> <artifactId>google-cloud-firestore</artifactId> <version>3.15.0</version> </dependency> <dependency> <groupId>com.google.auth</groupId> <artifactId>google-auth-library-oauth2-http</artifactId> <version>1.27.0</version> </dependency> Realtime Database La funcionalidad de Realtime Database est\u00e1 incluida en el Admin SDK, por lo que no es necesario a\u00f1adir dependencias adicionales. Simplemente utiliza las clases que proporciona firebase-admin . Nota Haz clic en Reload Maven Project para asegurarte de que todas las dependencias se descargan correctamente.","title":"\ud83d\udd39Acceso desde IntelliJ"},{"location":"mongo/Ejercicio/","text":"\ud83d\udcdd Ejercicio: Mi base de datos MongoDB en Kotlin \ud83d\udee0\ufe0f Requisitos 1. Base de Datos En este ejercicio vas a crear tu propia base de datos MongoDB, cuyo nombre debe seguir el formato: bd_tunombreprimerapellido . Por ejemplo, si te llamas Maria P\u00e9rez, tu base de datos se llamar\u00e1 bd_mariaperez . 2. Opeaciones en Kotlin Trabajar\u00e1s con Kotlin y KMongo para realizar operaciones CRUD (crear, leer, actualizar y eliminar) y una consulta avanzada utilizando el m\u00e9todo aggregate() . Crea tambi\u00e9n una colecci\u00f3n principal. Puedes elegir el tema que m\u00e1s te guste, por ejemplo: productos, libros, peliculas, alumnos, clientes... Implementa en tu programa las siguientes operaciones: Insertar varios documentos en la colecci\u00f3n. Mostrar todos los documentos almacenados. Actualizar alg\u00fan campo de un documento (por ejemplo, el precio o el stock). Encontrar documentos seg\u00fan criterios de b\u00fasqueda. Eliminar uno o varios documentos seg\u00fan un criterio. 3. B\u00fasqueda avanzada con aggregate() Crea una consulta con agregaci\u00f3n que muestre informaci\u00f3n resumida de tus datos. Algunas ideas: Agrupar productos por categor\u00eda y calcular el precio medio. Contar cu\u00e1ntos productos hay por tipo. Mostrar los productos con precio superior a la media. \ud83d\udce9 Entrega Sube un archivo .zip con: El proyecto completo. Un archivo README.md donde expliques: El nombre de tu base de datos. Qu\u00e9 colecci\u00f3n has elegido. Qu\u00e9 operaciones CRUD has implementado. Qu\u00e9 hace tu consulta con aggregate() y qu\u00e9 resultado devuelve. \u2705 R\u00fabrica de evaluaci\u00f3n Criterio Puntuaci\u00f3n Base de datos 2 Operaciones CRUD 3 Agregaci\u00f3n 2 C\u00f3digo y documentaci\u00f3n 2 Control de errores 1 Puntuaci\u00f3n total 10","title":"\ud83d\udcddEjercicio obligatorio 1"},{"location":"mongo/Ejercicio/#ejercicio-mi-base-de-datos-mongodb-en-kotlin","text":"","title":"\ud83d\udcdd Ejercicio: Mi base de datos MongoDB en Kotlin"},{"location":"mongo/Ejercicio/#requisitos","text":"","title":"\ud83d\udee0\ufe0f Requisitos"},{"location":"mongo/Ejercicio/#1-base-de-datos","text":"En este ejercicio vas a crear tu propia base de datos MongoDB, cuyo nombre debe seguir el formato: bd_tunombreprimerapellido . Por ejemplo, si te llamas Maria P\u00e9rez, tu base de datos se llamar\u00e1 bd_mariaperez .","title":"1. Base de Datos"},{"location":"mongo/Ejercicio/#2-opeaciones-en-kotlin","text":"Trabajar\u00e1s con Kotlin y KMongo para realizar operaciones CRUD (crear, leer, actualizar y eliminar) y una consulta avanzada utilizando el m\u00e9todo aggregate() . Crea tambi\u00e9n una colecci\u00f3n principal. Puedes elegir el tema que m\u00e1s te guste, por ejemplo: productos, libros, peliculas, alumnos, clientes... Implementa en tu programa las siguientes operaciones: Insertar varios documentos en la colecci\u00f3n. Mostrar todos los documentos almacenados. Actualizar alg\u00fan campo de un documento (por ejemplo, el precio o el stock). Encontrar documentos seg\u00fan criterios de b\u00fasqueda. Eliminar uno o varios documentos seg\u00fan un criterio.","title":"2. Opeaciones en Kotlin"},{"location":"mongo/Ejercicio/#3-busqueda-avanzada-con-aggregate","text":"Crea una consulta con agregaci\u00f3n que muestre informaci\u00f3n resumida de tus datos. Algunas ideas: Agrupar productos por categor\u00eda y calcular el precio medio. Contar cu\u00e1ntos productos hay por tipo. Mostrar los productos con precio superior a la media.","title":"3. B\u00fasqueda avanzada con aggregate()"},{"location":"mongo/Ejercicio/#entrega","text":"Sube un archivo .zip con: El proyecto completo. Un archivo README.md donde expliques: El nombre de tu base de datos. Qu\u00e9 colecci\u00f3n has elegido. Qu\u00e9 operaciones CRUD has implementado. Qu\u00e9 hace tu consulta con aggregate() y qu\u00e9 resultado devuelve.","title":"\ud83d\udce9 Entrega"},{"location":"mongo/Ejercicio/#rubrica-de-evaluacion","text":"Criterio Puntuaci\u00f3n Base de datos 2 Operaciones CRUD 3 Agregaci\u00f3n 2 C\u00f3digo y documentaci\u00f3n 2 Control de errores 1 Puntuaci\u00f3n total 10","title":"\u2705 R\u00fabrica de evaluaci\u00f3n"},{"location":"mongo/Ejercicio2/","text":"\ud83d\udcdd Ejercicio: Mi base de datos MongoDB con referencias y agregaciones (tema libre) \ud83d\udee0\ufe0f Requisitos 1. Base de Datos En este ejercicio vas a crear tu propia base de datos MongoDB, cuyo nombre debe seguir el formato: bd_tunombreprimerapellido . Por ejemplo, si te llamas Maria P\u00e9rez, tu base de datos se llamar\u00e1 bd_mariaperez. 2. Modelo con varias colecciones (tema libre) Debes crear al menos 3 colecciones relacionadas mediante referencias . La tem\u00e1tica es libre . Requisitos del modelo: Debe haber relaciones 1:N y/o N:M usando referencias (no embedding masivo). Puedes usar IDs l\u00f3gicos (ej.: \"prod-laptop\" ) o ObjectId . Cada colecci\u00f3n debe cargarse desde su archivo JSON . 3. Operaciones en Kotlin Trabajar\u00e1s con Kotlin + KMongo (y Jackson para leer JSON) para implementar: Insertar varios documentos en una colecci\u00f3n. Mostrar todos los documentos almacenados. Actualizar alg\u00fan campo de un documento. Buscar documentos seg\u00fan un criterio. Eliminar uno o varios documentos seg\u00fan condici\u00f3n. Cargar datos desde JSON para todas tus colecciones. Verificar datos en mongosh . 4. B\u00fasquedas avanzadas con aggregate() Debes crear dos consultas de agregaci\u00f3n : \ud83d\udd39 A) Join multinivel con referencias Usa $lookup y $unwind para combinar colecciones. \ud83d\udd39 B) Agregaci\u00f3n en una sola colecci\u00f3n Ejemplos: - Estad\u00edsticas por categor\u00eda - Documentos por a\u00f1o - Media de duraci\u00f3n/precio/puntuaci\u00f3n por grupo Debe contener al menos un \\$group y un \\$sort . \ud83d\udce9 Entrega Sube un archivo .zip con: El proyecto completo de IntelliJ Archivos JSON Archivo README.md donde expliques: Nombre de tu base de datos Tem\u00e1tica elegida Colecciones y sus referencias Qu\u00e9 operaciones CRUD has implementado Qu\u00e9 hace cada pipeline de agregaci\u00f3n. Ejemplos de resultados en consola Capturas de verificaci\u00f3n desde mongosh \u2705 R\u00fabrica de evaluaci\u00f3n Criterio Puntos Base de datos y modelo (3 colecciones con referencias) 2 Carga desde JSON 1 Operaciones CRUD en Kotlin 2 Agregaciones con referencias ( lookup + unwind ) 3 Agregaci\u00f3n en una sola colecci\u00f3n 1 C\u00f3digo y documentaci\u00f3n (README, claridad, salidas) 1 Total 10 puntos","title":"\ud83d\udcddEjercicio obligatorio 2"},{"location":"mongo/Ejercicio2/#ejercicio-mi-base-de-datos-mongodb-con-referencias-y-agregaciones-tema-libre","text":"","title":"\ud83d\udcdd Ejercicio: Mi base de datos MongoDB con referencias y agregaciones (tema libre)"},{"location":"mongo/Ejercicio2/#requisitos","text":"","title":"\ud83d\udee0\ufe0f Requisitos"},{"location":"mongo/Ejercicio2/#1-base-de-datos","text":"En este ejercicio vas a crear tu propia base de datos MongoDB, cuyo nombre debe seguir el formato: bd_tunombreprimerapellido . Por ejemplo, si te llamas Maria P\u00e9rez, tu base de datos se llamar\u00e1 bd_mariaperez.","title":"1. Base de Datos"},{"location":"mongo/Ejercicio2/#2-modelo-con-varias-colecciones-tema-libre","text":"Debes crear al menos 3 colecciones relacionadas mediante referencias . La tem\u00e1tica es libre .","title":"2. Modelo con varias colecciones (tema libre)"},{"location":"mongo/Ejercicio2/#requisitos-del-modelo","text":"Debe haber relaciones 1:N y/o N:M usando referencias (no embedding masivo). Puedes usar IDs l\u00f3gicos (ej.: \"prod-laptop\" ) o ObjectId . Cada colecci\u00f3n debe cargarse desde su archivo JSON .","title":"Requisitos del modelo:"},{"location":"mongo/Ejercicio2/#3-operaciones-en-kotlin","text":"Trabajar\u00e1s con Kotlin + KMongo (y Jackson para leer JSON) para implementar: Insertar varios documentos en una colecci\u00f3n. Mostrar todos los documentos almacenados. Actualizar alg\u00fan campo de un documento. Buscar documentos seg\u00fan un criterio. Eliminar uno o varios documentos seg\u00fan condici\u00f3n. Cargar datos desde JSON para todas tus colecciones. Verificar datos en mongosh .","title":"3. Operaciones en Kotlin"},{"location":"mongo/Ejercicio2/#4-busquedas-avanzadas-con-aggregate","text":"Debes crear dos consultas de agregaci\u00f3n :","title":"4. B\u00fasquedas avanzadas con aggregate()"},{"location":"mongo/Ejercicio2/#a-join-multinivel-con-referencias","text":"Usa $lookup y $unwind para combinar colecciones.","title":"\ud83d\udd39 A) Join multinivel con referencias"},{"location":"mongo/Ejercicio2/#b-agregacion-en-una-sola-coleccion","text":"Ejemplos: - Estad\u00edsticas por categor\u00eda - Documentos por a\u00f1o - Media de duraci\u00f3n/precio/puntuaci\u00f3n por grupo Debe contener al menos un \\$group y un \\$sort .","title":"\ud83d\udd39 B) Agregaci\u00f3n en una sola colecci\u00f3n"},{"location":"mongo/Ejercicio2/#entrega","text":"Sube un archivo .zip con: El proyecto completo de IntelliJ Archivos JSON Archivo README.md donde expliques: Nombre de tu base de datos Tem\u00e1tica elegida Colecciones y sus referencias Qu\u00e9 operaciones CRUD has implementado Qu\u00e9 hace cada pipeline de agregaci\u00f3n. Ejemplos de resultados en consola Capturas de verificaci\u00f3n desde mongosh","title":"\ud83d\udce9 Entrega"},{"location":"mongo/Ejercicio2/#rubrica-de-evaluacion","text":"Criterio Puntos Base de datos y modelo (3 colecciones con referencias) 2 Carga desde JSON 1 Operaciones CRUD en Kotlin 2 Agregaciones con referencias ( lookup + unwind ) 3 Agregaci\u00f3n en una sola colecci\u00f3n 1 C\u00f3digo y documentaci\u00f3n (README, claridad, salidas) 1 Total 10 puntos","title":"\u2705 R\u00fabrica de evaluaci\u00f3n"},{"location":"mongo/Mongo/","text":"MongoDB \ud83d\udcda MongoDB es un sistema de gesti\u00f3n de bases de datos NoSQL orientado a documentos . A diferencia de las bases de datos relacionales, que almacenan la informaci\u00f3n en tablas con filas y columnas, MongoDB guarda los datos en colecciones formadas por documentos en formato BSON (una representaci\u00f3n binaria de JSON). Cada documento es una estructura flexible , parecida a un objeto de programaci\u00f3n, donde los datos se organizan en pares clave\u2013valor . Esta flexibilidad permite que cada documento tenga una estructura diferente, lo que hace que MongoDB se adapte f\u00e1cilmente a los cambios en los datos sin necesidad de modificar esquemas. \ud83d\udcc2 Estructura b\u00e1sica Concepto Equivalente en BD relacional Descripci\u00f3n Base de datos Base de datos Conjunto de colecciones. Colecci\u00f3n Tabla Agrupaci\u00f3n de documentos relacionados. Documento Fila (registro) Unidad b\u00e1sica de almacenamiento. Es un objeto JSON. Campo Columna Atributo dentro del documento. Ejemplo de estructura flexible Veamos algunos ejemplos de documentos JSON para guardar la informaci\u00f3n de libros y autores . Dependiendo de c\u00f3mo se deba acceder a la informaci\u00f3n, podemos plantearnos guardar los libros con sus autores, o guardar los autores con sus libros. Incluso podr\u00edamos guardar ambas versiones, para poder acceder a los datos de todas las formas posibles, aunque eso implique duplicar la informaci\u00f3n. De la primera manera, guardando los libros junto con su autor, podr\u00edamos tener documentos con esta estructura, que se podr\u00edan guardar en una colecci\u00f3n llamada Libros : { _id:101, titol:\"El secret de Khadrell\", autor: { nom:\"Pep\", cognoms:\"Castellano Puchol\", any_naixement:1960 }, isbn:\"84-95620-72-3\" }, { _id:102, titol:\"L'Ombra del Vent\", autor: { nom:\"Carlos\", cognoms:\"Ruiz Zafon\", pais:\"Espanya\" }, pagines:490, editorial:\"Planeta\" } Observa c\u00f3mo los objetos no tienen por qu\u00e9 tener la misma estructura. La forma de acceder al nombre de un autor ser\u00eda la siguiente: objeto.autor.nombre Una manera alternativa de guardar la informaci\u00f3n, como hab\u00edamos comentado antes, ser\u00eda organizarla por autores, junto con sus libros. De este modo, podr\u00edamos ir completando la colecci\u00f3n Autores con uno o m\u00e1s documentos de este estilo: { _id: 201, nom:\"Pep\", cognoms:\"Castellano Puchol\", any_naixement:1960, llibres: [ { titol:\"El secret de Khadrell\", isbn:\"84-95620-72-3\" }, { titol:\"Habitaci\u00f3 502\", editorial:\"Tabarca\" } ] }, { _id:202, nom:\"Carlos\", cognoms:\"Ruiz Zafon\", pais:\"Espanya\", llibres: [ { titol:\"L'Ombra del Vent\", pagines:490, editorial:\"Planeta\" } ] } Observa c\u00f3mo, para un autor, ahora tenemos un array (los corchetes: [ ]) con sus libros. \u00bfCu\u00e1l de las dos formas es mejor para guardar la informaci\u00f3n? Pues depende del tipo de acceso que se vaya a realizar a los datos. La mejor opci\u00f3n ser\u00e1 probablemente aquella que, seg\u00fan las consultas que se necesiten hacer, devuelva la informaci\u00f3n de forma m\u00e1s r\u00e1pida.","title":"\ud83d\udd39Introducci\u00f3n"},{"location":"mongo/Mongo/#mongodb","text":"\ud83d\udcda MongoDB es un sistema de gesti\u00f3n de bases de datos NoSQL orientado a documentos . A diferencia de las bases de datos relacionales, que almacenan la informaci\u00f3n en tablas con filas y columnas, MongoDB guarda los datos en colecciones formadas por documentos en formato BSON (una representaci\u00f3n binaria de JSON). Cada documento es una estructura flexible , parecida a un objeto de programaci\u00f3n, donde los datos se organizan en pares clave\u2013valor . Esta flexibilidad permite que cada documento tenga una estructura diferente, lo que hace que MongoDB se adapte f\u00e1cilmente a los cambios en los datos sin necesidad de modificar esquemas. \ud83d\udcc2 Estructura b\u00e1sica Concepto Equivalente en BD relacional Descripci\u00f3n Base de datos Base de datos Conjunto de colecciones. Colecci\u00f3n Tabla Agrupaci\u00f3n de documentos relacionados. Documento Fila (registro) Unidad b\u00e1sica de almacenamiento. Es un objeto JSON. Campo Columna Atributo dentro del documento. Ejemplo de estructura flexible Veamos algunos ejemplos de documentos JSON para guardar la informaci\u00f3n de libros y autores . Dependiendo de c\u00f3mo se deba acceder a la informaci\u00f3n, podemos plantearnos guardar los libros con sus autores, o guardar los autores con sus libros. Incluso podr\u00edamos guardar ambas versiones, para poder acceder a los datos de todas las formas posibles, aunque eso implique duplicar la informaci\u00f3n. De la primera manera, guardando los libros junto con su autor, podr\u00edamos tener documentos con esta estructura, que se podr\u00edan guardar en una colecci\u00f3n llamada Libros : { _id:101, titol:\"El secret de Khadrell\", autor: { nom:\"Pep\", cognoms:\"Castellano Puchol\", any_naixement:1960 }, isbn:\"84-95620-72-3\" }, { _id:102, titol:\"L'Ombra del Vent\", autor: { nom:\"Carlos\", cognoms:\"Ruiz Zafon\", pais:\"Espanya\" }, pagines:490, editorial:\"Planeta\" } Observa c\u00f3mo los objetos no tienen por qu\u00e9 tener la misma estructura. La forma de acceder al nombre de un autor ser\u00eda la siguiente: objeto.autor.nombre Una manera alternativa de guardar la informaci\u00f3n, como hab\u00edamos comentado antes, ser\u00eda organizarla por autores, junto con sus libros. De este modo, podr\u00edamos ir completando la colecci\u00f3n Autores con uno o m\u00e1s documentos de este estilo: { _id: 201, nom:\"Pep\", cognoms:\"Castellano Puchol\", any_naixement:1960, llibres: [ { titol:\"El secret de Khadrell\", isbn:\"84-95620-72-3\" }, { titol:\"Habitaci\u00f3 502\", editorial:\"Tabarca\" } ] }, { _id:202, nom:\"Carlos\", cognoms:\"Ruiz Zafon\", pais:\"Espanya\", llibres: [ { titol:\"L'Ombra del Vent\", pagines:490, editorial:\"Planeta\" } ] } Observa c\u00f3mo, para un autor, ahora tenemos un array (los corchetes: [ ]) con sus libros. \u00bfCu\u00e1l de las dos formas es mejor para guardar la informaci\u00f3n? Pues depende del tipo de acceso que se vaya a realizar a los datos. La mejor opci\u00f3n ser\u00e1 probablemente aquella que, seg\u00fan las consultas que se necesiten hacer, devuelva la informaci\u00f3n de forma m\u00e1s r\u00e1pida.","title":"MongoDB"},{"location":"mongo/colecciones/","text":"\ud83d\udd39Colecciones En los ejemplos vistos hasta ahora hemos trabajado con una \u00fanica colecci\u00f3n formada por varios documentos. En bases de datos NoSQL, como MongoDB, es habitual trabajar con varias colecciones para organizar los datos de forma l\u00f3gica. Aunque NoSQL no soporta joins como SQL, existen estrategias para relacionar colecciones: 1\ufe0f\u20e3 Referencias : En este enfoque, los documentos almacenan solo referencias (IDs) de documentos en otras colecciones . Se usa cuando los datos son reutilizados en m\u00faltiples documentos o crecen mucho en tama\u00f1o. Ejemplo : Cliente y Pedidos en colecciones separadas con referencia Colecci\u00f3n clientes { \"_id\": 1, \"nombre\": \"Juan\", \"email\": \"juan@email.com\", } Colecci\u00f3n pedidos En cada pedido guardamos en el campo cliente_id del cliente. [ { \"_id\": 101, \"cliente_id\": 1, \"producto\": \"Laptop\", \"total\": 1200 }, { \"_id\": 102, \"cliente_id\": 1, \"producto\": \"Mouse\", \"total\": 25 } ] 2\ufe0f\u20e3 Embebido : Este enfoque anida los datos relacionados dentro del mismo documento . Se usa cuando los datos relacionados se consultan frecuentemente juntos y no crecen demasiado en tama\u00f1o. Ejemplo : Cliente con sus Pedidos embebidos { \"_id\": 1, \"nombre\": \"Juan\", \"email\": \"juan@email.com\", \"pedidos\": [ { \"producto\": \"Laptop\", \"total\": 1200 }, { \"producto\": \"Mouse\", \"total\": 25 } ] } \ud83d\udd39 Relaciones en MongoDB Aunque MongoDB no es relacional, $lookup permite combinar datos como si fuera una base de datos relacional (tipo SQL), pero usando su sistema de agregaci\u00f3n. El operador $lookup se utiliza en MongoDB para realizar un join entre dos colecciones, es decir, para relacionar documentos de diferentes colecciones usando un campo com\u00fan. Es \u00fatil cuando seguimos un enfoque de referencias , donde almacenamos solo el ObjectId en lugar de los documentos embebidos. Sintaxis { $lookup: { from: <collection_to_join>, localField: <field_from_the_input_documents>, foreignField: <field_from_collection>, as: <output_array_field> } } Ejemplo 1 : Relacionar la coleci\u00f3n Clientes con sus Pedidos Colecci\u00f3n clientes [ { \"_id\": 1, \"nombre\": \"Carlos\", \"email\": \"carlos@example.com\" }, { \"_id\": 2, \"nombre\": \"Ana\", \"email\": \"ana@example.com\" } ] Colecci\u00f3n pedidos [ { \"_id\": 101, \"cliente_id\": 1, \"producto\": \"Laptop\", \"precio\": 1200 }, { \"_id\": 102, \"cliente_id\": 1, \"producto\": \"Mouse\", \"precio\": 50 }, { \"_id\": 103, \"cliente_id\": 2, \"producto\": \"Teclado\", \"precio\": 80 } ] Consulta con $lookup para unir clientes con sus pedidos db.clientes.aggregate([ { \"$lookup\": { \"from\": \"pedidos\", // Colecci\u00f3n a unir \"localField\": \"_id\", // Campo en la colecci\u00f3n actual (clientes) \"foreignField\": \"cliente_id\", // Campo en la otra colecci\u00f3n (pedidos) \"as\": \"pedidos\" // Nombre del campo de salida con los pedidos } } ]) Resultado esperado [ { \"_id\": 1, \"nombre\": \"Carlos\", \"email\": \"carlos@example.com\", \"pedidos\": [ { \"_id\": 101, \"cliente_id\": 1, \"producto\": \"Laptop\", \"precio\": 1200 }, { \"_id\": 102, \"cliente_id\": 1, \"producto\": \"Mouse\", \"precio\": 50 } ] }, { \"_id\": 2, \"nombre\": \"Ana\", \"email\": \"ana@example.com\", \"pedidos\": [ { \"_id\": 103, \"cliente_id\": 2, \"producto\": \"Teclado\", \"precio\": 80 } ] } ] Ejemplo 2 : Realcionar la colecci\u00f3n autores con sus libros. // Colecciones db.createCollection(\"authors\"); db.createCollection(\"books\"); // 1) Insertar autor con _id(string) db.authors.insertOne({ _id: \"diego\", name: \"Diego Cort\u00e9s\", email: \"dcortes@example.com\", age: 25 }); // 2) Insertar libros referenciando el _id del autor db.books.insertMany([ { _id: \"book-philosopher-stone\", name: \"Philosopher's Stone\", author_id: \"diego\" // \u2190 referencia }, { _id: \"book-secret-programming\", name: \"Secret of programming\", author_id: \"diego\" // \u2190 referencia } ]); // 3) JOIN con $lookup (authors \u2192 books) db.getCollection(\"authors\").aggregate([ { $lookup: { from: \"books\", localField: \"_id\", // \"diego\" foreignField: \"author_id\", as: \"books\" } } ]); Resultado esperado [ { _id: 'diego', name: 'Diego Cort\u00e9s', email: 'dcortes@example.com', age: 25, books: [ { _id: 'book-philosopher-stone', name: \"Philosopher's Stone\", author_id: 'diego' }, { _id: 'book-secret-programming', name: 'Secret of programming', author_id: 'diego' } ] } ] \ud83d\udd39 $lookup anidado Siguiendo con el ejemplo de clientes y sus pedidos, si cada pedido tiene detalles en una tercera colecci\u00f3n detalles_pedido , podemos anidar otro $lookup: Ejemplo : Relacionar clientes con pedidos y detalles_pedido Colecci\u00f3n clientes [ { \"_id\": 1, \"nombre\": \"Carlos\", \"email\": \"carlos@example.com\" }, { \"_id\": 2, \"nombre\": \"Ana\", \"email\": \"ana@example.com\" } ] Colecci\u00f3n pedidos [ { \"_id\": 101, \"cliente_id\": 1, \"producto\": \"Laptop\", \"precio\": 1200 }, { \"_id\": 102, \"cliente_id\": 1, \"producto\": \"Mouse\", \"precio\": 50 }, { \"_id\": 103, \"cliente_id\": 2, \"producto\": \"Teclado\", \"precio\": 80 } ] Colecci\u00f3n detalles_pedido [ { \"_id\": 201, \"pedido_id\": 101, \"cantidad\": 1, \"garantia\": \"2 a\u00f1os\" }, { \"_id\": 202, \"pedido_id\": 102, \"cantidad\": 2, \"garantia\": \"1 a\u00f1o\" }, { \"_id\": 203, \"pedido_id\": 103, \"cantidad\": 1, \"garantia\": \"3 a\u00f1os\" } ] Consulta con $lookup anidado La idea es obtener una lista de clientes con sus pedidos, y dentro de cada pedido, los detalles de ese pedido. db.clientes.aggregate([ { \"$lookup\": { \"from\": \"pedidos\", \"localField\": \"_id\", \"foreignField\": \"cliente_id\", \"as\": \"pedidos\" } }, { \"$unwind\": \"$pedidos\" // Descompone el array de pedidos }, { \"$lookup\": { \"from\": \"detalles_pedido\", \"localField\": \"pedidos._id\", \"foreignField\": \"pedido_id\", \"as\": \"pedidos.detalles\" } }, { \"$group\": { \"_id\": \"$_id\", \"nombre\": { \"$first\": \"$nombre\" }, \"email\": { \"$first\": \"$email\" }, \"pedidos\": { \"$push\": \"$pedidos\" } } } ]) Resultado esperado [ { \"_id\": 1, \"nombre\": \"Carlos\", \"email\": \"carlos@example.com\", \"pedidos\": [ { \"_id\": 101, \"cliente_id\": 1, \"producto\": \"Laptop\", \"precio\": 1200, \"detalles\": [ { \"_id\": 201, \"pedido_id\": 101, \"cantidad\": 1, \"garantia\": \"2 a\u00f1os\" } ] }, { \"_id\": 102, \"cliente_id\": 1, \"producto\": \"Mouse\", \"precio\": 50, \"detalles\": [ { \"_id\": 202, \"pedido_id\": 102, \"cantidad\": 2, \"garantia\": \"1 a\u00f1o\" } ] } ] }, { \"_id\": 2, \"nombre\": \"Ana\", \"email\": \"ana@example.com\", \"pedidos\": [ { \"_id\": 103, \"cliente_id\": 2, \"producto\": \"Teclado\", \"precio\": 80, \"detalles\": [ { \"_id\": 203, \"pedido_id\": 103, \"cantidad\": 1, \"garantia\": \"3 a\u00f1os\" } ] } ] } ] \ud83c\udfaf Explicaci\u00f3n del Pipeline $lookup (clientes \u2192 pedidos): Une los pedidos a cada cliente. $unwind (pedidos): Descompone la lista de pedidos para poder hacer otro $lookup. $lookup (pedidos \u2192 detalles_pedido): Une los detalles a cada pedido. $group: Vuelve a agrupar los datos para reconstruir la estructura. \ud83d\udd39El operador $unwind El operador $unwind en MongoDB descompone un array dentro de un documento en m\u00faltiples documentos, cada uno con un solo elemento del array. Es especialmente \u00fatil cuando trabajamos con $lookup , porque las consultas de agregaci\u00f3n en MongoDB manejan arrays, y a veces es necesario convertirlos en documentos individuales para hacer m\u00e1s joins o transformaciones. \u00bfCu\u00e1ndo se usa $unwind? \u2714 Cuando necesitas descomponer arrays en documentos individuales. \u2714 Para hacer joins en m\u00faltiples niveles (como unir detalles_pedido a cada pedido). \u2714 Para hacer c\u00e1lculos en elementos individuales de un array, como contar cu\u00e1ntos productos ha comprado un cliente. Ejemplo sin $unwind db.clientes.aggregate([ { \"$lookup\": { \"from\": \"pedidos\", \"localField\": \"_id\", \"foreignField\": \"cliente_id\", \"as\": \"pedidos\" } } ]) Resultado [ { \"_id\": 1, \"nombre\": \"Carlos\", \"pedidos\": [ { \"_id\": 101, \"cliente_id\": 1, \"producto\": \"Laptop\", \"precio\": 1200 }, { \"_id\": 102, \"cliente_id\": 1, \"producto\": \"Mouse\", \"precio\": 50 } ] }, { \"_id\": 2, \"nombre\": \"Ana\", \"pedidos\": [ { \"_id\": 103, \"cliente_id\": 2, \"producto\": \"Teclado\", \"precio\": 80 } ] } ] Cada cliente tiene un array con sus pedidos, pero si queremos hacer un segundo $lookup (por ejemplo, para unir detalles de los pedidos), MongoDB no puede unir arrays directamente. Ejemplo con $unwind db.clientes.aggregate([ { \"$lookup\": { \"from\": \"pedidos\", \"localField\": \"_id\", \"foreignField\": \"cliente_id\", \"as\": \"pedidos\" } }, { \"$unwind\": \"$pedidos\" } ]) Resultado [ { \"_id\": 1, \"nombre\": \"Carlos\", \"pedidos\": { \"_id\": 101, \"cliente_id\": 1, \"producto\": \"Laptop\", \"precio\": 1200 } }, { \"_id\": 1, \"nombre\": \"Carlos\", \"pedidos\": { \"_id\": 102, \"cliente_id\": 1, \"producto\": \"Mouse\", \"precio\": 50 } }, { \"_id\": 2, \"nombre\": \"Ana\", \"pedidos\": { \"_id\": 103, \"cliente_id\": 2, \"producto\": \"Teclado\", \"precio\": 80 } } ] Ahora, cada cliente tiene m\u00faltiples documentos, uno por cada pedido, lo que permite realizar otro $lookup con detalles_pedido. \ud83d\udd39Desde Kotlin En esta pr\u00e1ctica trabajaremos desde IntelliJ con Kotlin, Jackson y KMongo para construir un ejemplo completo de varias colecciones en MongoDB sobre informaci\u00f3n musical. Utilizaremos Jackson (ObjectMapper) para deserializar los ficheros JSON a data classes de Kotlin, y KMongo para conectarnos, insertar, consultar y ejecutar agregaciones (incluyendo $lookup y $unwind). Jackson nos permitir\u00e1, adem\u00e1s, mapear f\u00e1cilmente resultados de agregaci\u00f3n (documentos BSON) a clases Kotlin mediante convertValue, lo que simplifica mucho el trabajo con pipelines. Modelo de datos: grupos : contiene informaci\u00f3n sobre grupos musicales. estilo : define los distintos estilos musicales (Rock, Jazz, etc.). album : recoge los discos publicados por los grupos. canciones : contiene las canciones que forman parte de los \u00e1lbumes. Cada colecci\u00f3n est\u00e1 relacionada con otras a trav\u00e9s de campos que act\u00faan como referencias . Relaci\u00f3n: grupos \u2192 estilo Cada grupo pertenece a un \u00fanico estilo musical, representado por el campo estilo_id, que hace referencia al campo _id de la colecci\u00f3n estilo. Relaci\u00f3n 1:N : un estilo puede estar asociado a varios grupos, pero cada grupo tiene solo un estilo. // Colecci\u00f3n: grupos [ { _id: \"grupo1\", nombre: \"The Beatles\", a\u00f1o_creacion: 1960, estilo_id: \"estilo1\" }, { _id: \"grupo2\", nombre: \"Queen\", a\u00f1o_creacion: 1970, estilo_id: \"estilo2\" } ] // Colecci\u00f3n: estilo [ { _id: \"estilo1\", nombre: \"Rock\" }, { _id: \"estilo2\", nombre: \"Rock Cl\u00e1sico\" } ] Relaci\u00f3n: album \u2192 grupos Cada \u00e1lbum pertenece a un grupo concreto. Esto se representa mediante el campo grupo_id, que contiene el _id del grupo. Relaci\u00f3n 1:N : un grupo puede tener muchos \u00e1lbumes, pero cada \u00e1lbum pertenece a un \u00fanico grupo. // Colecci\u00f3n: album [ { _id: \"album1\", nombre: \"Abbey Road\", grupo_id: \"grupo1\", a\u00f1o_lanzamiento: 1969 }, { _id: \"album2\", nombre: \"A Night at the Opera\", grupo_id: \"grupo2\", a\u00f1o_lanzamiento: 1975 } ] Relaci\u00f3n: canciones \u2192 album Cada canci\u00f3n pertenece a un \u00e1lbum, identificado mediante el campo album_id. Relaci\u00f3n 1:N : un \u00e1lbum puede tener muchas canciones, pero cada canci\u00f3n pertenece a un solo \u00e1lbum. // Colecci\u00f3n: canciones [ { _id: \"cancion1\", nombre: \"Come Together\", album_id: \"album1\", duracion: 259 }, { _id: \"cancion2\", nombre: \"Bohemian Rhapsody\", album_id: \"album2\", duracion: 355 } ] Estrategia para construir la BD La mejor estrategia para construir la base de datos a partir de archivos JSON es cargar los datos de cada colecci\u00f3n desde cada archivo independiente y luego insertarlos en MongoDB usando KMongo o el driver oficial. As\u00ed mantienes la separaci\u00f3n de datos y facilitas la actualizaci\u00f3n o migraci\u00f3n futura. 1\ufe0f\u20e3 Crea un archivo para cada colecci\u00f3n: grupos.json estilo.json album.json canciones.json Los guradaremos en un paquete nuevo llamado musica dentro del paquete kmongo , que ya ten\u00edamos creado: 2\ufe0f\u20e3 Creamos un programa main() que lea cada archivo JSON y lo convi\u00e9rta a una lista de objetos kotlin utilizando la libreia Jackson e insertamos los objetos en MongoDB utilizando KMongo. package kmongo.musica import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.readValue import org.litote.kmongo.* import java.io.File // \ud83d\udce6 Data classes data class Grupo(val _id: String, val nombre: String, val a\u00f1o_creacion: Int, val estilo_id: String) data class Estilo(val _id: String, val nombre: String) data class Album(val _id: String, val nombre: String, val grupo_id: String, val a\u00f1o_lanzamiento: Int) data class Cancion(val _id: String, val nombre: String, val album_id: String, val duracion: Int) val client = KMongo.createClient(\"mongodb://localhost:27017\") val database = client.getDatabase(\"musicaDB\") val mapper = jacksonObjectMapper() fun cargarGrupos() { val archivo = File(\"src/main/kotlin/kmongo/musica/grupos.json\") val lista: List<Grupo> = mapper.readValue(archivo) val coleccion = database.getCollection<Grupo>(\"grupos\") coleccion.drop() coleccion.insertMany(lista) println(\"\u2705 Grupos insertados:\") for (g in lista) println(\"\ud83c\udfb8 ${g.nombre} (${g.a\u00f1o_creacion})\") } fun cargarEstilos() { val archivo = File(\"src/main/kotlin/kmongo/musica/estilo.json\") val lista: List<Estilo> = mapper.readValue(archivo) val coleccion = database.getCollection<Estilo>(\"estilo\") coleccion.drop() coleccion.insertMany(lista) println(\"\u2705 Estilos insertados:\") for (e in lista) println(\"\ud83c\udfb6 ${e.nombre}\") } fun cargarAlbumes() { val archivo = File(\"src/main/kotlin/kmongo/musica/album.json\") val lista: List<Album> = mapper.readValue(archivo) val coleccion = database.getCollection<Album>(\"album\") coleccion.drop() coleccion.insertMany(lista) println(\"\u2705 \u00c1lbumes insertados:\") for (a in lista) println(\"\ud83d\udcbf ${a.nombre} (${a.a\u00f1o_lanzamiento})\") } fun cargarCanciones() { val archivo = File(\"src/main/kotlin/kmongo/musica/canciones.json\") val lista: List<Cancion> = mapper.readValue(archivo) val coleccion = database.getCollection<Cancion>(\"canciones\") coleccion.drop() coleccion.insertMany(lista) println(\"\u2705 Canciones insertadas:\") for (c in lista) println(\"\ud83c\udfb5 ${c.nombre} - ${c.duracion} segundos\") } fun main() { cargarGrupos() cargarEstilos() cargarAlbumes() cargarCanciones() client.close() println(\"\ud83c\udf89 Base de datos cargada correctamente y conexi\u00f3n cerrada.\") } Comprobar las colecciones desde el shell mongosh use musicaDB show collections db.grupos.find().pretty() db.album.find().pretty() db.canciones.find().pretty() db.estilo.find().pretty() \ud83d\udd39 Agregaci\u00f3n Antes de unir colecciones con $lookup, empezaremos con un ejercicio de agregaci\u00f3n sobre una \u00fanica colecci\u00f3n de nuestra base de datos musical. Usaremos la colecci\u00f3n canciones, que contiene los campos _id, nombre, album_id y duracion. Desde IntelliJ + Kotlin, con Jackson y KMongo, construiremos un pipeline que calcule m\u00e9tricas por album_id sin realizar joins. El objetivo es afianzar la mec\u00e1nica del framework de agregaci\u00f3n (sin $lookup) para obtener, por cada \u00e1lbum (referenciado por album_id): n\u00famero de canciones ($sum) duraci\u00f3n total en segundos ($sum) duraci\u00f3n media ($avg) duraci\u00f3n m\u00ednima y m\u00e1xima ($min, $max) Clases intermedias Cuando trabajamos con KMongo en Kotlin, las consultas simples (find, insert, update) devuelven documentos con la misma estructura que las data class que usamos para mapear las colecciones. Sin embargo, esto cambia completamente cuando usamos agregaciones . El documento que sale de la agregaci\u00f3n NO tiene la misma forma que el documento original almacenado en la colecci\u00f3n. La soluci\u00f3n es utilizar data class intermedias que representan la forma exacta del documento que produce una etapa concreta de la agregaci\u00f3n. \ud83d\udd39A\u00f1ade la clase que refleja exactamente lo que proyecta el pipeline: id de \u00e1lbum, nombre y m\u00e9tricas. data class StatsAlbum( val album_id: String, val album_nombre: String, val total_canciones: Int, val duracion_total: Int, // segundos val duracion_media: Double, // ya redondeada a 1 decimal val duracion_min: Int, val duracion_max: Int ) \ud83d\udd39 A\u00f1ade la funci\u00f3n de agregaci\u00f3n ($group + $lookup + $unwind + $project + $sort) /** \ud83d\udcca Agregaci\u00f3n en UNA colecci\u00f3n: estad\u00edsticas por \u00e1lbum (solo 'canciones') */ fun estadisticasCancionesPorAlbum() { val colDocs = database .getCollection<Cancion>(\"canciones\") .withDocumentClass(Document::class.java) val pipeline = listOf( // 1) Agrupar en 'canciones' por album_id y calcular m\u00e9tricas Document(\"\\$group\", Document() .append(\"_id\", \"\\$album_id\") .append(\"total_canciones\", Document(\"\\$sum\", 1)) .append(\"duracion_total\", Document(\"\\$sum\", \"\\$duracion\")) .append(\"duracion_media_raw\", Document(\"\\$avg\", \"\\$duracion\")) .append(\"duracion_min\", Document(\"\\$min\", \"\\$duracion\")) .append(\"duracion_max\", Document(\"\\$max\", \"\\$duracion\")) ), // 2) Unir con 'album' para obtener el nombre del \u00e1lbum Document(\"\\$lookup\", Document() .append(\"from\", \"album\") .append(\"localField\", \"_id\") .append(\"foreignField\", \"_id\") .append(\"as\", \"album\")), Document(\"\\$unwind\", \"\\$album\"), // 3) Proyecci\u00f3n final (renombrar, redondear y seleccionar campos) Document(\"\\$project\", Document() .append(\"_id\", 0) .append(\"album_id\", \"\\$_id\") .append(\"album_nombre\", \"\\$album.nombre\") .append(\"total_canciones\", 1) .append(\"duracion_total\", 1) .append(\"duracion_min\", 1) .append(\"duracion_max\", 1) .append(\"duracion_media\", Document(\"\\$round\", listOf(\"\\$duracion_media_raw\", 1))) ), // 4) Ordenar por m\u00e1s canciones y luego por m\u00e1s duraci\u00f3n total Document(\"\\$sort\", Document(\"total_canciones\", -1).append(\"duracion_total\", -1)) ) val resultado = colDocs.aggregate(pipeline) .map { d -> mapper.convertValue(d, StatsAlbum::class.java) } .toList() println(\"\\n\ud83d\udcca Estad\u00edsticas por \u00e1lbum:\") resultado.forEach { s -> println( \"\ud83d\udcbf ${s.album_nombre} (${s.album_id}) \u2014 \" + \"\ud83c\udfb5 ${s.total_canciones} | \u23f1 total=${mmss(s.duracion_total)} \" + \"| avg=${\"%.1f\".format(s.duracion_media)}s \" + \"| min=${mmss(s.duracion_min)} | max=${mmss(s.duracion_max)}\" ) } } \ud83d\udd39Incorporamos la funci\u00f3n a main() fun main() { estadisticasCancionesPorAlbum() } \ud83d\udd39 Consultas con $lookup y $unwind Con la base de datos musical ya cargada, vamos a ilustrar c\u00f3mo consultar datos relacionados en MongoDB usando el pipeline de agregaci\u00f3n. En concreto, veremos un ejemplo que: Une colecciones con $lookup (p. ej., canciones \u2192 album \u2192 grupos) para simular un JOIN. Normaliza resultados con $unwind cuando el lookup devuelve arrays, transform\u00e1ndolos en documentos planos y f\u00e1ciles de consumir. el nombre de la canci\u00f3n, el \u00e1lbum al que pertenece, y el grupo que interpreta ese \u00e1lbum. Esto requiere dos niveles de uni\u00f3n: canciones \u2192 album \u2192 grupo \ud83d\udd39 A\u00f1ade estas clases adicionales para representar el resultado de la consulta multinivel (anotamos las clases con @JsonIgnoreProperties(ignoreUnknown = true) para que Jackson ignore cualquier campo que no est\u00e9 declarado): import com.fasterxml.jackson.annotation.JsonIgnoreProperties @JsonIgnoreProperties(ignoreUnknown = true) data class CancionConAlbumYGrupo( val _id: String, val nombre: String, val duracion: Int, val album: AlbumConGrupo? ) @JsonIgnoreProperties(ignoreUnknown = true) data class AlbumConGrupo( val _id: String, val nombre: String, val a\u00f1o_lanzamiento: Int, val grupo: Grupo ) \ud83d\udd39 A\u00f1ade la funci\u00f3n mostrarCancionesConAlbumYGrupo() Pega esta funci\u00f3n al final del archivo (fuera de main, pero dentro del mismo archivo): fun mostrarCancionesConAlbumYGrupo() { val resultado = database.getCollection<Cancion>(\"canciones\") .aggregate<CancionConAlbumYGrupo>( listOf( lookup(\"album\", \"album_id\", \"_id\", \"album\"), unwind(\"\\$album\"), lookup(\"grupos\", \"album.grupo_id\", \"_id\", \"album.grupo\"), unwind(\"\\$album.grupo\") ) ) .toList() println(\"\\n\ud83c\udfb6 Canciones con su \u00e1lbum y grupo:\") for (c in resultado) { println(\"\ud83c\udfb5 ${c.nombre} (${c.duracion}s) - \u00c1lbum: ${c.album.nombre} - Grupo: ${c.album.grupo.nombre}\") } } \ud83d\udd39 Incorporamos la funci\u00f3n a main() fun main() { mostrarCancionesConAlbumYGrupo() } \ud83d\udd39Programa completo package kmongo.musica import com.fasterxml.jackson.annotation.JsonIgnoreProperties import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.readValue import org.bson.Document import org.litote.kmongo.* import java.io.File // \ud83d\udce6 Data classes data class Grupo(val _id: String, val nombre: String, val a\u00f1o_creacion: Int, val estilo_id: String) data class Estilo(val _id: String, val nombre: String) data class Album(val _id: String, val nombre: String, val grupo_id: String, val a\u00f1o_lanzamiento: Int) data class Cancion(val _id: String, val nombre: String, val album_id: String, val duracion: Int) @JsonIgnoreProperties(ignoreUnknown = true) data class CancionConAlbumYGrupo( val _id: String, val nombre: String, val duracion: Int, val album: AlbumConGrupo? ) @JsonIgnoreProperties(ignoreUnknown = true) data class AlbumConGrupo( val _id: String, val nombre: String, val a\u00f1o_lanzamiento: Int, val grupo: Grupo ) data class StatsAlbum( val album_id: String, val album_nombre: String, val total_canciones: Int, val duracion_total: Int, // segundos val duracion_media: Double, // ya redondeada a 1 decimal val duracion_min: Int, val duracion_max: Int ) // funic\u00f3n para formatear segundos a mm:ss private fun mmss(seg: Int) = \"%d:%02d\".format(seg / 60, seg % 60) val client = KMongo.createClient(\"mongodb://localhost:27017\") val database = client.getDatabase(\"musicaDB\") val mapper = jacksonObjectMapper() fun cargarGrupos() { val archivo = File(\"src/main/kotlin/kmongo/musica/grupos.json\") val lista: List<Grupo> = mapper.readValue(archivo) val coleccion = database.getCollection<Grupo>(\"grupos\") coleccion.drop() coleccion.insertMany(lista) println(\"\u2705 Grupos insertados:\") for (g in lista) println(\"\ud83c\udfb8 ${g.nombre} (${g.a\u00f1o_creacion})\") } fun cargarEstilos() { val archivo = File(\"src/main/kotlin/kmongo/musica/estilo.json\") val lista: List<Estilo> = mapper.readValue(archivo) val coleccion = database.getCollection<Estilo>(\"estilo\") coleccion.drop() coleccion.insertMany(lista) println(\"\u2705 Estilos insertados:\") for (e in lista) println(\"\ud83c\udfb6 ${e.nombre}\") } fun cargarAlbumes() { val archivo = File(\"src/main/kotlin/kmongo/musica/album.json\") val lista: List<Album> = mapper.readValue(archivo) val coleccion = database.getCollection<Album>(\"album\") coleccion.drop() coleccion.insertMany(lista) println(\"\u2705 \u00c1lbumes insertados:\") for (a in lista) println(\"\ud83d\udcbf ${a.nombre} (${a.a\u00f1o_lanzamiento})\") } fun cargarCanciones() { val archivo = File(\"src/main/kotlin/kmongo/musica/canciones.json\") val lista: List<Cancion> = mapper.readValue(archivo) val coleccion = database.getCollection<Cancion>(\"canciones\") coleccion.drop() coleccion.insertMany(lista) println(\"\u2705 Canciones insertadas:\") for (c in lista) println(\"\ud83c\udfb5 ${c.nombre} - ${c.duracion} segundos\") } /** \ud83d\udcca Agregaci\u00f3n en UNA colecci\u00f3n: estad\u00edsticas por \u00e1lbum (solo 'canciones') */ fun estadisticasCancionesPorAlbum() { val colDocs = database .getCollection<Cancion>(\"canciones\") .withDocumentClass(Document::class.java) val pipeline = listOf( // 1) Agrupar en 'canciones' por album_id y calcular m\u00e9tricas Document(\"\\$group\", Document() .append(\"_id\", \"\\$album_id\") .append(\"total_canciones\", Document(\"\\$sum\", 1)) .append(\"duracion_total\", Document(\"\\$sum\", \"\\$duracion\")) .append(\"duracion_media_raw\", Document(\"\\$avg\", \"\\$duracion\")) .append(\"duracion_min\", Document(\"\\$min\", \"\\$duracion\")) .append(\"duracion_max\", Document(\"\\$max\", \"\\$duracion\")) ), // 2) Unir con 'album' para obtener el nombre del \u00e1lbum Document(\"\\$lookup\", Document() .append(\"from\", \"album\") .append(\"localField\", \"_id\") .append(\"foreignField\", \"_id\") .append(\"as\", \"album\")), Document(\"\\$unwind\", \"\\$album\"), // 3) Proyecci\u00f3n final (renombrar, redondear y seleccionar campos) Document(\"\\$project\", Document() .append(\"_id\", 0) .append(\"album_id\", \"\\$_id\") .append(\"album_nombre\", \"\\$album.nombre\") .append(\"total_canciones\", 1) .append(\"duracion_total\", 1) .append(\"duracion_min\", 1) .append(\"duracion_max\", 1) .append(\"duracion_media\", Document(\"\\$round\", listOf(\"\\$duracion_media_raw\", 1))) ), // 4) Ordenar por m\u00e1s canciones y luego por m\u00e1s duraci\u00f3n total Document(\"\\$sort\", Document(\"total_canciones\", -1).append(\"duracion_total\", -1)) ) val resultado = colDocs.aggregate(pipeline) .map { d -> mapper.convertValue(d, StatsAlbum::class.java) } .toList() println(\"\\n\ud83d\udcca Estad\u00edsticas por \u00e1lbum:\") resultado.forEach { s -> println( \"\ud83d\udcbf ${s.album_nombre} (${s.album_id}) \u2014 \" + \"\ud83c\udfb5 ${s.total_canciones} | \u23f1 total=${mmss(s.duracion_total)} \" + \"| avg=${\"%.1f\".format(s.duracion_media)}s \" + \"| min=${mmss(s.duracion_min)} | max=${mmss(s.duracion_max)}\" ) } } fun mostrarCancionesConAlbumYGrupo() { val pipeline = listOf( lookup(\"album\", \"album_id\", \"_id\", \"album\"), unwind(\"\\$album\"), lookup(\"grupos\", \"album.grupo_id\", \"_id\", \"album.grupo\"), unwind(\"\\$album.grupo\") ) // vista como Document para que aggregate devuelva Document val colDocs = database .getCollection<Cancion>(\"canciones\") .withDocumentClass(Document::class.java) val resultado = colDocs .aggregate(pipeline) .map { doc -> mapper.convertValue(doc, CancionConAlbumYGrupo::class.java) } .toList() println(\"\\n\ud83c\udfb6 Canciones con su \u00e1lbum y grupo:\") for (c in resultado) { val nombreAlbum = c.album?.nombre ?: \"Sin \u00e1lbum\" val nombreGrupo = c.album?.grupo?.nombre ?: \"Sin grupo\" println(\"\ud83c\udfb5 ${c.nombre} (${c.duracion}s) - \u00c1lbum: $nombreAlbum - Grupo: $nombreGrupo\") } } fun main() { cargarGrupos() cargarEstilos() cargarAlbumes() cargarCanciones() // Agregaci\u00f3n en una sola colecci\u00f3n estadisticasCancionesPorAlbum() // Consultas con $lookup y $unwind mostrarCancionesConAlbumYGrupo() client.close() println(\"\ud83c\udf89 Base de datos cargada correctamente y conexi\u00f3n cerrada.\") } Resultado final:","title":"\ud83d\udd39Colecciones"},{"location":"mongo/colecciones/#colecciones","text":"En los ejemplos vistos hasta ahora hemos trabajado con una \u00fanica colecci\u00f3n formada por varios documentos. En bases de datos NoSQL, como MongoDB, es habitual trabajar con varias colecciones para organizar los datos de forma l\u00f3gica. Aunque NoSQL no soporta joins como SQL, existen estrategias para relacionar colecciones: 1\ufe0f\u20e3 Referencias : En este enfoque, los documentos almacenan solo referencias (IDs) de documentos en otras colecciones . Se usa cuando los datos son reutilizados en m\u00faltiples documentos o crecen mucho en tama\u00f1o. Ejemplo : Cliente y Pedidos en colecciones separadas con referencia Colecci\u00f3n clientes { \"_id\": 1, \"nombre\": \"Juan\", \"email\": \"juan@email.com\", } Colecci\u00f3n pedidos En cada pedido guardamos en el campo cliente_id del cliente. [ { \"_id\": 101, \"cliente_id\": 1, \"producto\": \"Laptop\", \"total\": 1200 }, { \"_id\": 102, \"cliente_id\": 1, \"producto\": \"Mouse\", \"total\": 25 } ] 2\ufe0f\u20e3 Embebido : Este enfoque anida los datos relacionados dentro del mismo documento . Se usa cuando los datos relacionados se consultan frecuentemente juntos y no crecen demasiado en tama\u00f1o. Ejemplo : Cliente con sus Pedidos embebidos { \"_id\": 1, \"nombre\": \"Juan\", \"email\": \"juan@email.com\", \"pedidos\": [ { \"producto\": \"Laptop\", \"total\": 1200 }, { \"producto\": \"Mouse\", \"total\": 25 } ] }","title":"\ud83d\udd39Colecciones"},{"location":"mongo/colecciones/#relaciones-en-mongodb","text":"Aunque MongoDB no es relacional, $lookup permite combinar datos como si fuera una base de datos relacional (tipo SQL), pero usando su sistema de agregaci\u00f3n. El operador $lookup se utiliza en MongoDB para realizar un join entre dos colecciones, es decir, para relacionar documentos de diferentes colecciones usando un campo com\u00fan. Es \u00fatil cuando seguimos un enfoque de referencias , donde almacenamos solo el ObjectId en lugar de los documentos embebidos. Sintaxis { $lookup: { from: <collection_to_join>, localField: <field_from_the_input_documents>, foreignField: <field_from_collection>, as: <output_array_field> } } Ejemplo 1 : Relacionar la coleci\u00f3n Clientes con sus Pedidos Colecci\u00f3n clientes [ { \"_id\": 1, \"nombre\": \"Carlos\", \"email\": \"carlos@example.com\" }, { \"_id\": 2, \"nombre\": \"Ana\", \"email\": \"ana@example.com\" } ] Colecci\u00f3n pedidos [ { \"_id\": 101, \"cliente_id\": 1, \"producto\": \"Laptop\", \"precio\": 1200 }, { \"_id\": 102, \"cliente_id\": 1, \"producto\": \"Mouse\", \"precio\": 50 }, { \"_id\": 103, \"cliente_id\": 2, \"producto\": \"Teclado\", \"precio\": 80 } ] Consulta con $lookup para unir clientes con sus pedidos db.clientes.aggregate([ { \"$lookup\": { \"from\": \"pedidos\", // Colecci\u00f3n a unir \"localField\": \"_id\", // Campo en la colecci\u00f3n actual (clientes) \"foreignField\": \"cliente_id\", // Campo en la otra colecci\u00f3n (pedidos) \"as\": \"pedidos\" // Nombre del campo de salida con los pedidos } } ]) Resultado esperado [ { \"_id\": 1, \"nombre\": \"Carlos\", \"email\": \"carlos@example.com\", \"pedidos\": [ { \"_id\": 101, \"cliente_id\": 1, \"producto\": \"Laptop\", \"precio\": 1200 }, { \"_id\": 102, \"cliente_id\": 1, \"producto\": \"Mouse\", \"precio\": 50 } ] }, { \"_id\": 2, \"nombre\": \"Ana\", \"email\": \"ana@example.com\", \"pedidos\": [ { \"_id\": 103, \"cliente_id\": 2, \"producto\": \"Teclado\", \"precio\": 80 } ] } ] Ejemplo 2 : Realcionar la colecci\u00f3n autores con sus libros. // Colecciones db.createCollection(\"authors\"); db.createCollection(\"books\"); // 1) Insertar autor con _id(string) db.authors.insertOne({ _id: \"diego\", name: \"Diego Cort\u00e9s\", email: \"dcortes@example.com\", age: 25 }); // 2) Insertar libros referenciando el _id del autor db.books.insertMany([ { _id: \"book-philosopher-stone\", name: \"Philosopher's Stone\", author_id: \"diego\" // \u2190 referencia }, { _id: \"book-secret-programming\", name: \"Secret of programming\", author_id: \"diego\" // \u2190 referencia } ]); // 3) JOIN con $lookup (authors \u2192 books) db.getCollection(\"authors\").aggregate([ { $lookup: { from: \"books\", localField: \"_id\", // \"diego\" foreignField: \"author_id\", as: \"books\" } } ]); Resultado esperado [ { _id: 'diego', name: 'Diego Cort\u00e9s', email: 'dcortes@example.com', age: 25, books: [ { _id: 'book-philosopher-stone', name: \"Philosopher's Stone\", author_id: 'diego' }, { _id: 'book-secret-programming', name: 'Secret of programming', author_id: 'diego' } ] } ]","title":"\ud83d\udd39 Relaciones en MongoDB"},{"location":"mongo/colecciones/#lookup-anidado","text":"Siguiendo con el ejemplo de clientes y sus pedidos, si cada pedido tiene detalles en una tercera colecci\u00f3n detalles_pedido , podemos anidar otro $lookup: Ejemplo : Relacionar clientes con pedidos y detalles_pedido Colecci\u00f3n clientes [ { \"_id\": 1, \"nombre\": \"Carlos\", \"email\": \"carlos@example.com\" }, { \"_id\": 2, \"nombre\": \"Ana\", \"email\": \"ana@example.com\" } ] Colecci\u00f3n pedidos [ { \"_id\": 101, \"cliente_id\": 1, \"producto\": \"Laptop\", \"precio\": 1200 }, { \"_id\": 102, \"cliente_id\": 1, \"producto\": \"Mouse\", \"precio\": 50 }, { \"_id\": 103, \"cliente_id\": 2, \"producto\": \"Teclado\", \"precio\": 80 } ] Colecci\u00f3n detalles_pedido [ { \"_id\": 201, \"pedido_id\": 101, \"cantidad\": 1, \"garantia\": \"2 a\u00f1os\" }, { \"_id\": 202, \"pedido_id\": 102, \"cantidad\": 2, \"garantia\": \"1 a\u00f1o\" }, { \"_id\": 203, \"pedido_id\": 103, \"cantidad\": 1, \"garantia\": \"3 a\u00f1os\" } ] Consulta con $lookup anidado La idea es obtener una lista de clientes con sus pedidos, y dentro de cada pedido, los detalles de ese pedido. db.clientes.aggregate([ { \"$lookup\": { \"from\": \"pedidos\", \"localField\": \"_id\", \"foreignField\": \"cliente_id\", \"as\": \"pedidos\" } }, { \"$unwind\": \"$pedidos\" // Descompone el array de pedidos }, { \"$lookup\": { \"from\": \"detalles_pedido\", \"localField\": \"pedidos._id\", \"foreignField\": \"pedido_id\", \"as\": \"pedidos.detalles\" } }, { \"$group\": { \"_id\": \"$_id\", \"nombre\": { \"$first\": \"$nombre\" }, \"email\": { \"$first\": \"$email\" }, \"pedidos\": { \"$push\": \"$pedidos\" } } } ]) Resultado esperado [ { \"_id\": 1, \"nombre\": \"Carlos\", \"email\": \"carlos@example.com\", \"pedidos\": [ { \"_id\": 101, \"cliente_id\": 1, \"producto\": \"Laptop\", \"precio\": 1200, \"detalles\": [ { \"_id\": 201, \"pedido_id\": 101, \"cantidad\": 1, \"garantia\": \"2 a\u00f1os\" } ] }, { \"_id\": 102, \"cliente_id\": 1, \"producto\": \"Mouse\", \"precio\": 50, \"detalles\": [ { \"_id\": 202, \"pedido_id\": 102, \"cantidad\": 2, \"garantia\": \"1 a\u00f1o\" } ] } ] }, { \"_id\": 2, \"nombre\": \"Ana\", \"email\": \"ana@example.com\", \"pedidos\": [ { \"_id\": 103, \"cliente_id\": 2, \"producto\": \"Teclado\", \"precio\": 80, \"detalles\": [ { \"_id\": 203, \"pedido_id\": 103, \"cantidad\": 1, \"garantia\": \"3 a\u00f1os\" } ] } ] } ] \ud83c\udfaf Explicaci\u00f3n del Pipeline $lookup (clientes \u2192 pedidos): Une los pedidos a cada cliente. $unwind (pedidos): Descompone la lista de pedidos para poder hacer otro $lookup. $lookup (pedidos \u2192 detalles_pedido): Une los detalles a cada pedido. $group: Vuelve a agrupar los datos para reconstruir la estructura.","title":"\ud83d\udd39 $lookup anidado"},{"location":"mongo/colecciones/#el-operador-unwind","text":"El operador $unwind en MongoDB descompone un array dentro de un documento en m\u00faltiples documentos, cada uno con un solo elemento del array. Es especialmente \u00fatil cuando trabajamos con $lookup , porque las consultas de agregaci\u00f3n en MongoDB manejan arrays, y a veces es necesario convertirlos en documentos individuales para hacer m\u00e1s joins o transformaciones. \u00bfCu\u00e1ndo se usa $unwind? \u2714 Cuando necesitas descomponer arrays en documentos individuales. \u2714 Para hacer joins en m\u00faltiples niveles (como unir detalles_pedido a cada pedido). \u2714 Para hacer c\u00e1lculos en elementos individuales de un array, como contar cu\u00e1ntos productos ha comprado un cliente. Ejemplo sin $unwind db.clientes.aggregate([ { \"$lookup\": { \"from\": \"pedidos\", \"localField\": \"_id\", \"foreignField\": \"cliente_id\", \"as\": \"pedidos\" } } ]) Resultado [ { \"_id\": 1, \"nombre\": \"Carlos\", \"pedidos\": [ { \"_id\": 101, \"cliente_id\": 1, \"producto\": \"Laptop\", \"precio\": 1200 }, { \"_id\": 102, \"cliente_id\": 1, \"producto\": \"Mouse\", \"precio\": 50 } ] }, { \"_id\": 2, \"nombre\": \"Ana\", \"pedidos\": [ { \"_id\": 103, \"cliente_id\": 2, \"producto\": \"Teclado\", \"precio\": 80 } ] } ] Cada cliente tiene un array con sus pedidos, pero si queremos hacer un segundo $lookup (por ejemplo, para unir detalles de los pedidos), MongoDB no puede unir arrays directamente. Ejemplo con $unwind db.clientes.aggregate([ { \"$lookup\": { \"from\": \"pedidos\", \"localField\": \"_id\", \"foreignField\": \"cliente_id\", \"as\": \"pedidos\" } }, { \"$unwind\": \"$pedidos\" } ]) Resultado [ { \"_id\": 1, \"nombre\": \"Carlos\", \"pedidos\": { \"_id\": 101, \"cliente_id\": 1, \"producto\": \"Laptop\", \"precio\": 1200 } }, { \"_id\": 1, \"nombre\": \"Carlos\", \"pedidos\": { \"_id\": 102, \"cliente_id\": 1, \"producto\": \"Mouse\", \"precio\": 50 } }, { \"_id\": 2, \"nombre\": \"Ana\", \"pedidos\": { \"_id\": 103, \"cliente_id\": 2, \"producto\": \"Teclado\", \"precio\": 80 } } ] Ahora, cada cliente tiene m\u00faltiples documentos, uno por cada pedido, lo que permite realizar otro $lookup con detalles_pedido.","title":"\ud83d\udd39El operador $unwind"},{"location":"mongo/colecciones/#desde-kotlin","text":"En esta pr\u00e1ctica trabajaremos desde IntelliJ con Kotlin, Jackson y KMongo para construir un ejemplo completo de varias colecciones en MongoDB sobre informaci\u00f3n musical. Utilizaremos Jackson (ObjectMapper) para deserializar los ficheros JSON a data classes de Kotlin, y KMongo para conectarnos, insertar, consultar y ejecutar agregaciones (incluyendo $lookup y $unwind). Jackson nos permitir\u00e1, adem\u00e1s, mapear f\u00e1cilmente resultados de agregaci\u00f3n (documentos BSON) a clases Kotlin mediante convertValue, lo que simplifica mucho el trabajo con pipelines. Modelo de datos: grupos : contiene informaci\u00f3n sobre grupos musicales. estilo : define los distintos estilos musicales (Rock, Jazz, etc.). album : recoge los discos publicados por los grupos. canciones : contiene las canciones que forman parte de los \u00e1lbumes. Cada colecci\u00f3n est\u00e1 relacionada con otras a trav\u00e9s de campos que act\u00faan como referencias . Relaci\u00f3n: grupos \u2192 estilo Cada grupo pertenece a un \u00fanico estilo musical, representado por el campo estilo_id, que hace referencia al campo _id de la colecci\u00f3n estilo. Relaci\u00f3n 1:N : un estilo puede estar asociado a varios grupos, pero cada grupo tiene solo un estilo. // Colecci\u00f3n: grupos [ { _id: \"grupo1\", nombre: \"The Beatles\", a\u00f1o_creacion: 1960, estilo_id: \"estilo1\" }, { _id: \"grupo2\", nombre: \"Queen\", a\u00f1o_creacion: 1970, estilo_id: \"estilo2\" } ] // Colecci\u00f3n: estilo [ { _id: \"estilo1\", nombre: \"Rock\" }, { _id: \"estilo2\", nombre: \"Rock Cl\u00e1sico\" } ] Relaci\u00f3n: album \u2192 grupos Cada \u00e1lbum pertenece a un grupo concreto. Esto se representa mediante el campo grupo_id, que contiene el _id del grupo. Relaci\u00f3n 1:N : un grupo puede tener muchos \u00e1lbumes, pero cada \u00e1lbum pertenece a un \u00fanico grupo. // Colecci\u00f3n: album [ { _id: \"album1\", nombre: \"Abbey Road\", grupo_id: \"grupo1\", a\u00f1o_lanzamiento: 1969 }, { _id: \"album2\", nombre: \"A Night at the Opera\", grupo_id: \"grupo2\", a\u00f1o_lanzamiento: 1975 } ] Relaci\u00f3n: canciones \u2192 album Cada canci\u00f3n pertenece a un \u00e1lbum, identificado mediante el campo album_id. Relaci\u00f3n 1:N : un \u00e1lbum puede tener muchas canciones, pero cada canci\u00f3n pertenece a un solo \u00e1lbum. // Colecci\u00f3n: canciones [ { _id: \"cancion1\", nombre: \"Come Together\", album_id: \"album1\", duracion: 259 }, { _id: \"cancion2\", nombre: \"Bohemian Rhapsody\", album_id: \"album2\", duracion: 355 } ] Estrategia para construir la BD La mejor estrategia para construir la base de datos a partir de archivos JSON es cargar los datos de cada colecci\u00f3n desde cada archivo independiente y luego insertarlos en MongoDB usando KMongo o el driver oficial. As\u00ed mantienes la separaci\u00f3n de datos y facilitas la actualizaci\u00f3n o migraci\u00f3n futura. 1\ufe0f\u20e3 Crea un archivo para cada colecci\u00f3n: grupos.json estilo.json album.json canciones.json Los guradaremos en un paquete nuevo llamado musica dentro del paquete kmongo , que ya ten\u00edamos creado: 2\ufe0f\u20e3 Creamos un programa main() que lea cada archivo JSON y lo convi\u00e9rta a una lista de objetos kotlin utilizando la libreia Jackson e insertamos los objetos en MongoDB utilizando KMongo. package kmongo.musica import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.readValue import org.litote.kmongo.* import java.io.File // \ud83d\udce6 Data classes data class Grupo(val _id: String, val nombre: String, val a\u00f1o_creacion: Int, val estilo_id: String) data class Estilo(val _id: String, val nombre: String) data class Album(val _id: String, val nombre: String, val grupo_id: String, val a\u00f1o_lanzamiento: Int) data class Cancion(val _id: String, val nombre: String, val album_id: String, val duracion: Int) val client = KMongo.createClient(\"mongodb://localhost:27017\") val database = client.getDatabase(\"musicaDB\") val mapper = jacksonObjectMapper() fun cargarGrupos() { val archivo = File(\"src/main/kotlin/kmongo/musica/grupos.json\") val lista: List<Grupo> = mapper.readValue(archivo) val coleccion = database.getCollection<Grupo>(\"grupos\") coleccion.drop() coleccion.insertMany(lista) println(\"\u2705 Grupos insertados:\") for (g in lista) println(\"\ud83c\udfb8 ${g.nombre} (${g.a\u00f1o_creacion})\") } fun cargarEstilos() { val archivo = File(\"src/main/kotlin/kmongo/musica/estilo.json\") val lista: List<Estilo> = mapper.readValue(archivo) val coleccion = database.getCollection<Estilo>(\"estilo\") coleccion.drop() coleccion.insertMany(lista) println(\"\u2705 Estilos insertados:\") for (e in lista) println(\"\ud83c\udfb6 ${e.nombre}\") } fun cargarAlbumes() { val archivo = File(\"src/main/kotlin/kmongo/musica/album.json\") val lista: List<Album> = mapper.readValue(archivo) val coleccion = database.getCollection<Album>(\"album\") coleccion.drop() coleccion.insertMany(lista) println(\"\u2705 \u00c1lbumes insertados:\") for (a in lista) println(\"\ud83d\udcbf ${a.nombre} (${a.a\u00f1o_lanzamiento})\") } fun cargarCanciones() { val archivo = File(\"src/main/kotlin/kmongo/musica/canciones.json\") val lista: List<Cancion> = mapper.readValue(archivo) val coleccion = database.getCollection<Cancion>(\"canciones\") coleccion.drop() coleccion.insertMany(lista) println(\"\u2705 Canciones insertadas:\") for (c in lista) println(\"\ud83c\udfb5 ${c.nombre} - ${c.duracion} segundos\") } fun main() { cargarGrupos() cargarEstilos() cargarAlbumes() cargarCanciones() client.close() println(\"\ud83c\udf89 Base de datos cargada correctamente y conexi\u00f3n cerrada.\") } Comprobar las colecciones desde el shell mongosh use musicaDB show collections db.grupos.find().pretty() db.album.find().pretty() db.canciones.find().pretty() db.estilo.find().pretty()","title":"\ud83d\udd39Desde Kotlin"},{"location":"mongo/colecciones/#agregacion","text":"Antes de unir colecciones con $lookup, empezaremos con un ejercicio de agregaci\u00f3n sobre una \u00fanica colecci\u00f3n de nuestra base de datos musical. Usaremos la colecci\u00f3n canciones, que contiene los campos _id, nombre, album_id y duracion. Desde IntelliJ + Kotlin, con Jackson y KMongo, construiremos un pipeline que calcule m\u00e9tricas por album_id sin realizar joins. El objetivo es afianzar la mec\u00e1nica del framework de agregaci\u00f3n (sin $lookup) para obtener, por cada \u00e1lbum (referenciado por album_id): n\u00famero de canciones ($sum) duraci\u00f3n total en segundos ($sum) duraci\u00f3n media ($avg) duraci\u00f3n m\u00ednima y m\u00e1xima ($min, $max) Clases intermedias Cuando trabajamos con KMongo en Kotlin, las consultas simples (find, insert, update) devuelven documentos con la misma estructura que las data class que usamos para mapear las colecciones. Sin embargo, esto cambia completamente cuando usamos agregaciones . El documento que sale de la agregaci\u00f3n NO tiene la misma forma que el documento original almacenado en la colecci\u00f3n. La soluci\u00f3n es utilizar data class intermedias que representan la forma exacta del documento que produce una etapa concreta de la agregaci\u00f3n. \ud83d\udd39A\u00f1ade la clase que refleja exactamente lo que proyecta el pipeline: id de \u00e1lbum, nombre y m\u00e9tricas. data class StatsAlbum( val album_id: String, val album_nombre: String, val total_canciones: Int, val duracion_total: Int, // segundos val duracion_media: Double, // ya redondeada a 1 decimal val duracion_min: Int, val duracion_max: Int ) \ud83d\udd39 A\u00f1ade la funci\u00f3n de agregaci\u00f3n ($group + $lookup + $unwind + $project + $sort) /** \ud83d\udcca Agregaci\u00f3n en UNA colecci\u00f3n: estad\u00edsticas por \u00e1lbum (solo 'canciones') */ fun estadisticasCancionesPorAlbum() { val colDocs = database .getCollection<Cancion>(\"canciones\") .withDocumentClass(Document::class.java) val pipeline = listOf( // 1) Agrupar en 'canciones' por album_id y calcular m\u00e9tricas Document(\"\\$group\", Document() .append(\"_id\", \"\\$album_id\") .append(\"total_canciones\", Document(\"\\$sum\", 1)) .append(\"duracion_total\", Document(\"\\$sum\", \"\\$duracion\")) .append(\"duracion_media_raw\", Document(\"\\$avg\", \"\\$duracion\")) .append(\"duracion_min\", Document(\"\\$min\", \"\\$duracion\")) .append(\"duracion_max\", Document(\"\\$max\", \"\\$duracion\")) ), // 2) Unir con 'album' para obtener el nombre del \u00e1lbum Document(\"\\$lookup\", Document() .append(\"from\", \"album\") .append(\"localField\", \"_id\") .append(\"foreignField\", \"_id\") .append(\"as\", \"album\")), Document(\"\\$unwind\", \"\\$album\"), // 3) Proyecci\u00f3n final (renombrar, redondear y seleccionar campos) Document(\"\\$project\", Document() .append(\"_id\", 0) .append(\"album_id\", \"\\$_id\") .append(\"album_nombre\", \"\\$album.nombre\") .append(\"total_canciones\", 1) .append(\"duracion_total\", 1) .append(\"duracion_min\", 1) .append(\"duracion_max\", 1) .append(\"duracion_media\", Document(\"\\$round\", listOf(\"\\$duracion_media_raw\", 1))) ), // 4) Ordenar por m\u00e1s canciones y luego por m\u00e1s duraci\u00f3n total Document(\"\\$sort\", Document(\"total_canciones\", -1).append(\"duracion_total\", -1)) ) val resultado = colDocs.aggregate(pipeline) .map { d -> mapper.convertValue(d, StatsAlbum::class.java) } .toList() println(\"\\n\ud83d\udcca Estad\u00edsticas por \u00e1lbum:\") resultado.forEach { s -> println( \"\ud83d\udcbf ${s.album_nombre} (${s.album_id}) \u2014 \" + \"\ud83c\udfb5 ${s.total_canciones} | \u23f1 total=${mmss(s.duracion_total)} \" + \"| avg=${\"%.1f\".format(s.duracion_media)}s \" + \"| min=${mmss(s.duracion_min)} | max=${mmss(s.duracion_max)}\" ) } } \ud83d\udd39Incorporamos la funci\u00f3n a main() fun main() { estadisticasCancionesPorAlbum() }","title":"\ud83d\udd39 Agregaci\u00f3n"},{"location":"mongo/colecciones/#consultas-con-lookup-y-unwind","text":"Con la base de datos musical ya cargada, vamos a ilustrar c\u00f3mo consultar datos relacionados en MongoDB usando el pipeline de agregaci\u00f3n. En concreto, veremos un ejemplo que: Une colecciones con $lookup (p. ej., canciones \u2192 album \u2192 grupos) para simular un JOIN. Normaliza resultados con $unwind cuando el lookup devuelve arrays, transform\u00e1ndolos en documentos planos y f\u00e1ciles de consumir. el nombre de la canci\u00f3n, el \u00e1lbum al que pertenece, y el grupo que interpreta ese \u00e1lbum. Esto requiere dos niveles de uni\u00f3n: canciones \u2192 album \u2192 grupo \ud83d\udd39 A\u00f1ade estas clases adicionales para representar el resultado de la consulta multinivel (anotamos las clases con @JsonIgnoreProperties(ignoreUnknown = true) para que Jackson ignore cualquier campo que no est\u00e9 declarado): import com.fasterxml.jackson.annotation.JsonIgnoreProperties @JsonIgnoreProperties(ignoreUnknown = true) data class CancionConAlbumYGrupo( val _id: String, val nombre: String, val duracion: Int, val album: AlbumConGrupo? ) @JsonIgnoreProperties(ignoreUnknown = true) data class AlbumConGrupo( val _id: String, val nombre: String, val a\u00f1o_lanzamiento: Int, val grupo: Grupo ) \ud83d\udd39 A\u00f1ade la funci\u00f3n mostrarCancionesConAlbumYGrupo() Pega esta funci\u00f3n al final del archivo (fuera de main, pero dentro del mismo archivo): fun mostrarCancionesConAlbumYGrupo() { val resultado = database.getCollection<Cancion>(\"canciones\") .aggregate<CancionConAlbumYGrupo>( listOf( lookup(\"album\", \"album_id\", \"_id\", \"album\"), unwind(\"\\$album\"), lookup(\"grupos\", \"album.grupo_id\", \"_id\", \"album.grupo\"), unwind(\"\\$album.grupo\") ) ) .toList() println(\"\\n\ud83c\udfb6 Canciones con su \u00e1lbum y grupo:\") for (c in resultado) { println(\"\ud83c\udfb5 ${c.nombre} (${c.duracion}s) - \u00c1lbum: ${c.album.nombre} - Grupo: ${c.album.grupo.nombre}\") } } \ud83d\udd39 Incorporamos la funci\u00f3n a main() fun main() { mostrarCancionesConAlbumYGrupo() }","title":"\ud83d\udd39 Consultas con $lookup y $unwind"},{"location":"mongo/colecciones/#programa-completo","text":"package kmongo.musica import com.fasterxml.jackson.annotation.JsonIgnoreProperties import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.readValue import org.bson.Document import org.litote.kmongo.* import java.io.File // \ud83d\udce6 Data classes data class Grupo(val _id: String, val nombre: String, val a\u00f1o_creacion: Int, val estilo_id: String) data class Estilo(val _id: String, val nombre: String) data class Album(val _id: String, val nombre: String, val grupo_id: String, val a\u00f1o_lanzamiento: Int) data class Cancion(val _id: String, val nombre: String, val album_id: String, val duracion: Int) @JsonIgnoreProperties(ignoreUnknown = true) data class CancionConAlbumYGrupo( val _id: String, val nombre: String, val duracion: Int, val album: AlbumConGrupo? ) @JsonIgnoreProperties(ignoreUnknown = true) data class AlbumConGrupo( val _id: String, val nombre: String, val a\u00f1o_lanzamiento: Int, val grupo: Grupo ) data class StatsAlbum( val album_id: String, val album_nombre: String, val total_canciones: Int, val duracion_total: Int, // segundos val duracion_media: Double, // ya redondeada a 1 decimal val duracion_min: Int, val duracion_max: Int ) // funic\u00f3n para formatear segundos a mm:ss private fun mmss(seg: Int) = \"%d:%02d\".format(seg / 60, seg % 60) val client = KMongo.createClient(\"mongodb://localhost:27017\") val database = client.getDatabase(\"musicaDB\") val mapper = jacksonObjectMapper() fun cargarGrupos() { val archivo = File(\"src/main/kotlin/kmongo/musica/grupos.json\") val lista: List<Grupo> = mapper.readValue(archivo) val coleccion = database.getCollection<Grupo>(\"grupos\") coleccion.drop() coleccion.insertMany(lista) println(\"\u2705 Grupos insertados:\") for (g in lista) println(\"\ud83c\udfb8 ${g.nombre} (${g.a\u00f1o_creacion})\") } fun cargarEstilos() { val archivo = File(\"src/main/kotlin/kmongo/musica/estilo.json\") val lista: List<Estilo> = mapper.readValue(archivo) val coleccion = database.getCollection<Estilo>(\"estilo\") coleccion.drop() coleccion.insertMany(lista) println(\"\u2705 Estilos insertados:\") for (e in lista) println(\"\ud83c\udfb6 ${e.nombre}\") } fun cargarAlbumes() { val archivo = File(\"src/main/kotlin/kmongo/musica/album.json\") val lista: List<Album> = mapper.readValue(archivo) val coleccion = database.getCollection<Album>(\"album\") coleccion.drop() coleccion.insertMany(lista) println(\"\u2705 \u00c1lbumes insertados:\") for (a in lista) println(\"\ud83d\udcbf ${a.nombre} (${a.a\u00f1o_lanzamiento})\") } fun cargarCanciones() { val archivo = File(\"src/main/kotlin/kmongo/musica/canciones.json\") val lista: List<Cancion> = mapper.readValue(archivo) val coleccion = database.getCollection<Cancion>(\"canciones\") coleccion.drop() coleccion.insertMany(lista) println(\"\u2705 Canciones insertadas:\") for (c in lista) println(\"\ud83c\udfb5 ${c.nombre} - ${c.duracion} segundos\") } /** \ud83d\udcca Agregaci\u00f3n en UNA colecci\u00f3n: estad\u00edsticas por \u00e1lbum (solo 'canciones') */ fun estadisticasCancionesPorAlbum() { val colDocs = database .getCollection<Cancion>(\"canciones\") .withDocumentClass(Document::class.java) val pipeline = listOf( // 1) Agrupar en 'canciones' por album_id y calcular m\u00e9tricas Document(\"\\$group\", Document() .append(\"_id\", \"\\$album_id\") .append(\"total_canciones\", Document(\"\\$sum\", 1)) .append(\"duracion_total\", Document(\"\\$sum\", \"\\$duracion\")) .append(\"duracion_media_raw\", Document(\"\\$avg\", \"\\$duracion\")) .append(\"duracion_min\", Document(\"\\$min\", \"\\$duracion\")) .append(\"duracion_max\", Document(\"\\$max\", \"\\$duracion\")) ), // 2) Unir con 'album' para obtener el nombre del \u00e1lbum Document(\"\\$lookup\", Document() .append(\"from\", \"album\") .append(\"localField\", \"_id\") .append(\"foreignField\", \"_id\") .append(\"as\", \"album\")), Document(\"\\$unwind\", \"\\$album\"), // 3) Proyecci\u00f3n final (renombrar, redondear y seleccionar campos) Document(\"\\$project\", Document() .append(\"_id\", 0) .append(\"album_id\", \"\\$_id\") .append(\"album_nombre\", \"\\$album.nombre\") .append(\"total_canciones\", 1) .append(\"duracion_total\", 1) .append(\"duracion_min\", 1) .append(\"duracion_max\", 1) .append(\"duracion_media\", Document(\"\\$round\", listOf(\"\\$duracion_media_raw\", 1))) ), // 4) Ordenar por m\u00e1s canciones y luego por m\u00e1s duraci\u00f3n total Document(\"\\$sort\", Document(\"total_canciones\", -1).append(\"duracion_total\", -1)) ) val resultado = colDocs.aggregate(pipeline) .map { d -> mapper.convertValue(d, StatsAlbum::class.java) } .toList() println(\"\\n\ud83d\udcca Estad\u00edsticas por \u00e1lbum:\") resultado.forEach { s -> println( \"\ud83d\udcbf ${s.album_nombre} (${s.album_id}) \u2014 \" + \"\ud83c\udfb5 ${s.total_canciones} | \u23f1 total=${mmss(s.duracion_total)} \" + \"| avg=${\"%.1f\".format(s.duracion_media)}s \" + \"| min=${mmss(s.duracion_min)} | max=${mmss(s.duracion_max)}\" ) } } fun mostrarCancionesConAlbumYGrupo() { val pipeline = listOf( lookup(\"album\", \"album_id\", \"_id\", \"album\"), unwind(\"\\$album\"), lookup(\"grupos\", \"album.grupo_id\", \"_id\", \"album.grupo\"), unwind(\"\\$album.grupo\") ) // vista como Document para que aggregate devuelva Document val colDocs = database .getCollection<Cancion>(\"canciones\") .withDocumentClass(Document::class.java) val resultado = colDocs .aggregate(pipeline) .map { doc -> mapper.convertValue(doc, CancionConAlbumYGrupo::class.java) } .toList() println(\"\\n\ud83c\udfb6 Canciones con su \u00e1lbum y grupo:\") for (c in resultado) { val nombreAlbum = c.album?.nombre ?: \"Sin \u00e1lbum\" val nombreGrupo = c.album?.grupo?.nombre ?: \"Sin grupo\" println(\"\ud83c\udfb5 ${c.nombre} (${c.duracion}s) - \u00c1lbum: $nombreAlbum - Grupo: $nombreGrupo\") } } fun main() { cargarGrupos() cargarEstilos() cargarAlbumes() cargarCanciones() // Agregaci\u00f3n en una sola colecci\u00f3n estadisticasCancionesPorAlbum() // Consultas con $lookup y $unwind mostrarCancionesConAlbumYGrupo() client.close() println(\"\ud83c\udf89 Base de datos cargada correctamente y conexi\u00f3n cerrada.\") } Resultado final:","title":"\ud83d\udd39Programa completo"},{"location":"mongo/comandos/","text":"\ud83d\udd39 Comandos de MongoDB y su utilizaci\u00f3n Los comandos b\u00e1sicos de MongoDB ya se trabajaron en 1.\u00ba de DAM, cuando se introdujo el modelo NoSQL y las operaciones fundamentales sobre colecciones y documentos. En este tema no se pretende volver a explicarlos desde cero, sino ofrecer un resumen pr\u00e1ctico y actualizado con los comandos m\u00e1s \u00fatiles para consultar, ordenar, filtrar y gestionar datos en MongoDB, que te servir\u00e1 como recordatorio y punto de partida para los ejercicios de este m\u00f3dulo. MongoDB utiliza su propia shell interactiva , llamada mongosh , que permite ejecutar comandos para administrar bases de datos, colecciones y documentos. Su sintaxis es muy similar a JavaScript , ya que cada comando se ejecuta sobre un objeto base : db.coleccion.operacion() db \u2192 representa la base de datos actual. coleccion \u2192 el nombre de la colecci\u00f3n sobre la que actuamos. operacion() \u2192 el comando que deseamos ejecutar. \ud83d\udd39 Sobre bases de datos Comando Descripci\u00f3n Ejemplo show dbs Muestra todas las bases de datos existentes. show dbs use <nombre> Cambia a una base de datos (la crea si no existe). use biblioteca db.getName() Muestra el nombre de la base de datos actual. db.getName() db.dropDatabase() Elimina la base de datos actual. db.dropDatabase() \ud83d\udd39 Sobre colecciones Comando Descripci\u00f3n show collections Lista todas las colecciones de la base de datos. Ejemplo: show collections db.createCollection(\"nombre\") Crea una colecci\u00f3n vac\u00eda. Ejemplo: db.createCollection(\"alumnos\") db.coleccion.drop() Elimina una colecci\u00f3n completa. Ejemplo: db.alumnos.drop() db.coleccion.renameCollection(\"nuevoNombre\") Cambia el nombre de una colecci\u00f3n. Ejemplo: db.alumnos.renameCollection(\"estudiantes\") \ud83d\udd39 Operaciones CRUD \ud83d\udd39Inserci\u00f3n Comando Descripci\u00f3n insertOne() Inserta un solo documento. Ejemplo: db.alumnos.insertOne({nombre:\"Ana\", nota:8}) insertMany() Inserta varios documentos a la vez. Ejemplo: db.alumnos.insertMany([{nombre:\"Luis\", nota:7}, {nombre:\"Marta\", nota:9}]) \ud83d\udccc Si la colecci\u00f3n no existe, MongoDB la crear\u00e1 autom\u00e1ticamente en el momento de la inserci\u00f3n. Inserci\u00f3n especificando el id Si en la inserci\u00f3n del documento no se especifica el campo _id , como es el caso de los ejemplos anteriores, Mongo lo genera autom\u00e1ticamente de tipo ObjectId . Pero nosotros podemos poner este campo _id con el valor que queramos. Eso s\u00ed, debemos asegurarnos de que ese valor no lo use ning\u00fan otro documento de la colecci\u00f3n, o nos dar\u00e1 un error. \ud83d\udd39B\u00fasqueda Comando Descripci\u00f3n find() Devuelve todos los documentos de la colecci\u00f3n. Ejemplo: db.alumnos.find() findOne() Devuelve el primer documento que cumple una condici\u00f3n. Ejemplo: db.alumnos.findOne({nombre:\"Ana\"}) find(criterio, proyecci\u00f3n) Permite filtrar y mostrar solo algunos campos. Ejemplo: db.alumnos.find({nota:{$gte:8}}, {nombre:1, _id:0}) \ud83d\udcd8 Operadores comunes : $eq (igual), $ne (distinto), $gt (mayor que), $lt (menor que), $gte (mayor o igual), $lte (menor o igual), $in , $and , $or . \ud83d\udd39 Actualizaci\u00f3n Comando Descripci\u00f3n updateOne(filtro, cambios) Actualiza el primer documento que cumpla la condici\u00f3n. Ejemplo: db.alumnos.updateOne({nombre:\"Ana\"}, {$set:{nota:9}}) updateMany(filtro, cambios) Actualiza todos los documentos que cumplan la condici\u00f3n. Ejemplo: db.alumnos.updateMany({nota:{$lt:5}}, {$set:{aprobado:false}}) replaceOne(filtro, nuevoDoc) Sustituye el documento completo. Ejemplo: db.alumnos.replaceOne({nombre:\"Ana\"}, {nombre:\"Ana\", nota:10}) \u26a0\ufe0f Usa $set para modificar solo algunos campos y no perder el resto . \ud83d\udd39 Eliminaci\u00f3n Comando Descripci\u00f3n deleteOne() Elimina el primer documento que cumpla la condici\u00f3n. Ejemplo: db.alumnos.deleteOne({nombre:\"Luis\"}) deleteMany() Elimina todos los documentos que cumplan la condici\u00f3n. Ejemplo: db.alumnos.deleteMany({nota:{$lt:5}}) Ejemplo use biblioteca db.libros.insertMany([ {titulo:\"1984\", autor:\"Orwell\", a\u00f1o:1949}, {titulo:\"Fahrenheit 451\", autor:\"Bradbury\", a\u00f1o:1953} ]) db.libros.find() db.libros.updateOne({titulo:\"1984\"}, {$set:{a\u00f1o:1950}}) db.libros.find({a\u00f1o:{$gte:1950}}) db.libros.deleteOne({titulo:\"Fahrenheit 451\"}) \ud83d\udd39 Consultas avanzadas y ordenaci\u00f3n Comando Descripci\u00f3n sort() Ordena los resultados. 1 ascendente, -1 descendente. Ejemplo: db.alumnos.find().sort({nota:-1}) limit() Limita el n\u00famero de resultados. Ejemplo: db.alumnos.find().limit(3) countDocuments() Devuelve el n\u00famero de documentos que cumplen un filtro. Ejemplo: db.alumnos.countDocuments({nota:{$gte:5}}) \ud83d\udd39 \u00cdndices Comando Descripci\u00f3n createIndex({campo:1}) Crea un \u00edndice ascendente. Ejemplo: db.alumnos.createIndex({nombre:1}) getIndexes() Muestra los \u00edndices existentes. Ejemplo: db.alumnos.getIndexes() dropIndex(\"nombre_1\") Elimina un \u00edndice. Ejemplo: db.alumnos.dropIndex(\"nombre_1\") \ud83d\udd39 Informaci\u00f3n \u00fatil del entorno Comando Descripci\u00f3n db.stats() Muestra estad\u00edsticas sobre la base de datos. Ejemplo: db.stats() db.coleccion.stats() Muestra estad\u00edsticas sobre una colecci\u00f3n. Ejemplo: db.alumnos.stats() db.version() Devuelve la versi\u00f3n de MongoDB. Ejemplo: db.version() \ud83d\udd39 Consultas avanzadas con aggregate() El m\u00e9todo aggregate() permite realizar consultas complejas y procesamientos de datos en varias etapas, similares a las funciones de GROUP BY, JOIN o HAVING en SQL. Cada etapa del pipeline (tuber\u00eda) transforma los datos paso a paso. Estructura b\u00e1sica db.coleccion.aggregate([ { <etapa1> }, { <etapa2> }, ... ]) Cada etapa (stage) se representa mediante un objeto precedido por $, que indica la operaci\u00f3n a realizar. Etapa Descripci\u00f3n $match Filtra documentos (equivalente a WHERE ). Ejemplo: { $match: { ciudad: \"Valencia\" } } $project Selecciona campos espec\u00edficos o crea nuevos. Ejemplo: { $project: { _id:0, nombre:1, nota:1 } } $sort Ordena los resultados. Ejemplo: { $sort: { nota: -1 } } $limit Limita el n\u00famero de resultados. Ejemplo: { $limit: 5 } $skip Omite un n\u00famero de documentos. Ejemplo: { $skip: 10 } $group Agrupa los documentos por un campo y calcula valores agregados (como COUNT , SUM , AVG ). Ejemplo: { $group: { _id: \"$curso\", media: { $avg: \"$nota\" } } } $count Devuelve el n\u00famero total de documentos resultantes. Ejemplo: { $count: \"total\" } $lookup Realiza una uni\u00f3n entre colecciones (similar a JOIN ). Ejemplo: { $lookup: { from: \"profesores\", localField: \"idProfesor\", foreignField: \"_id\", as: \"infoProfesor\" } } $unwind Descompone arrays en m\u00faltiples documentos. Ejemplo: { $unwind: \"$aficiones\" } Ejemplo Supongamos que quieres agrupar los libros por autor y calcular el a\u00f1o promedio de publicaci\u00f3n de sus obras: db.libros.aggregate([ { $group: { _id: \"$autor\", // agrupamos por autor promedioA\u00f1o: { $avg: \"$a\u00f1o\" }, // promedio de a\u00f1os cantidadLibros: { $sum: 1 } // n\u00famero de libros por autor } } ]) \u2705 Resumen Categor\u00eda Comandos clave \ud83d\udcda Base de datos show dbs , use , db.getName() , db.dropDatabase() \ud83d\udcc2 Colecciones show collections , db.createCollection() , db.coleccion.drop() \u2795 Inserci\u00f3n db.coleccion.insertOne() , db.coleccion.insertMany() \ud83d\udd0d Consulta db.coleccion.find() , db.coleccion.findOne() , .sort() , .limit() \u270f\ufe0f Actualizaci\u00f3n db.coleccion.updateOne() , db.coleccion.updateMany() , $set \u274c Eliminaci\u00f3n db.coleccion.deleteOne() , db.coleccion.deleteMany() \ud83e\udde9 \u00cdndices db.coleccion.createIndex() , db.coleccion.getIndexes() , db.coleccion.dropIndex() \ud83d\udcc8 Estad\u00edsticas db.stats() , db.coleccion.stats() , db.version()","title":"\ud83d\udd39Comandos"},{"location":"mongo/comandos/#comandos-de-mongodb-y-su-utilizacion","text":"Los comandos b\u00e1sicos de MongoDB ya se trabajaron en 1.\u00ba de DAM, cuando se introdujo el modelo NoSQL y las operaciones fundamentales sobre colecciones y documentos. En este tema no se pretende volver a explicarlos desde cero, sino ofrecer un resumen pr\u00e1ctico y actualizado con los comandos m\u00e1s \u00fatiles para consultar, ordenar, filtrar y gestionar datos en MongoDB, que te servir\u00e1 como recordatorio y punto de partida para los ejercicios de este m\u00f3dulo. MongoDB utiliza su propia shell interactiva , llamada mongosh , que permite ejecutar comandos para administrar bases de datos, colecciones y documentos. Su sintaxis es muy similar a JavaScript , ya que cada comando se ejecuta sobre un objeto base : db.coleccion.operacion() db \u2192 representa la base de datos actual. coleccion \u2192 el nombre de la colecci\u00f3n sobre la que actuamos. operacion() \u2192 el comando que deseamos ejecutar.","title":"\ud83d\udd39 Comandos de MongoDB y su utilizaci\u00f3n"},{"location":"mongo/comandos/#sobre-bases-de-datos","text":"Comando Descripci\u00f3n Ejemplo show dbs Muestra todas las bases de datos existentes. show dbs use <nombre> Cambia a una base de datos (la crea si no existe). use biblioteca db.getName() Muestra el nombre de la base de datos actual. db.getName() db.dropDatabase() Elimina la base de datos actual. db.dropDatabase()","title":"\ud83d\udd39 Sobre bases de datos"},{"location":"mongo/comandos/#sobre-colecciones","text":"Comando Descripci\u00f3n show collections Lista todas las colecciones de la base de datos. Ejemplo: show collections db.createCollection(\"nombre\") Crea una colecci\u00f3n vac\u00eda. Ejemplo: db.createCollection(\"alumnos\") db.coleccion.drop() Elimina una colecci\u00f3n completa. Ejemplo: db.alumnos.drop() db.coleccion.renameCollection(\"nuevoNombre\") Cambia el nombre de una colecci\u00f3n. Ejemplo: db.alumnos.renameCollection(\"estudiantes\")","title":"\ud83d\udd39 Sobre colecciones"},{"location":"mongo/comandos/#operaciones-crud","text":"","title":"\ud83d\udd39 Operaciones CRUD"},{"location":"mongo/comandos/#insercion","text":"Comando Descripci\u00f3n insertOne() Inserta un solo documento. Ejemplo: db.alumnos.insertOne({nombre:\"Ana\", nota:8}) insertMany() Inserta varios documentos a la vez. Ejemplo: db.alumnos.insertMany([{nombre:\"Luis\", nota:7}, {nombre:\"Marta\", nota:9}]) \ud83d\udccc Si la colecci\u00f3n no existe, MongoDB la crear\u00e1 autom\u00e1ticamente en el momento de la inserci\u00f3n. Inserci\u00f3n especificando el id Si en la inserci\u00f3n del documento no se especifica el campo _id , como es el caso de los ejemplos anteriores, Mongo lo genera autom\u00e1ticamente de tipo ObjectId . Pero nosotros podemos poner este campo _id con el valor que queramos. Eso s\u00ed, debemos asegurarnos de que ese valor no lo use ning\u00fan otro documento de la colecci\u00f3n, o nos dar\u00e1 un error.","title":"\ud83d\udd39Inserci\u00f3n"},{"location":"mongo/comandos/#busqueda","text":"Comando Descripci\u00f3n find() Devuelve todos los documentos de la colecci\u00f3n. Ejemplo: db.alumnos.find() findOne() Devuelve el primer documento que cumple una condici\u00f3n. Ejemplo: db.alumnos.findOne({nombre:\"Ana\"}) find(criterio, proyecci\u00f3n) Permite filtrar y mostrar solo algunos campos. Ejemplo: db.alumnos.find({nota:{$gte:8}}, {nombre:1, _id:0}) \ud83d\udcd8 Operadores comunes : $eq (igual), $ne (distinto), $gt (mayor que), $lt (menor que), $gte (mayor o igual), $lte (menor o igual), $in , $and , $or .","title":"\ud83d\udd39B\u00fasqueda"},{"location":"mongo/comandos/#actualizacion","text":"Comando Descripci\u00f3n updateOne(filtro, cambios) Actualiza el primer documento que cumpla la condici\u00f3n. Ejemplo: db.alumnos.updateOne({nombre:\"Ana\"}, {$set:{nota:9}}) updateMany(filtro, cambios) Actualiza todos los documentos que cumplan la condici\u00f3n. Ejemplo: db.alumnos.updateMany({nota:{$lt:5}}, {$set:{aprobado:false}}) replaceOne(filtro, nuevoDoc) Sustituye el documento completo. Ejemplo: db.alumnos.replaceOne({nombre:\"Ana\"}, {nombre:\"Ana\", nota:10}) \u26a0\ufe0f Usa $set para modificar solo algunos campos y no perder el resto .","title":"\ud83d\udd39 Actualizaci\u00f3n"},{"location":"mongo/comandos/#eliminacion","text":"Comando Descripci\u00f3n deleteOne() Elimina el primer documento que cumpla la condici\u00f3n. Ejemplo: db.alumnos.deleteOne({nombre:\"Luis\"}) deleteMany() Elimina todos los documentos que cumplan la condici\u00f3n. Ejemplo: db.alumnos.deleteMany({nota:{$lt:5}}) Ejemplo use biblioteca db.libros.insertMany([ {titulo:\"1984\", autor:\"Orwell\", a\u00f1o:1949}, {titulo:\"Fahrenheit 451\", autor:\"Bradbury\", a\u00f1o:1953} ]) db.libros.find() db.libros.updateOne({titulo:\"1984\"}, {$set:{a\u00f1o:1950}}) db.libros.find({a\u00f1o:{$gte:1950}}) db.libros.deleteOne({titulo:\"Fahrenheit 451\"})","title":"\ud83d\udd39 Eliminaci\u00f3n"},{"location":"mongo/comandos/#consultas-avanzadas-y-ordenacion","text":"Comando Descripci\u00f3n sort() Ordena los resultados. 1 ascendente, -1 descendente. Ejemplo: db.alumnos.find().sort({nota:-1}) limit() Limita el n\u00famero de resultados. Ejemplo: db.alumnos.find().limit(3) countDocuments() Devuelve el n\u00famero de documentos que cumplen un filtro. Ejemplo: db.alumnos.countDocuments({nota:{$gte:5}})","title":"\ud83d\udd39 Consultas avanzadas y ordenaci\u00f3n"},{"location":"mongo/comandos/#indices","text":"Comando Descripci\u00f3n createIndex({campo:1}) Crea un \u00edndice ascendente. Ejemplo: db.alumnos.createIndex({nombre:1}) getIndexes() Muestra los \u00edndices existentes. Ejemplo: db.alumnos.getIndexes() dropIndex(\"nombre_1\") Elimina un \u00edndice. Ejemplo: db.alumnos.dropIndex(\"nombre_1\")","title":"\ud83d\udd39 \u00cdndices"},{"location":"mongo/comandos/#informacion-util-del-entorno","text":"Comando Descripci\u00f3n db.stats() Muestra estad\u00edsticas sobre la base de datos. Ejemplo: db.stats() db.coleccion.stats() Muestra estad\u00edsticas sobre una colecci\u00f3n. Ejemplo: db.alumnos.stats() db.version() Devuelve la versi\u00f3n de MongoDB. Ejemplo: db.version()","title":"\ud83d\udd39 Informaci\u00f3n \u00fatil del entorno"},{"location":"mongo/comandos/#consultas-avanzadas-con-aggregate","text":"El m\u00e9todo aggregate() permite realizar consultas complejas y procesamientos de datos en varias etapas, similares a las funciones de GROUP BY, JOIN o HAVING en SQL. Cada etapa del pipeline (tuber\u00eda) transforma los datos paso a paso. Estructura b\u00e1sica db.coleccion.aggregate([ { <etapa1> }, { <etapa2> }, ... ]) Cada etapa (stage) se representa mediante un objeto precedido por $, que indica la operaci\u00f3n a realizar. Etapa Descripci\u00f3n $match Filtra documentos (equivalente a WHERE ). Ejemplo: { $match: { ciudad: \"Valencia\" } } $project Selecciona campos espec\u00edficos o crea nuevos. Ejemplo: { $project: { _id:0, nombre:1, nota:1 } } $sort Ordena los resultados. Ejemplo: { $sort: { nota: -1 } } $limit Limita el n\u00famero de resultados. Ejemplo: { $limit: 5 } $skip Omite un n\u00famero de documentos. Ejemplo: { $skip: 10 } $group Agrupa los documentos por un campo y calcula valores agregados (como COUNT , SUM , AVG ). Ejemplo: { $group: { _id: \"$curso\", media: { $avg: \"$nota\" } } } $count Devuelve el n\u00famero total de documentos resultantes. Ejemplo: { $count: \"total\" } $lookup Realiza una uni\u00f3n entre colecciones (similar a JOIN ). Ejemplo: { $lookup: { from: \"profesores\", localField: \"idProfesor\", foreignField: \"_id\", as: \"infoProfesor\" } } $unwind Descompone arrays en m\u00faltiples documentos. Ejemplo: { $unwind: \"$aficiones\" } Ejemplo Supongamos que quieres agrupar los libros por autor y calcular el a\u00f1o promedio de publicaci\u00f3n de sus obras: db.libros.aggregate([ { $group: { _id: \"$autor\", // agrupamos por autor promedioA\u00f1o: { $avg: \"$a\u00f1o\" }, // promedio de a\u00f1os cantidadLibros: { $sum: 1 } // n\u00famero de libros por autor } } ])","title":"\ud83d\udd39 Consultas avanzadas con aggregate()"},{"location":"mongo/comandos/#resumen","text":"Categor\u00eda Comandos clave \ud83d\udcda Base de datos show dbs , use , db.getName() , db.dropDatabase() \ud83d\udcc2 Colecciones show collections , db.createCollection() , db.coleccion.drop() \u2795 Inserci\u00f3n db.coleccion.insertOne() , db.coleccion.insertMany() \ud83d\udd0d Consulta db.coleccion.find() , db.coleccion.findOne() , .sort() , .limit() \u270f\ufe0f Actualizaci\u00f3n db.coleccion.updateOne() , db.coleccion.updateMany() , $set \u274c Eliminaci\u00f3n db.coleccion.deleteOne() , db.coleccion.deleteMany() \ud83e\udde9 \u00cdndices db.coleccion.createIndex() , db.coleccion.getIndexes() , db.coleccion.dropIndex() \ud83d\udcc8 Estad\u00edsticas db.stats() , db.coleccion.stats() , db.version()","title":"\u2705 Resumen"},{"location":"mongo/conexion/","text":"\ud83d\udd39Conexi\u00f3n Para conectar una aplicaci\u00f3n escrita en Kotlin con una base de datos MongoDB , existen dos opciones principales, seg\u00fan el objetivo y el nivel de control que se necesite sobre las operaciones: 1\ufe0f\u20e3 Conexi\u00f3n con el controlador oficial de MongoDB ( MongoDB Driver ) Es la opci\u00f3n m\u00e1s directa y de bajo nivel. Permite trabajar con las clases del paquete com.mongodb o org.bson para realizar operaciones CRUD (crear, leer, actualizar y eliminar) sobre las colecciones. Se utiliza cuando se quiere tener control total sobre las consultas, la conexi\u00f3n y la conversi\u00f3n de documentos BSON a objetos Kotlin. 2\ufe0f\u20e3 Conexi\u00f3n mediante una librer\u00eda de mapeo (ORM/ODM), como KMongo KMongo es una capa de abstracci\u00f3n sobre el driver oficial, dise\u00f1ada espec\u00edficamente para Kotlin. Permite trabajar con data classes y consultas tipadas, simplificando el c\u00f3digo y haci\u00e9ndolo m\u00e1s idiom\u00e1tico. Es la opci\u00f3n m\u00e1s recomendada para proyectos educativos o empresariales donde se busca claridad, seguridad de tipos y menor c\u00f3digo repetitivo. A continuaci\u00f3n veremos un ejemplo pr\u00e1ctico de cada una de las dos formas de conectar Kotlin con MongoDB. Ambos ejemplos se ejecutar\u00e1n sobre MongoDB Community Server en local y se crear\u00e1n con Gradle desde IntelliJ. 3\ufe0f\u20e3 Creamos un nuevo proyecto llamado BDNoSQL . \ud83d\udd39Kotlin + Gradle + Driver oficial 1. A\u00f1adir las dependencias en Gradle En el archivo build.gradle.kts , dentro del bloque dependencies, a\u00f1adimos: dependencies { implementation(\"org.mongodb:mongodb-driver-sync:5.2.0\") } 2. Ejemplo sobre la colecci\u00f3n Libros Crea un archivo main.kt en un paquete nuevo llamado mongo con el siguiente c\u00f3digo: import com.mongodb.client.MongoClients import com.mongodb.client.MongoCollection import com.mongodb.client.MongoDatabase import org.bson.Document fun main() { // 1Conexi\u00f3n al servidor local val uri = \"mongodb://localhost:27017\" val client = MongoClients.create(uri) // Seleccionar base de datos val database: MongoDatabase = client.getDatabase(\"biblioteca\") // Seleccionar colecci\u00f3n val coleccion: MongoCollection<Document> = database.getCollection(\"libros\") // Insertar un documento val doc = Document(\"titulo\", \"1984\") .append(\"autor\", \"George Orwell\") .append(\"a\u00f1o\", 1949) coleccion.insertOne(doc) println(\"Documento insertado correctamente.\") // Leer documentos for (libro in coleccion.find()) { println(libro.toJson()) } client.close() } Advertencia Al ejecutar el programa os aparecer\u00e1 el siguiene mensaje: Esto no es un error, solo una advertencia. MongoDB intenta usar SLF4J (Simple Logging Facade for Java) para mostrar mensajes de registro (logs) sobre la conexi\u00f3n, operaciones, etc. Como tu proyecto no incluye ninguna librer\u00eda de logging, te avisa de que no podr\u00e1 mostrar esos logs internos, pero el programa sigue funcionando perfectamente. \ud83d\udd39Kotlin + Gradle + KMongo 1. A\u00f1adir las dependencias en Gradle En el archivo build.gradle.kts , dentro del bloque dependencies, a\u00f1adimos: dependencies { implementation(\"org.litote.kmongo:kmongo:5.1.0\") } 2. Ejemplo sobre la colecci\u00f3n Libros Crea un archivo main.kt en un paquete nuevo llamado kmongo con el siguiente c\u00f3digo: import org.litote.kmongo.* data class Libros(val titulo: String, val autor: String, val a\u00f1o: Int) fun main() { // Crear conexi\u00f3n val client = KMongo.createClient() // Por defecto: mongodb://localhost:27017 val database = client.getDatabase(\"biblioteca\") val coleccion = database.getCollection<Libros>() // Insertar datos val libro = Libros(\"Fahrenheit 451\", \"Ray Bradbury\", 1953) coleccion.insertOne(libro) println(\"Libro insertado correctamente\") // Consultar datos val resultados = coleccion.find() resultados.forEach { println(it) } client.close() } Nota Aparecer\u00e1n los dos libros insertados, tanto en el ejemplo anterior como en este, ya que la colecci\u00f3n Libros es la misma. \ud83d\udd39Control de errores Cuando un programa se conecta a una base de datos como MongoDB, siempre existe la posibilidad de que ocurran errores: la base de datos puede no estar disponible, los datos pueden ser incorrectos o una operaci\u00f3n puede fallar por un conflicto o por formato inv\u00e1lido. Por eso, es importante incluir control de errores en el c\u00f3digo, especialmente en las operaciones de conexi\u00f3n y en las operaciones CRUD (insertar, leer, actualizar, eliminar). El control de errores se hace con bloques try-catch . As\u00ed puedes capturar las excepciones y evitar que el programa se detenga bruscamente. Buenas pr\u00e1cticas: Verificar que el servidor MongoDB est\u00e1 en ejecuci\u00f3n antes de conectar. Usar try-catch en las secciones cr\u00edticas del programa (especialmente conexi\u00f3n e inserci\u00f3n). Mostrar mensajes claros al usuario para facilitar el diagn\u00f3stico. Cerrar el cliente con client.close() en un bloque finally si se usa una conexi\u00f3n persistente. try { val client = KMongo.createClient() // Por defecto: mongodb://localhost:27017 val database = client.getDatabase(\"biblioteca\") val coleccion = database.getCollection<Libros>() // Insertar datos val libro = Libros(\"Fahrenheit 451\", \"Ray Bradbury\", 1953) coleccion.insertOne(libro) println(\"Libro insertado correctamente\") // Consultar datos val resultados = coleccion.find() resultados.forEach { println(it) } client.close() } catch (e: Exception) { println(\"\u26a0\ufe0f Error al acceder a MongoDB: ${e.message}\") } finally { //si se usa una conexi\u00f3n persistente. // Cierre seguro del cliente client?.close() println(\"\ud83d\udd12 Conexi\u00f3n cerrada.\") } \ud83d\udd39Construir una base de datos MongoDB Existen principalmente dos maneras de crear y poblar una base de datos en MongoDB: 1. Inserci\u00f3n manual de documentos Podemos crear los documentos directamente desde la consola de MongoDB o desde un programa, utilizando instrucciones insertOne() o insertMany() con los datos escritos a mano. Por ejemplo: Insertar un pel\u00edcula en una colecci\u00f3n llamada peliculas. db.peliculas.insertOne({ \"titol\": \"La noia terrible\", \"director\": \"Michael Verhoeven\", \"genere\": \"Drama\", \"any\": 1990 }) Este m\u00e9todo es \u00fatil para hacer pruebas r\u00e1pidas o a\u00f1adir registros sueltos, pero no resulta pr\u00e1ctico cuando tenemos muchos datos. 2. Lectura desde un archivo JSON Cuando ya disponemos de un conjunto de datos estructurados (por ejemplo, en un archivo json ), podemos leer el archivo desde un programa y convertir cada elemento en un documento MongoDB . Esto permite crear colecciones completas de forma autom\u00e1tica, sin escribir los documentos uno a uno. A partir de este archivo, un programa en Kotlin puede leer los datos y a\u00f1adirlos autom\u00e1ticamente a una colecci\u00f3n MongoDB mediante las funciones insertOne() o insertMany(). En este ejemplo veremos c\u00f3mo crear una base de datos MongoDB, utilizando el controlador KMongo , a partir de un archivo JSON llamado peliculas.json , que ubicaremos en un paquete nuevo llamado peliculas , dentro del paquete kmongo ( src/main/kotlin/kmongo/peliculas/ ). Vamos a desarrollar dos programas equivalentes, pero utilizando dos librer\u00edas diferentes para el tratamiento de los datos JSON: kotlinx.serialization y Jackson . Ambos programas trabajar\u00e1n con el mismo archivo de datos peliculas.json , y realizar\u00e1n exactamente los mismos pasos: Lee el archivo JSON. Convertir los datos le\u00eddos en una lista de objetos de la clase Pelicula. Insertar los objetos en una colecci\u00f3n de MongoDB llamada peliculas, utilizando la librer\u00eda KMongo , que permite trabajar directamente con clases de datos Kotlin (data class). Recupera y muestra los datos almacenados en la colecci\u00f3n. -- \ud83d\udd39Estructura del archivo JSON [ { \"titol\": \"La noia terrible\", \"titol_or\": \"Das schreckliche M\u00e4dchen\", \"director\": \"Michael Verhoeven\", \"genere\": \"Drama\", \"durada\": 93, \"any\": 1990, \"actors\": [\"Lena Stolze\", \"Hans-Reinhard M\u00fcller\", \"Monika Baumgartner\"], \"sinopsi\": \"Una noia alemanya que viu a Passau inicia una investigaci\u00f3 sobre el passat...\" }, { \"titol\": \"Hardcore\", \"titol_or\": null, \"director\": \"Paul Schrader\", \"genere\": \"Comedia\", \"durada\": 109, \"any\": 1979, \"actors\": [\"Peter Boyle\", \"George C. Scott\", \"Season Hubley\"], \"sinopsi\": \"Un home profundament religi\u00f3s contracta un detectiu per trobar la seua filla...\" } ] \ud83d\udd39Estructura del proyecto BDNoSQL/ \u251c\u2500 build.gradle.kts \u251c\u2500 src/ \u2514\u2500 main/ \u2514\u2500 kotlin/ \u2514\u2500 kmongo/ \u2514\u2500 peliculas/ \u251c\u2500 MainSerialization.kt \u2192 programa con kotlinx.serialization \u2514\u2500 MainJackson.kt \u2192 programa con Jackson \u2514\u2500 peliculas.json \u2192 archivo con las pel\u00edculas \ud83d\udd39Programa utilizando kotlinx.serialization : MainSerialization.kt package kmongo.peliculas import kotlinx.serialization.Serializable import kotlinx.serialization.builtins.ListSerializer import kotlinx.serialization.json.Json import org.litote.kmongo.* import org.litote.kmongo.getCollection import java.io.File @Serializable data class PeliculaSerializada( val titol: String = \"\", val titol_or: String? = null, val director: String = \"\", val genere: String = \"\", val durada: Int = 0, val any: Int = 0, val actors: List<String>? = null, val sinopsi: String = \"\" ) fun main() { val ruta = \"src/main/kotlin/kmongo/peliculas/peliculas.json\" val archivo = File(ruta) if (!archivo.exists()) { println(\"\u274c No se ha encontrado el archivo $ruta\") return } println(\"\ud83d\udcd6 Leyendo archivo $ruta ...\") try { // 1\ufe0f\u20e3 Leer y deserializar las pel\u00edculas con kotlinx.serialization val json = Json { ignoreUnknownKeys = true } val peliculas: List<PeliculaSerializada> = json.decodeFromString( ListSerializer(PeliculaSerializada.serializer()), archivo.readText(Charsets.UTF_8) ) println(\"\u2705 Se han le\u00eddo ${peliculas.size} pel\u00edculas del archivo.\") // Conexi\u00f3n a MongoDB con KMongo val cliente = KMongo.createClient(\"mongodb://localhost:27017\") val bd = cliente.getDatabase(\"peliculas_db\") val coleccion = bd.getCollection<PeliculaSerializada>() // Limpiar colecci\u00f3n coleccion.drop() // Insertar todas las pel\u00edculas directamente (sin Document) coleccion.insertMany(peliculas) println(\"\ud83d\udcbe ${peliculas.size} pel\u00edculas insertadas correctamente.\\n\") // Consultar y mostrar todas val lista = coleccion.find().toList() println(\"\ud83d\udcdc Contenido de la colecci\u00f3n en MongoDB:\\n\") var i = 1 for (p in lista) { println(\"\ud83c\udf9e\ufe0f $i. ${p.titol} (${p.any})\") println(\" \ud83c\udfac Director: ${p.director}\") println(\" \ud83e\udde9 G\u00e9nero: ${p.genere}\") println(\" \u23f1\ufe0f Duraci\u00f3n: ${p.durada} min\") if (p.actors != null) println(\" \ud83d\udc65 Actores: ${p.actors.joinToString(\", \")}\") println(\" \ud83d\udcdd Sinopsis: ${p.sinopsi.take(100)}...\") println(\"---------------------------------------------------------\") i++ } // Ejemplo de consulta: solo dramas ordenados por t\u00edtulo val dramas = coleccion.find(PeliculaSerializada::genere eq \"Drama\").sortedBy { it.titol } println(\"\\n\ud83c\udfad --- Pel\u00edculas de g\u00e9nero 'Drama' ---\\n\") for (p in dramas) { println(\"${p.titol} - ${p.director} (${p.any})\") } cliente.close() println(\"\\n\ud83d\udd1a Proceso finalizado correctamente.\") } catch (e: Exception) { println(\"\u274c Error durante la ejecuci\u00f3n: ${e.message}\") e.printStackTrace() } } \ud83d\udd39Programa utilizando Jackson : MainJackson.kt package kmongo.peliculas import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.readValue import org.litote.kmongo.KMongo import org.litote.kmongo.eq import org.litote.kmongo.getCollection import java.io.File import org.litote.kmongo.Id import org.litote.kmongo.newId data class Pelicula( val _id: Id<Pelicula> = newId(), val titol: String = \"\", val titol_or: String? = null, val director: String = \"\", val genere: String = \"\", val durada: Int = 0, val any: Int = 0, val actors: List<String>? = null, val sinopsi: String = \"\" ) fun main() { val ruta = \"src/main/kotlin/kmongo/peliculas/peliculas.json\" val archivo = File(ruta) if (!archivo.exists()) { println(\"\u274c No se ha encontrado el archivo $ruta\") return } println(\"Leyendo archivo $ruta ...\") try { // Crear el mapper de Jackson val mapper = jacksonObjectMapper() // Leer el archivo y convertirlo en lista de Pelicula val peliculas: List<Pelicula> = mapper.readValue(archivo) println(\"\u2705 Se han le\u00eddo ${peliculas.size} pel\u00edculas del archivo.\") // Conectarse a MongoDB con KMongo val cliente = KMongo.createClient(\"mongodb://localhost:27017\") val baseDatos = cliente.getDatabase(\"peliculas_db\") val coleccion = baseDatos.getCollection<Pelicula>() // Limpiar colecci\u00f3n (opcional) coleccion.drop() // Insertar todas las pel\u00edculas de golpe coleccion.insertMany(peliculas) println(\" ${peliculas.size} pel\u00edculas insertadas correctamente.\\n\") // Mostrar todas las pel\u00edculas val lista = coleccion.find().toList() println(\"Contenido de la colecci\u00f3n en MongoDB:\\n\") var i = 1 for (p in lista) { println(\"\ud83c\udf9e\ufe0f $i. ${p.titol} (${p.any})\") println(\" \ud83c\udfac Director: ${p.director}\") println(\" \ud83e\udde9 G\u00e9nero: ${p.genere}\") println(\" \u23f1\ufe0f Duraci\u00f3n: ${p.durada} min\") if (p.actors != null) println(\" \ud83d\udc65 Actores: ${p.actors.joinToString(\", \")}\") println(\" \ud83d\udcdd Sinopsis: ${p.sinopsi.take(100)}...\") println(\"---------------------------------------------------------\") i++ } // Consultar solo los dramas, ordenados por t\u00edtulo println(\"\\n--- Pel\u00edculas de g\u00e9nero 'Drama' ---\\n\") val dramas = coleccion.find(Pelicula::genere eq \"Drama\").sortedBy { it.titol } for (p in dramas) { println(\"${p.titol} - ${p.director} (${p.any})\") } cliente.close() println(\"\\n Proceso finalizado correctamente.\") } catch (e: Exception) { println(\"\u274c Error durante la ejecuci\u00f3n: ${e.message}\") e.printStackTrace() } } \ud83d\udd39Salida esperada:","title":"\ud83d\udd39Desde Kotlin"},{"location":"mongo/conexion/#conexion","text":"Para conectar una aplicaci\u00f3n escrita en Kotlin con una base de datos MongoDB , existen dos opciones principales, seg\u00fan el objetivo y el nivel de control que se necesite sobre las operaciones: 1\ufe0f\u20e3 Conexi\u00f3n con el controlador oficial de MongoDB ( MongoDB Driver ) Es la opci\u00f3n m\u00e1s directa y de bajo nivel. Permite trabajar con las clases del paquete com.mongodb o org.bson para realizar operaciones CRUD (crear, leer, actualizar y eliminar) sobre las colecciones. Se utiliza cuando se quiere tener control total sobre las consultas, la conexi\u00f3n y la conversi\u00f3n de documentos BSON a objetos Kotlin. 2\ufe0f\u20e3 Conexi\u00f3n mediante una librer\u00eda de mapeo (ORM/ODM), como KMongo KMongo es una capa de abstracci\u00f3n sobre el driver oficial, dise\u00f1ada espec\u00edficamente para Kotlin. Permite trabajar con data classes y consultas tipadas, simplificando el c\u00f3digo y haci\u00e9ndolo m\u00e1s idiom\u00e1tico. Es la opci\u00f3n m\u00e1s recomendada para proyectos educativos o empresariales donde se busca claridad, seguridad de tipos y menor c\u00f3digo repetitivo. A continuaci\u00f3n veremos un ejemplo pr\u00e1ctico de cada una de las dos formas de conectar Kotlin con MongoDB. Ambos ejemplos se ejecutar\u00e1n sobre MongoDB Community Server en local y se crear\u00e1n con Gradle desde IntelliJ. 3\ufe0f\u20e3 Creamos un nuevo proyecto llamado BDNoSQL .","title":"\ud83d\udd39Conexi\u00f3n"},{"location":"mongo/conexion/#kotlin-gradle-driver-oficial","text":"1. A\u00f1adir las dependencias en Gradle En el archivo build.gradle.kts , dentro del bloque dependencies, a\u00f1adimos: dependencies { implementation(\"org.mongodb:mongodb-driver-sync:5.2.0\") } 2. Ejemplo sobre la colecci\u00f3n Libros Crea un archivo main.kt en un paquete nuevo llamado mongo con el siguiente c\u00f3digo: import com.mongodb.client.MongoClients import com.mongodb.client.MongoCollection import com.mongodb.client.MongoDatabase import org.bson.Document fun main() { // 1Conexi\u00f3n al servidor local val uri = \"mongodb://localhost:27017\" val client = MongoClients.create(uri) // Seleccionar base de datos val database: MongoDatabase = client.getDatabase(\"biblioteca\") // Seleccionar colecci\u00f3n val coleccion: MongoCollection<Document> = database.getCollection(\"libros\") // Insertar un documento val doc = Document(\"titulo\", \"1984\") .append(\"autor\", \"George Orwell\") .append(\"a\u00f1o\", 1949) coleccion.insertOne(doc) println(\"Documento insertado correctamente.\") // Leer documentos for (libro in coleccion.find()) { println(libro.toJson()) } client.close() } Advertencia Al ejecutar el programa os aparecer\u00e1 el siguiene mensaje: Esto no es un error, solo una advertencia. MongoDB intenta usar SLF4J (Simple Logging Facade for Java) para mostrar mensajes de registro (logs) sobre la conexi\u00f3n, operaciones, etc. Como tu proyecto no incluye ninguna librer\u00eda de logging, te avisa de que no podr\u00e1 mostrar esos logs internos, pero el programa sigue funcionando perfectamente.","title":"\ud83d\udd39Kotlin + Gradle + Driver oficial"},{"location":"mongo/conexion/#kotlin-gradle-kmongo","text":"1. A\u00f1adir las dependencias en Gradle En el archivo build.gradle.kts , dentro del bloque dependencies, a\u00f1adimos: dependencies { implementation(\"org.litote.kmongo:kmongo:5.1.0\") } 2. Ejemplo sobre la colecci\u00f3n Libros Crea un archivo main.kt en un paquete nuevo llamado kmongo con el siguiente c\u00f3digo: import org.litote.kmongo.* data class Libros(val titulo: String, val autor: String, val a\u00f1o: Int) fun main() { // Crear conexi\u00f3n val client = KMongo.createClient() // Por defecto: mongodb://localhost:27017 val database = client.getDatabase(\"biblioteca\") val coleccion = database.getCollection<Libros>() // Insertar datos val libro = Libros(\"Fahrenheit 451\", \"Ray Bradbury\", 1953) coleccion.insertOne(libro) println(\"Libro insertado correctamente\") // Consultar datos val resultados = coleccion.find() resultados.forEach { println(it) } client.close() } Nota Aparecer\u00e1n los dos libros insertados, tanto en el ejemplo anterior como en este, ya que la colecci\u00f3n Libros es la misma.","title":"\ud83d\udd39Kotlin + Gradle + KMongo"},{"location":"mongo/conexion/#control-de-errores","text":"Cuando un programa se conecta a una base de datos como MongoDB, siempre existe la posibilidad de que ocurran errores: la base de datos puede no estar disponible, los datos pueden ser incorrectos o una operaci\u00f3n puede fallar por un conflicto o por formato inv\u00e1lido. Por eso, es importante incluir control de errores en el c\u00f3digo, especialmente en las operaciones de conexi\u00f3n y en las operaciones CRUD (insertar, leer, actualizar, eliminar). El control de errores se hace con bloques try-catch . As\u00ed puedes capturar las excepciones y evitar que el programa se detenga bruscamente. Buenas pr\u00e1cticas: Verificar que el servidor MongoDB est\u00e1 en ejecuci\u00f3n antes de conectar. Usar try-catch en las secciones cr\u00edticas del programa (especialmente conexi\u00f3n e inserci\u00f3n). Mostrar mensajes claros al usuario para facilitar el diagn\u00f3stico. Cerrar el cliente con client.close() en un bloque finally si se usa una conexi\u00f3n persistente. try { val client = KMongo.createClient() // Por defecto: mongodb://localhost:27017 val database = client.getDatabase(\"biblioteca\") val coleccion = database.getCollection<Libros>() // Insertar datos val libro = Libros(\"Fahrenheit 451\", \"Ray Bradbury\", 1953) coleccion.insertOne(libro) println(\"Libro insertado correctamente\") // Consultar datos val resultados = coleccion.find() resultados.forEach { println(it) } client.close() } catch (e: Exception) { println(\"\u26a0\ufe0f Error al acceder a MongoDB: ${e.message}\") } finally { //si se usa una conexi\u00f3n persistente. // Cierre seguro del cliente client?.close() println(\"\ud83d\udd12 Conexi\u00f3n cerrada.\") }","title":"\ud83d\udd39Control de errores"},{"location":"mongo/conexion/#construir-una-base-de-datos-mongodb","text":"Existen principalmente dos maneras de crear y poblar una base de datos en MongoDB: 1. Inserci\u00f3n manual de documentos Podemos crear los documentos directamente desde la consola de MongoDB o desde un programa, utilizando instrucciones insertOne() o insertMany() con los datos escritos a mano. Por ejemplo: Insertar un pel\u00edcula en una colecci\u00f3n llamada peliculas. db.peliculas.insertOne({ \"titol\": \"La noia terrible\", \"director\": \"Michael Verhoeven\", \"genere\": \"Drama\", \"any\": 1990 }) Este m\u00e9todo es \u00fatil para hacer pruebas r\u00e1pidas o a\u00f1adir registros sueltos, pero no resulta pr\u00e1ctico cuando tenemos muchos datos. 2. Lectura desde un archivo JSON Cuando ya disponemos de un conjunto de datos estructurados (por ejemplo, en un archivo json ), podemos leer el archivo desde un programa y convertir cada elemento en un documento MongoDB . Esto permite crear colecciones completas de forma autom\u00e1tica, sin escribir los documentos uno a uno. A partir de este archivo, un programa en Kotlin puede leer los datos y a\u00f1adirlos autom\u00e1ticamente a una colecci\u00f3n MongoDB mediante las funciones insertOne() o insertMany(). En este ejemplo veremos c\u00f3mo crear una base de datos MongoDB, utilizando el controlador KMongo , a partir de un archivo JSON llamado peliculas.json , que ubicaremos en un paquete nuevo llamado peliculas , dentro del paquete kmongo ( src/main/kotlin/kmongo/peliculas/ ). Vamos a desarrollar dos programas equivalentes, pero utilizando dos librer\u00edas diferentes para el tratamiento de los datos JSON: kotlinx.serialization y Jackson . Ambos programas trabajar\u00e1n con el mismo archivo de datos peliculas.json , y realizar\u00e1n exactamente los mismos pasos: Lee el archivo JSON. Convertir los datos le\u00eddos en una lista de objetos de la clase Pelicula. Insertar los objetos en una colecci\u00f3n de MongoDB llamada peliculas, utilizando la librer\u00eda KMongo , que permite trabajar directamente con clases de datos Kotlin (data class). Recupera y muestra los datos almacenados en la colecci\u00f3n. -- \ud83d\udd39Estructura del archivo JSON [ { \"titol\": \"La noia terrible\", \"titol_or\": \"Das schreckliche M\u00e4dchen\", \"director\": \"Michael Verhoeven\", \"genere\": \"Drama\", \"durada\": 93, \"any\": 1990, \"actors\": [\"Lena Stolze\", \"Hans-Reinhard M\u00fcller\", \"Monika Baumgartner\"], \"sinopsi\": \"Una noia alemanya que viu a Passau inicia una investigaci\u00f3 sobre el passat...\" }, { \"titol\": \"Hardcore\", \"titol_or\": null, \"director\": \"Paul Schrader\", \"genere\": \"Comedia\", \"durada\": 109, \"any\": 1979, \"actors\": [\"Peter Boyle\", \"George C. Scott\", \"Season Hubley\"], \"sinopsi\": \"Un home profundament religi\u00f3s contracta un detectiu per trobar la seua filla...\" } ] \ud83d\udd39Estructura del proyecto BDNoSQL/ \u251c\u2500 build.gradle.kts \u251c\u2500 src/ \u2514\u2500 main/ \u2514\u2500 kotlin/ \u2514\u2500 kmongo/ \u2514\u2500 peliculas/ \u251c\u2500 MainSerialization.kt \u2192 programa con kotlinx.serialization \u2514\u2500 MainJackson.kt \u2192 programa con Jackson \u2514\u2500 peliculas.json \u2192 archivo con las pel\u00edculas \ud83d\udd39Programa utilizando kotlinx.serialization : MainSerialization.kt package kmongo.peliculas import kotlinx.serialization.Serializable import kotlinx.serialization.builtins.ListSerializer import kotlinx.serialization.json.Json import org.litote.kmongo.* import org.litote.kmongo.getCollection import java.io.File @Serializable data class PeliculaSerializada( val titol: String = \"\", val titol_or: String? = null, val director: String = \"\", val genere: String = \"\", val durada: Int = 0, val any: Int = 0, val actors: List<String>? = null, val sinopsi: String = \"\" ) fun main() { val ruta = \"src/main/kotlin/kmongo/peliculas/peliculas.json\" val archivo = File(ruta) if (!archivo.exists()) { println(\"\u274c No se ha encontrado el archivo $ruta\") return } println(\"\ud83d\udcd6 Leyendo archivo $ruta ...\") try { // 1\ufe0f\u20e3 Leer y deserializar las pel\u00edculas con kotlinx.serialization val json = Json { ignoreUnknownKeys = true } val peliculas: List<PeliculaSerializada> = json.decodeFromString( ListSerializer(PeliculaSerializada.serializer()), archivo.readText(Charsets.UTF_8) ) println(\"\u2705 Se han le\u00eddo ${peliculas.size} pel\u00edculas del archivo.\") // Conexi\u00f3n a MongoDB con KMongo val cliente = KMongo.createClient(\"mongodb://localhost:27017\") val bd = cliente.getDatabase(\"peliculas_db\") val coleccion = bd.getCollection<PeliculaSerializada>() // Limpiar colecci\u00f3n coleccion.drop() // Insertar todas las pel\u00edculas directamente (sin Document) coleccion.insertMany(peliculas) println(\"\ud83d\udcbe ${peliculas.size} pel\u00edculas insertadas correctamente.\\n\") // Consultar y mostrar todas val lista = coleccion.find().toList() println(\"\ud83d\udcdc Contenido de la colecci\u00f3n en MongoDB:\\n\") var i = 1 for (p in lista) { println(\"\ud83c\udf9e\ufe0f $i. ${p.titol} (${p.any})\") println(\" \ud83c\udfac Director: ${p.director}\") println(\" \ud83e\udde9 G\u00e9nero: ${p.genere}\") println(\" \u23f1\ufe0f Duraci\u00f3n: ${p.durada} min\") if (p.actors != null) println(\" \ud83d\udc65 Actores: ${p.actors.joinToString(\", \")}\") println(\" \ud83d\udcdd Sinopsis: ${p.sinopsi.take(100)}...\") println(\"---------------------------------------------------------\") i++ } // Ejemplo de consulta: solo dramas ordenados por t\u00edtulo val dramas = coleccion.find(PeliculaSerializada::genere eq \"Drama\").sortedBy { it.titol } println(\"\\n\ud83c\udfad --- Pel\u00edculas de g\u00e9nero 'Drama' ---\\n\") for (p in dramas) { println(\"${p.titol} - ${p.director} (${p.any})\") } cliente.close() println(\"\\n\ud83d\udd1a Proceso finalizado correctamente.\") } catch (e: Exception) { println(\"\u274c Error durante la ejecuci\u00f3n: ${e.message}\") e.printStackTrace() } } \ud83d\udd39Programa utilizando Jackson : MainJackson.kt package kmongo.peliculas import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper import com.fasterxml.jackson.module.kotlin.readValue import org.litote.kmongo.KMongo import org.litote.kmongo.eq import org.litote.kmongo.getCollection import java.io.File import org.litote.kmongo.Id import org.litote.kmongo.newId data class Pelicula( val _id: Id<Pelicula> = newId(), val titol: String = \"\", val titol_or: String? = null, val director: String = \"\", val genere: String = \"\", val durada: Int = 0, val any: Int = 0, val actors: List<String>? = null, val sinopsi: String = \"\" ) fun main() { val ruta = \"src/main/kotlin/kmongo/peliculas/peliculas.json\" val archivo = File(ruta) if (!archivo.exists()) { println(\"\u274c No se ha encontrado el archivo $ruta\") return } println(\"Leyendo archivo $ruta ...\") try { // Crear el mapper de Jackson val mapper = jacksonObjectMapper() // Leer el archivo y convertirlo en lista de Pelicula val peliculas: List<Pelicula> = mapper.readValue(archivo) println(\"\u2705 Se han le\u00eddo ${peliculas.size} pel\u00edculas del archivo.\") // Conectarse a MongoDB con KMongo val cliente = KMongo.createClient(\"mongodb://localhost:27017\") val baseDatos = cliente.getDatabase(\"peliculas_db\") val coleccion = baseDatos.getCollection<Pelicula>() // Limpiar colecci\u00f3n (opcional) coleccion.drop() // Insertar todas las pel\u00edculas de golpe coleccion.insertMany(peliculas) println(\" ${peliculas.size} pel\u00edculas insertadas correctamente.\\n\") // Mostrar todas las pel\u00edculas val lista = coleccion.find().toList() println(\"Contenido de la colecci\u00f3n en MongoDB:\\n\") var i = 1 for (p in lista) { println(\"\ud83c\udf9e\ufe0f $i. ${p.titol} (${p.any})\") println(\" \ud83c\udfac Director: ${p.director}\") println(\" \ud83e\udde9 G\u00e9nero: ${p.genere}\") println(\" \u23f1\ufe0f Duraci\u00f3n: ${p.durada} min\") if (p.actors != null) println(\" \ud83d\udc65 Actores: ${p.actors.joinToString(\", \")}\") println(\" \ud83d\udcdd Sinopsis: ${p.sinopsi.take(100)}...\") println(\"---------------------------------------------------------\") i++ } // Consultar solo los dramas, ordenados por t\u00edtulo println(\"\\n--- Pel\u00edculas de g\u00e9nero 'Drama' ---\\n\") val dramas = coleccion.find(Pelicula::genere eq \"Drama\").sortedBy { it.titol } for (p in dramas) { println(\"${p.titol} - ${p.director} (${p.any})\") } cliente.close() println(\"\\n Proceso finalizado correctamente.\") } catch (e: Exception) { println(\"\u274c Error durante la ejecuci\u00f3n: ${e.message}\") e.printStackTrace() } } \ud83d\udd39Salida esperada:","title":"\ud83d\udd39Construir una base de datos MongoDB"},{"location":"mongo/instalacion/","text":"Instalaci\u00f3n Hoy en d\u00eda existen m\u00faltiples opciones para trabajar con MongoDB, tanto a nivel de instalaci\u00f3n como de desarrollo y administraci\u00f3n. Aqu\u00ed tienes un resumen actualizado, organizado por categor\u00edas \ud83d\udc47 \u2699\ufe0f 1. Opciones de instalaci\u00f3n y despliegue Opci\u00f3n Descripci\u00f3n Ideal para \ud83d\udda5\ufe0f MongoDB Community Server Versi\u00f3n gratuita que se instala localmente en Windows, Linux o macOS. Pr\u00e1cticas locales, entornos educativos. \ud83d\udc33 MongoDB en Docker Se ejecuta como contenedor con docker-compose o comandos docker run . Entornos de desarrollo r\u00e1pidos y reproducibles. \u2601\ufe0f MongoDB Atlas Servicio en la nube oficial de MongoDB. Permite crear cl\u00fasteres gratuitos o de pago, gestionados por Mongo. Proyectos web, microservicios, despliegues reales. \ud83e\udde9 MongoDB Local + Atlas Sync Permite sincronizar datos locales con una base remota en Atlas. Aplicaciones con modo offline/online. \ud83d\udcbb 2. Herramientas de administraci\u00f3n y visualizaci\u00f3n Herramienta Tipo Descripci\u00f3n \ud83e\udded MongoDB Compass GUI oficial Interfaz gr\u00e1fica para consultar, insertar y analizar datos. \ud83d\udc18 DBeaver GUI universal Permite conectarse a Mongo y a otras bases de datos (SQL y NoSQL). \ud83e\uddd1\u200d\ud83d\udcbb Robo 3T (antiguo Robomongo) GUI ligera Muy utilizada para tareas b\u00e1sicas de exploraci\u00f3n. \ud83d\udcdc mongosh Consola oficial Shell de comandos moderno (sustituye a mongo ). \ud83c\udfaf De entre todas las opciones posibles para instalar y administrar MongoDB, hemos elegido utilizar la versi\u00f3n Community junto con Mongo Shell (mongosh) por su simplicidad, ligereza y adecuaci\u00f3n a los objetivos de esta unidad. \ud83d\udc27 Instalaci\u00f3n en Linux Para realizar la instalaci\u00f3n m\u00e1s b\u00e1sica, podemos hacerlo sin permisos de administrador. Si los tenemos, todo ser\u00e1 m\u00e1s c\u00f3modo, pero si no, tambi\u00e9n es posible, como veremos y destacaremos a continuaci\u00f3n. \u2699\ufe0f Instalaci\u00f3n del servidor (Linux) Desde la p\u00e1gina oficial de MongoDB: https://www.mongodb.com/try/download/community vamos al men\u00fa Products \u2192 Community Edition \u2192 Community Server y descargamos la versi\u00f3n apropiada para nuestro sistema operativo. Observa que, en el caso de Linux, hay muchas versiones para distintas distribuciones. Es recomendable elegir el paquete .tgz , ya que simplemente descomprimiendo el archivo se completa la instalaci\u00f3n b\u00e1sica. Por ejemplo, para Ubuntu 22.04 de 64 bits, en el momento de redactar estos apuntes, el archivo ser\u00eda: https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu2204-8.2.1.tgz Recuerda comprobar siempre que la versi\u00f3n coincide con la de tu sistema operativo. Sencillamente, descomprimiremos este archivo en el lugar que queramos, y con eso ya tendremos la instalaci\u00f3n b\u00e1sica lista. \ud83d\udcc1 Una vez instalado, crearemos el directorio de datos, que por defecto ha de estar ubicado en la raiz de la instalaci\u00f3n: mkdir /data mkdir /data/db El \u00fanico problema que podr\u00edamos tener, si no somos administradores, es no tener permiso para crear ese directorio. En ese caso, crearemos otro directorio alternativo y, en el momento de arrancar el servidor, le indicaremos esa ubicaci\u00f3n. \u25b6\ufe0f La forma de arrancar el servidor ser\u00e1: <directoro ra\u00edz de MongoDB>./bin/mongod Opcionalmente, podemos indicarle a MongoDB d\u00f3nde se encuentra la base de datos (si no lo especificamos, asumir\u00e1 por defecto que est\u00e1 en /data/db): <directorio ra\u00edz de MongoDB>./bin/mongod --dbpath <directorio_de_la_BD> Una vez arrancamos el servidor, y si todo es correcto, aparecer\u00e1n una serie de mensajes informativos y el servidor quedar\u00e1 en espera de recibir peticiones del cliente: Nota Una vez que el servidor est\u00e1 en marcha, no debemos cerrar esa terminal, ya que al hacerlo detendr\u00edamos el servidor. \u2699\ufe0f Instalaci\u00f3n del cliente MongoShell (Linux) Desde la p\u00e1gina de MongoDB https://www.mongodb.com/try/download/shell vamos al men\u00fa Products \u2192 Tools \u2192 MongoDB Shell , y descargamos la versi\u00f3n apropiada para nuestro sistema operativo. Observa que, en el caso de Linux, existen muchas versiones para diferentes distribuciones. Es recomendable elegir el paquete .tgz , ya que simplemente descomprimiendo el archivo se completa la instalaci\u00f3n. En el caso de Ubuntu 22.04 de 64 bits, seleccionaremos la opci\u00f3n gen\u00e9rica \u201cLinux 64\u201d, ya que es la que ofrece el paquete .tgz. El archivo correspondiente es: https://downloads.mongodb.com/compass/mongosh-2.4.0-linux-x64.tgz Recuerda asegurarte siempre de que la versi\u00f3n sea la correcta para tu sistema. Sencillamente descomprimiremos este archivo en el lugar que queramos, y con eso ya tendremos hecha la instalaci\u00f3n b\u00e1sica. \u25b6\ufe0f La forma de arrancar el cliente ser\u00e1: <directori ra\u00edz de Mongosh>./bin/mongosh \ud83e\ude9f Instalaci\u00f3n en Windows \u2699\ufe0f Instalaci\u00f3n del servidor (Windows) Desde la p\u00e1gina oficial de MongoDB: https://www.mongodb.com/try/download/community vamos al men\u00fa Products \u2192 Community Edition \u2192 Community Server y descargamos la versi\u00f3n apropiada para nuestro sistema operativo, que se distribuye como un archivo .msi ejecutable. \ud83d\udd3dEn el momento de redactar estos apuntes, la versi\u00f3n de 64 bits m\u00e1s reciente: https://fastdl.mongodb.org/windows/mongodb-windows-x86_64-8.2.1-signed.msi Durante la instalaci\u00f3n, se te preguntar\u00e1 si deseas instalarlo como un servicio. Si eliges esta opci\u00f3n, el programa se iniciar\u00e1 autom\u00e1ticamente con el sistema y no tendr\u00e1s que ejecutarlo manualmente cada vez. \ud83c\udfafSi instalaste MongoDB como servicio, se inicia autom\u00e1ticamente al arrancar Windows, puedes comprobarlo con: net start | find \"MongoDB\" Nota Si eliges no instalar MongoDB como servicio, deber\u00e1s iniciarlo manualmente cada vez que quieras usarlo. En este caso, es necesario crear la carpeta donde se almacenar\u00e1n los datos de la base de datos. \ud83d\udcbb Instalaci\u00f3n del cliente Mongo Shell (Windows) Para conectarnos como clientes, debemos hacerlo desde un terminal, utilizando mongosh.exe, que es la interfaz de l\u00ednea de comandos (CLI) oficial de MongoDB. Esta herramienta permite interactuar con la base de datos mediante comandos en JavaScript. \ud83d\udd3dDescargamos la versi\u00f3n correspondiente de MongoDB Shell para Windows desde la p\u00e1gina oficial: https://www.mongodb.com/try/download/shell \ud83d\udd3dEn el momento de redactar estos apuntes, la versi\u00f3n de 64 bits m\u00e1s reciente: https://downloads.mongodb.com/compass/mongosh-2.5.8-x64.msi Una vez el servidor est\u00e9 activo, simplemente escribe: mongosh Dentro del shell, prueba con: show dbs Si ves las bases de datos (admin, config, local), todo est\u00e1 funcionando correctamente: Mongo Compass Tambi\u00e9n pod\u00e9is descargar la versi\u00f3n MongoDB Compass , que es la herramienta gr\u00e1fica oficial de MongoDB, la cual permite visualizar, explorar y administrar bases de datos MongoDB sin necesidad de utilizar la l\u00ednea de comandos. https://downloads.mongodb.com/compass/mongodb-compass-1.45.3-win32-x64.exe Probar el funcionament Para probar su funcionamiento, vamos a ejecutar un par de comandos: uno para guardar un documento y otro para recuperarlo. En cualquier operaci\u00f3n, debemos escribir db seguido del nombre de la colecci\u00f3n, y despu\u00e9s la operaci\u00f3n que queremos realizar. Con el siguiente comando: db.ejemplo.insertOne({ msg: \"Hola, \u00bfqu\u00e9 tal?\" }) Nos responder\u00e1 con: { acknowledged: true, insertedId: ObjectId('68ff6004ab24a06f35cebea4') } Indicando que se ha insertado un documento en la colecci\u00f3n ejemplo (si no exist\u00eda, la crear\u00e1 autom\u00e1ticamente). Y con el siguiente comando recuperamos la informaci\u00f3n: db.ejemplo.find() Lo que nos devolver\u00e1 algo como: { \"_id\" : ObjectId(\"56cc1acd73b559230de8f71b\"), \"msg\" : \"Hola, \u00bfqu\u00e9 tal?\" } Todo esto se realiza en la misma terminal, y cada uno de nosotros obtendr\u00e1 un n\u00famero diferente en el campo ObjectId . En la siguiente imagen pueden verse las dos operaciones. En realidad, estamos conectados a una base de datos llamada test. Podemos crear y utilizar m\u00e1s de una base de datos, pero en este curso ser\u00e1 m\u00e1s que suficiente trabajar con esta. Para comprobarlo, podemos ejecutar la siguiente instrucci\u00f3n, que nos devuelve el nombre de la base de datos actual : db.getName()","title":"\ud83d\udd39Instalaci\u00f3n"},{"location":"mongo/instalacion/#instalacion","text":"Hoy en d\u00eda existen m\u00faltiples opciones para trabajar con MongoDB, tanto a nivel de instalaci\u00f3n como de desarrollo y administraci\u00f3n. Aqu\u00ed tienes un resumen actualizado, organizado por categor\u00edas \ud83d\udc47 \u2699\ufe0f 1. Opciones de instalaci\u00f3n y despliegue Opci\u00f3n Descripci\u00f3n Ideal para \ud83d\udda5\ufe0f MongoDB Community Server Versi\u00f3n gratuita que se instala localmente en Windows, Linux o macOS. Pr\u00e1cticas locales, entornos educativos. \ud83d\udc33 MongoDB en Docker Se ejecuta como contenedor con docker-compose o comandos docker run . Entornos de desarrollo r\u00e1pidos y reproducibles. \u2601\ufe0f MongoDB Atlas Servicio en la nube oficial de MongoDB. Permite crear cl\u00fasteres gratuitos o de pago, gestionados por Mongo. Proyectos web, microservicios, despliegues reales. \ud83e\udde9 MongoDB Local + Atlas Sync Permite sincronizar datos locales con una base remota en Atlas. Aplicaciones con modo offline/online. \ud83d\udcbb 2. Herramientas de administraci\u00f3n y visualizaci\u00f3n Herramienta Tipo Descripci\u00f3n \ud83e\udded MongoDB Compass GUI oficial Interfaz gr\u00e1fica para consultar, insertar y analizar datos. \ud83d\udc18 DBeaver GUI universal Permite conectarse a Mongo y a otras bases de datos (SQL y NoSQL). \ud83e\uddd1\u200d\ud83d\udcbb Robo 3T (antiguo Robomongo) GUI ligera Muy utilizada para tareas b\u00e1sicas de exploraci\u00f3n. \ud83d\udcdc mongosh Consola oficial Shell de comandos moderno (sustituye a mongo ). \ud83c\udfaf De entre todas las opciones posibles para instalar y administrar MongoDB, hemos elegido utilizar la versi\u00f3n Community junto con Mongo Shell (mongosh) por su simplicidad, ligereza y adecuaci\u00f3n a los objetivos de esta unidad.","title":"Instalaci\u00f3n"},{"location":"mongo/instalacion/#instalacion-en-linux","text":"Para realizar la instalaci\u00f3n m\u00e1s b\u00e1sica, podemos hacerlo sin permisos de administrador. Si los tenemos, todo ser\u00e1 m\u00e1s c\u00f3modo, pero si no, tambi\u00e9n es posible, como veremos y destacaremos a continuaci\u00f3n. \u2699\ufe0f Instalaci\u00f3n del servidor (Linux) Desde la p\u00e1gina oficial de MongoDB: https://www.mongodb.com/try/download/community vamos al men\u00fa Products \u2192 Community Edition \u2192 Community Server y descargamos la versi\u00f3n apropiada para nuestro sistema operativo. Observa que, en el caso de Linux, hay muchas versiones para distintas distribuciones. Es recomendable elegir el paquete .tgz , ya que simplemente descomprimiendo el archivo se completa la instalaci\u00f3n b\u00e1sica. Por ejemplo, para Ubuntu 22.04 de 64 bits, en el momento de redactar estos apuntes, el archivo ser\u00eda: https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu2204-8.2.1.tgz Recuerda comprobar siempre que la versi\u00f3n coincide con la de tu sistema operativo. Sencillamente, descomprimiremos este archivo en el lugar que queramos, y con eso ya tendremos la instalaci\u00f3n b\u00e1sica lista. \ud83d\udcc1 Una vez instalado, crearemos el directorio de datos, que por defecto ha de estar ubicado en la raiz de la instalaci\u00f3n: mkdir /data mkdir /data/db El \u00fanico problema que podr\u00edamos tener, si no somos administradores, es no tener permiso para crear ese directorio. En ese caso, crearemos otro directorio alternativo y, en el momento de arrancar el servidor, le indicaremos esa ubicaci\u00f3n. \u25b6\ufe0f La forma de arrancar el servidor ser\u00e1: <directoro ra\u00edz de MongoDB>./bin/mongod Opcionalmente, podemos indicarle a MongoDB d\u00f3nde se encuentra la base de datos (si no lo especificamos, asumir\u00e1 por defecto que est\u00e1 en /data/db): <directorio ra\u00edz de MongoDB>./bin/mongod --dbpath <directorio_de_la_BD> Una vez arrancamos el servidor, y si todo es correcto, aparecer\u00e1n una serie de mensajes informativos y el servidor quedar\u00e1 en espera de recibir peticiones del cliente: Nota Una vez que el servidor est\u00e1 en marcha, no debemos cerrar esa terminal, ya que al hacerlo detendr\u00edamos el servidor. \u2699\ufe0f Instalaci\u00f3n del cliente MongoShell (Linux) Desde la p\u00e1gina de MongoDB https://www.mongodb.com/try/download/shell vamos al men\u00fa Products \u2192 Tools \u2192 MongoDB Shell , y descargamos la versi\u00f3n apropiada para nuestro sistema operativo. Observa que, en el caso de Linux, existen muchas versiones para diferentes distribuciones. Es recomendable elegir el paquete .tgz , ya que simplemente descomprimiendo el archivo se completa la instalaci\u00f3n. En el caso de Ubuntu 22.04 de 64 bits, seleccionaremos la opci\u00f3n gen\u00e9rica \u201cLinux 64\u201d, ya que es la que ofrece el paquete .tgz. El archivo correspondiente es: https://downloads.mongodb.com/compass/mongosh-2.4.0-linux-x64.tgz Recuerda asegurarte siempre de que la versi\u00f3n sea la correcta para tu sistema. Sencillamente descomprimiremos este archivo en el lugar que queramos, y con eso ya tendremos hecha la instalaci\u00f3n b\u00e1sica. \u25b6\ufe0f La forma de arrancar el cliente ser\u00e1: <directori ra\u00edz de Mongosh>./bin/mongosh","title":"\ud83d\udc27 Instalaci\u00f3n en Linux"},{"location":"mongo/instalacion/#instalacion-en-windows","text":"\u2699\ufe0f Instalaci\u00f3n del servidor (Windows) Desde la p\u00e1gina oficial de MongoDB: https://www.mongodb.com/try/download/community vamos al men\u00fa Products \u2192 Community Edition \u2192 Community Server y descargamos la versi\u00f3n apropiada para nuestro sistema operativo, que se distribuye como un archivo .msi ejecutable. \ud83d\udd3dEn el momento de redactar estos apuntes, la versi\u00f3n de 64 bits m\u00e1s reciente: https://fastdl.mongodb.org/windows/mongodb-windows-x86_64-8.2.1-signed.msi Durante la instalaci\u00f3n, se te preguntar\u00e1 si deseas instalarlo como un servicio. Si eliges esta opci\u00f3n, el programa se iniciar\u00e1 autom\u00e1ticamente con el sistema y no tendr\u00e1s que ejecutarlo manualmente cada vez. \ud83c\udfafSi instalaste MongoDB como servicio, se inicia autom\u00e1ticamente al arrancar Windows, puedes comprobarlo con: net start | find \"MongoDB\" Nota Si eliges no instalar MongoDB como servicio, deber\u00e1s iniciarlo manualmente cada vez que quieras usarlo. En este caso, es necesario crear la carpeta donde se almacenar\u00e1n los datos de la base de datos. \ud83d\udcbb Instalaci\u00f3n del cliente Mongo Shell (Windows) Para conectarnos como clientes, debemos hacerlo desde un terminal, utilizando mongosh.exe, que es la interfaz de l\u00ednea de comandos (CLI) oficial de MongoDB. Esta herramienta permite interactuar con la base de datos mediante comandos en JavaScript. \ud83d\udd3dDescargamos la versi\u00f3n correspondiente de MongoDB Shell para Windows desde la p\u00e1gina oficial: https://www.mongodb.com/try/download/shell \ud83d\udd3dEn el momento de redactar estos apuntes, la versi\u00f3n de 64 bits m\u00e1s reciente: https://downloads.mongodb.com/compass/mongosh-2.5.8-x64.msi Una vez el servidor est\u00e9 activo, simplemente escribe: mongosh Dentro del shell, prueba con: show dbs Si ves las bases de datos (admin, config, local), todo est\u00e1 funcionando correctamente: Mongo Compass Tambi\u00e9n pod\u00e9is descargar la versi\u00f3n MongoDB Compass , que es la herramienta gr\u00e1fica oficial de MongoDB, la cual permite visualizar, explorar y administrar bases de datos MongoDB sin necesidad de utilizar la l\u00ednea de comandos. https://downloads.mongodb.com/compass/mongodb-compass-1.45.3-win32-x64.exe Probar el funcionament Para probar su funcionamiento, vamos a ejecutar un par de comandos: uno para guardar un documento y otro para recuperarlo. En cualquier operaci\u00f3n, debemos escribir db seguido del nombre de la colecci\u00f3n, y despu\u00e9s la operaci\u00f3n que queremos realizar. Con el siguiente comando: db.ejemplo.insertOne({ msg: \"Hola, \u00bfqu\u00e9 tal?\" }) Nos responder\u00e1 con: { acknowledged: true, insertedId: ObjectId('68ff6004ab24a06f35cebea4') } Indicando que se ha insertado un documento en la colecci\u00f3n ejemplo (si no exist\u00eda, la crear\u00e1 autom\u00e1ticamente). Y con el siguiente comando recuperamos la informaci\u00f3n: db.ejemplo.find() Lo que nos devolver\u00e1 algo como: { \"_id\" : ObjectId(\"56cc1acd73b559230de8f71b\"), \"msg\" : \"Hola, \u00bfqu\u00e9 tal?\" } Todo esto se realiza en la misma terminal, y cada uno de nosotros obtendr\u00e1 un n\u00famero diferente en el campo ObjectId . En la siguiente imagen pueden verse las dos operaciones. En realidad, estamos conectados a una base de datos llamada test. Podemos crear y utilizar m\u00e1s de una base de datos, pero en este curso ser\u00e1 m\u00e1s que suficiente trabajar con esta. Para comprobarlo, podemos ejecutar la siguiente instrucci\u00f3n, que nos devuelve el nombre de la base de datos actual : db.getName()","title":"\ud83e\ude9f Instalaci\u00f3n en Windows"},{"location":"mongo/json/","text":"JSON JSON (JavaScript Object Notation) es un formato de texto ligero utilizado para almacenar e intercambiar informaci\u00f3n estructurada entre aplicaciones. Aunque su sintaxis proviene de JavaScript, hoy en d\u00eda es independiente del lenguaje y se usa ampliamente en entornos como Kotlin, Java, Python, Node.js, bases de datos NoSQL, APIs REST, etc. Un fichero JSON est\u00e1 compuesto por pares clave\u2013valor , donde: Las claves siempre van entre comillas dobles \" \". Los valores pueden ser: Cadenas de texto (\"texto\") N\u00fameros (42) Booleanos (true o false) Objetos (otro conjunto de pares clave-valor { ... }) Arrays o listas ([ ... ]) Valor nulo (null) Ejemplos de estructuras JSON \ud83d\udd39 Objeto simple : Representa un \u00fanico elemento con propiedades b\u00e1sicas. { \"nombre\": \"Ana\", \"edad\": 25, \"ciudad\": \"Valencia\" } \ud83d\udd39 Objeto con array (lista de valores): Incluye un campo que contiene una lista. { \"nombre\": \"Pedro\", \"aficiones\": [\"cine\", \"f\u00fatbol\", \"viajar\"] } \ud83d\udd39 Objeto con otro objeto anidado : Un campo puede contener a su vez otro objeto JSON. { \"nombre\": \"Luc\u00eda\", \"edad\": 30, \"direccion\": { \"calle\": \"Gran V\u00eda\", \"ciudad\": \"Madrid\", \"codigo_postal\": 28013 } } \ud83d\udd39 Array de objetos : Cuando necesitamos almacenar varios elementos similares (por ejemplo, una lista de productos o alumnos). { \"alumnos\": [ { \"nombre\": \"Carlos\", \"nota\": 8.5 }, { \"nombre\": \"Mar\u00eda\", \"nota\": 9.2 }, { \"nombre\": \"Laura\", \"nota\": 7.8 } ] } \ud83d\udd39 Combinaci\u00f3n compleja (objetos + arrays + anidamientos) : Para representar datos estructurados, como los de una tienda online. { \"pedido\": { \"id\": 101, \"fecha\": \"2025-10-11\", \"cliente\": { \"nombre\": \"Javier L\u00f3pez\", \"email\": \"jlopez@example.com\" }, \"productos\": [ { \"nombre\": \"Rat\u00f3n inal\u00e1mbrico\", \"precio\": 19.99, \"cantidad\": 1 }, { \"nombre\": \"Teclado mec\u00e1nico\", \"precio\": 49.95, \"cantidad\": 1 } ], \"total\": 69.94 } } \ud83d\udd39 Array de objetos principales : Tambi\u00e9n se puede usar un array como estructura ra\u00edz, por ejemplo, para representar varios registros en un mismo fichero: [ { \"nombre\": \"Ana\", \"edad\": 25 }, { \"nombre\": \"Pedro\", \"edad\": 31 }, { \"nombre\": \"Luc\u00eda\", \"edad\": 28 } ]","title":"\ud83d\udd39JSON"},{"location":"mongo/json/#json","text":"JSON (JavaScript Object Notation) es un formato de texto ligero utilizado para almacenar e intercambiar informaci\u00f3n estructurada entre aplicaciones. Aunque su sintaxis proviene de JavaScript, hoy en d\u00eda es independiente del lenguaje y se usa ampliamente en entornos como Kotlin, Java, Python, Node.js, bases de datos NoSQL, APIs REST, etc. Un fichero JSON est\u00e1 compuesto por pares clave\u2013valor , donde: Las claves siempre van entre comillas dobles \" \". Los valores pueden ser: Cadenas de texto (\"texto\") N\u00fameros (42) Booleanos (true o false) Objetos (otro conjunto de pares clave-valor { ... }) Arrays o listas ([ ... ]) Valor nulo (null) Ejemplos de estructuras JSON \ud83d\udd39 Objeto simple : Representa un \u00fanico elemento con propiedades b\u00e1sicas. { \"nombre\": \"Ana\", \"edad\": 25, \"ciudad\": \"Valencia\" } \ud83d\udd39 Objeto con array (lista de valores): Incluye un campo que contiene una lista. { \"nombre\": \"Pedro\", \"aficiones\": [\"cine\", \"f\u00fatbol\", \"viajar\"] } \ud83d\udd39 Objeto con otro objeto anidado : Un campo puede contener a su vez otro objeto JSON. { \"nombre\": \"Luc\u00eda\", \"edad\": 30, \"direccion\": { \"calle\": \"Gran V\u00eda\", \"ciudad\": \"Madrid\", \"codigo_postal\": 28013 } } \ud83d\udd39 Array de objetos : Cuando necesitamos almacenar varios elementos similares (por ejemplo, una lista de productos o alumnos). { \"alumnos\": [ { \"nombre\": \"Carlos\", \"nota\": 8.5 }, { \"nombre\": \"Mar\u00eda\", \"nota\": 9.2 }, { \"nombre\": \"Laura\", \"nota\": 7.8 } ] } \ud83d\udd39 Combinaci\u00f3n compleja (objetos + arrays + anidamientos) : Para representar datos estructurados, como los de una tienda online. { \"pedido\": { \"id\": 101, \"fecha\": \"2025-10-11\", \"cliente\": { \"nombre\": \"Javier L\u00f3pez\", \"email\": \"jlopez@example.com\" }, \"productos\": [ { \"nombre\": \"Rat\u00f3n inal\u00e1mbrico\", \"precio\": 19.99, \"cantidad\": 1 }, { \"nombre\": \"Teclado mec\u00e1nico\", \"precio\": 49.95, \"cantidad\": 1 } ], \"total\": 69.94 } } \ud83d\udd39 Array de objetos principales : Tambi\u00e9n se puede usar un array como estructura ra\u00edz, por ejemplo, para representar varios registros en un mismo fichero: [ { \"nombre\": \"Ana\", \"edad\": 25 }, { \"nombre\": \"Pedro\", \"edad\": 31 }, { \"nombre\": \"Luc\u00eda\", \"edad\": 28 } ]","title":"JSON"}]}